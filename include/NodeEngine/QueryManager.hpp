#ifndef INCLUDE_QUERY_MANAGER__H_
#define INCLUDE_QUERY_MANAGER__H_

#include <NodeEngine/BufferManager.hpp>
#include <NodeEngine/ThreadPool.hpp>
#include <Plans/Query/QuerySubPlanId.hpp>
#include <QueryCompiler/QueryExecutionPlan.hpp>
#include <chrono>
#include <condition_variable>
#include <deque>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <unordered_set>

#include <NodeEngine/QueryStatistics.hpp>
#include <NodeEngine/Reconfigurable.hpp>
#include <NodeEngine/ReconfigurationTask.hpp>
#include <NodeEngine/Task.hpp>
#include <Sources/DataSource.hpp>
#include <Util/ThreadBarrier.hpp>
#include <Util/libcuckoo/cuckoohash_map.hh>
#include <Windowing/WindowHandler/AbstractWindowHandler.hpp>
#include <memory>

namespace NES {

class TupleBuffer;

class CompiledExecutablePipeline;
typedef std::shared_ptr<CompiledExecutablePipeline> CompiledExecutablePipelinePtr;

class BufferManager;
typedef std::shared_ptr<BufferManager> BufferManagerPtr;

class QueryManager;
typedef std::shared_ptr<QueryManager> QueryManagerPtr;

class QueryExecutionPlan;
typedef std::shared_ptr<QueryExecutionPlan> QueryExecutionPlanPtr;

/**
 * @brief the query manager is the central class to process queries.
 * It is source-driven. Each incoming buffer will add a task to the queue.
 * The query manager maintains three structures:
 * 1.) a data_source map to map one data source to N queries
 * 2.) a window map to map one window to N queries TODO:maybe should be removed later
 * 3.) a data_sink to map one data sink to N queries
 * @Limitations:
 *    - statistics do not cover intermediate buffers
 */
class QueryManager : public std::enable_shared_from_this<QueryManager>, public Reconfigurable {
  public:
    enum ExecutionResult : uint8_t {
        Ok = 0,
        Error,
        Finished
    };

    QueryManager() = delete;
    QueryManager(const QueryManager&) = delete;
    QueryManager& operator=(const QueryManager&) = delete;

    /**
     * @brief
     * @param bufferManager
     */
    explicit QueryManager(BufferManagerPtr bufferManager, uint64_t nodeEngineId);

    ~QueryManager();

    /**
     * @brief register a query by extracting sources, windows and sink and add them to
     * respective map
     * @param QueryExecutionPlan to be deployed
     */
    bool registerQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief deregister a query by extracting sources, windows and sink and remove them
     * from respective map
     * @param QueryExecutionPlan to be deployed
     * @return bool indicating if register was successful
     */
    bool deregisterQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief process task from task queue
     * @param bool indicating if the thread pool is still running
     * @param worker context
     * @return an execution result
     *
     */
    ExecutionResult processNextTask(std::atomic<bool>& running, WorkerContext& workerContext);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each incoming buffer
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the source at which the data arrived
     */
    void addWork(const std::string& sourceId, TupleBuffer& buf);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each buffer generated by the window trigger
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the pipeline stage that will be executed next
     */
    void addWorkForNextPipeline(TupleBuffer& buffer, PipelineStagePtr nextPipeline);

    void destroyCallback(ReconfigurationTask& task) override;

    void reconfigure(ReconfigurationTask&, WorkerContext& context) override;

  private:
    /**
     * @brief finalize task execution by:
     * 1.) update statistics (number of processed tuples and tasks)
     * 2.) release input buffer (give back to the buffer manager)
     * @param reference to processed task
     * @oaram reference to worker context
     */
    void completedWork(Task& task, WorkerContext& workerContext);

  public:
    /**
     * @brief retrieve the execution status of a given local query sub plan id.
     * @param id : the query sub plan id
     * @return status of the query sub plan
     */
    QueryExecutionPlan::QueryExecutionPlanStatus getQepStatus(QuerySubPlanId id);

    /**
     * @brief get general statistics of QueryManager and Buffer Manager
     */
    std::string getQueryManagerStatistics();

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool startQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool stopQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief notify all waiting threads in getWork() to wake up and try again
     */
    void unblockThreads() { cv.notify_all(); }

    /**
     * @brief reset query manager to intial state
     */
    void destroy();

    /**
     * @brief method to return the query statistics
     * @param qep of the particular query
     * @return
     */
    QueryStatisticsPtr getQueryStatistics(QuerySubPlanId qepId);

    size_t getNodeId() const;

    /**
     * @brief this methods adds a reconfiguration task on the worker queue
     * @return true if the reconfiguration task was added correctly on the worker queue
     * N.B.: this does not not mean that the reconfiguration took place but it means that it
     * was scheduled to be executed!
     * @param queryExecutionPlanId: the local QEP to reconfigure
     * @param reconfigurationDescriptor: what to do
     * @param blocking: whether to block until the reconfiguration is done. Mind this parameter because it blocks!
     */
    bool addReconfigurationTask(QuerySubPlanId queryExecutionPlanId, ReconfigurationTask reconfigurationDescriptor, bool blocking = false);

  private:
    friend class ThreadPool;
    friend class NodeEngine;
    /**
    * @brief method to start the thread pool
    * @param nodeEngineId the id of the owning node engine
    * @return bool indicating success
    */
    bool startThreadPool();

    QueryManager::ExecutionResult terminateLoop(WorkerContext&);

    std::deque<Task> taskQueue;
    ThreadPoolPtr threadPool;

    std::map<std::string, std::unordered_set<QueryExecutionPlanPtr>> sourceIdToQueryMap;

    std::unordered_map<QuerySubPlanId, QueryExecutionPlanPtr> runningQEPs;

    //TODO:check if it would be better to put it in the thread context
    mutable std::mutex statisticsMutex;
    cuckoohash_map<QuerySubPlanId, QueryStatisticsPtr> queryToStatisticsMap;

    std::shared_mutex queryMutex;
    std::mutex workMutex;

    std::condition_variable cv;

    BufferManagerPtr bufferManager;
    CompiledExecutablePipelinePtr reconfigurationExecutable;

    size_t nodeEngineId;
};

typedef std::shared_ptr<QueryManager> QueryManagerPtr;

}// namespace NES

#endif /* INCLUDE_query manager_H_ */
