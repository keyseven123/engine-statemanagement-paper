
// Generated from /Users/sumalvico/CLionProjects/nebulastream/nes-core/src/Parsers/NebulaSQL/gen/NebulaSQL.g4 by ANTLR 4.12.0

#include <Parsers/NebulaSQL/gen/NebulaSQLListener.h>

#include "Util/Logger/Logger.hpp"
#include <Parsers/NebulaSQL/gen/NebulaSQLParser.h>

using namespace antlrcpp;
using namespace antlr4;

namespace {

struct NebulaSQLParserStaticData final {
  NebulaSQLParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  NebulaSQLParserStaticData(const NebulaSQLParserStaticData&) = delete;
  NebulaSQLParserStaticData(NebulaSQLParserStaticData&&) = delete;
  NebulaSQLParserStaticData& operator=(const NebulaSQLParserStaticData&) = delete;
  NebulaSQLParserStaticData& operator=(NebulaSQLParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag nebulasqlParserOnceFlag;
NebulaSQLParserStaticData *nebulasqlParserStaticData = nullptr;

void nebulasqlParserInitialize() {
  assert(nebulasqlParserStaticData == nullptr);
  auto staticData = std::make_unique<NebulaSQLParserStaticData>(
    std::vector<std::string>{
      "singleStatement", "statement", "query", "queryOrganization", "queryTerm", 
      "queryPrimary", "querySpecification", "fromClause", "relation", "joinRelation", 
      "joinType", "joinCriteria", "relationPrimary", "functionTable", "fromStatement", 
      "fromStatementBody", "selectClause", "whereClause", "havingClause", 
      "inlineTable", "tableAlias", "multipartIdentifierList", "multipartIdentifier", 
      "namedExpression", "identifier", "strictIdentifier", "quotedIdentifier", 
      "identifierList", "identifierSeq", "errorCapturingIdentifier", "errorCapturingIdentifierExtra", 
      "namedExpressionSeq", "expression", "booleanExpression", "windowedAggregationClause", 
      "aggregationClause", "groupingSet", "windowClause", "watermarkClause", 
      "watermarkParameters", "windowSpec", "timeWindow", "countWindow", 
      "sizeParameter", "advancebyParameter", "timeUnit", "timestampParameter", 
      "functionName", "sinkClause", "sinkType", "sinkTypeZMQ", "nullNotnull", 
      "zmqKeyword", "streamName", "host", "port", "sinkTypeKafka", "kafkaKeyword", 
      "kafkaBroker", "kafkaTopic", "kafkaProducerTimout", "sinkTypeFile", 
      "fileFormat", "sinkTypeMQTT", "qos", "sinkTypeOPC", "sinkTypePrint", 
      "sortItem", "predicate", "valueExpression", "comparisonOperator", 
      "hint", "hintStatement", "primaryExpression", "qualifiedName", "number", 
      "constant", "booleanValue", "strictNonReserved", "ansiNonReserved", 
      "nonReserved"
    },
    std::vector<std::string>{
      "", "';'", "','", "'('", "')'", "'.'", "'/*+'", "'*/'", "", "", "", 
      "'ANY'", "", "", "'AT'", "", "", "'COMMENT'", "'CUBE'", "'DELETE'", 
      "", "'DISTINCT'", "'DIV'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", 
      "'EXISTS'", "'FALSE'", "'FIRST'", "'FOR'", "", "'FULL'", "", "'GROUPING'", 
      "", "'IF'", "", "", "", "", "", "", "'LAST'", "'LEFT'", "'LIKE'", 
      "", "'LIST'", "", "'NATURAL'", "", "'NULL'", "'NULLS'", "'OF'", "", 
      "", "", "'QUERY'", "'RECOVER'", "'RIGHT'", "", "'ROLLUP'", "", "'SETS'", 
      "'SOME'", "'START'", "'TABLE'", "'TO'", "'TRUE'", "'TYPE'", "", "'UNKNOWN'", 
      "'USE'", "'USING'", "'VALUES'", "'WHEN'", "", "", "'WITH'", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'FILE'", 
      "'MQTT'", "'OPC'", "'PRINT'", "", "'CSV_FORMAT'", "'NES_FORMAT'", 
      "'TEXT_FORMAT'", "'AT_MOST_ONCE'", "'AT_LEAST_ONCE'", "", "", "'<=>'", 
      "'<>'", "'!='", "'<'", "", "'>'", "", "'+'", "'-'", "'*'", "'/'", 
      "'%'", "'~'", "'&'", "'|'", "'||'", "'^'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "BACKQUOTED_IDENTIFIER", "ALL", "AND", 
      "ANY", "AS", "ASC", "AT", "BETWEEN", "BY", "COMMENT", "CUBE", "DELETE", 
      "DESC", "DISTINCT", "DIV", "DROP", "ELSE", "END", "ESCAPE", "EXISTS", 
      "FALSE", "FIRST", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "HAVING", 
      "IF", "IN", "INNER", "INSERT", "INTO", "IS", "JOIN", "LAST", "LEFT", 
      "LIKE", "LIMIT", "LIST", "MERGE", "NATURAL", "NOT", "NULLTOKEN", "NULLS", 
      "OF", "ON", "OR", "ORDER", "QUERY", "RECOVER", "RIGHT", "RLIKE", "ROLLUP", 
      "SELECT", "SETS", "SOME", "START", "TABLE", "TO", "TRUE", "TYPE", 
      "UNION", "UNKNOWN", "USE", "USING", "VALUES", "WHEN", "WHERE", "WINDOW", 
      "WITH", "TUMBLING", "SLIDING", "SIZE", "ADVANCE", "MS", "SEC", "MIN", 
      "HOUR", "DAY", "MAX", "AVG", "SUM", "COUNT", "WATERMARK", "OFFSET", 
      "ZMQ", "KAFKA", "FILE", "MQTT", "OPC", "PRINT", "LOCALHOST", "CSV_FORMAT", 
      "NES_FORMAT", "TEXT_FORMAT", "AT_MOST_ONCE", "AT_LEAST_ONCE", "BOOLEAN_VALUE", 
      "EQ", "NSEQ", "NEQ", "NEQJ", "LT", "LTE", "GT", "GTE", "PLUS", "MINUS", 
      "ASTERISK", "SLASH", "PERCENT", "TILDE", "AMPERSAND", "PIPE", "CONCAT_PIPE", 
      "HAT", "STRING", "BIGINT_LITERAL", "SMALLINT_LITERAL", "TINYINT_LITERAL", 
      "INTEGER_VALUE", "EXPONENT_VALUE", "DECIMAL_VALUE", "FLOAT_LITERAL", 
      "DOUBLE_LITERAL", "BIGDECIMAL_LITERAL", "IDENTIFIER", "SIMPLE_COMMENT", 
      "BRACKETED_COMMENT", "WS", "FOUR_OCTETS", "OCTET", "UNRECOGNIZED"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,141,950,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,1,0,1,0,5,0,165,8,0,10,0,12,0,168,9,
  	0,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,5,3,182,8,3,10,3,12,
  	3,185,9,3,3,3,187,8,3,1,3,1,3,1,3,3,3,192,8,3,3,3,194,8,3,1,3,1,3,3,3,
  	198,8,3,1,4,1,4,1,4,1,4,1,4,1,4,5,4,206,8,4,10,4,12,4,209,9,4,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,220,8,5,1,6,1,6,1,6,3,6,225,8,6,1,6,1,
  	6,3,6,229,8,6,1,6,3,6,232,8,6,1,7,1,7,1,7,1,7,5,7,238,8,7,10,7,12,7,241,
  	9,7,1,8,1,8,5,8,245,8,8,10,8,12,8,248,9,8,1,9,1,9,1,9,1,9,3,9,254,8,9,
  	1,9,1,9,1,9,1,9,1,9,3,9,261,8,9,1,10,3,10,264,8,10,1,11,1,11,1,11,1,12,
  	1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,
  	3,12,284,8,12,1,13,1,13,1,13,1,13,1,13,5,13,291,8,13,10,13,12,13,294,
  	9,13,3,13,296,8,13,1,13,1,13,1,13,1,14,1,14,4,14,303,8,14,11,14,12,14,
  	304,1,15,1,15,3,15,309,8,15,1,15,3,15,312,8,15,1,16,1,16,5,16,316,8,16,
  	10,16,12,16,319,9,16,1,16,1,16,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,
  	1,19,1,19,5,19,333,8,19,10,19,12,19,336,9,19,1,19,1,19,1,20,3,20,341,
  	8,20,1,20,1,20,3,20,345,8,20,3,20,347,8,20,1,21,1,21,1,21,5,21,352,8,
  	21,10,21,12,21,355,9,21,1,22,1,22,1,22,5,22,360,8,22,10,22,12,22,363,
  	9,22,1,23,1,23,3,23,367,8,23,1,23,1,23,3,23,371,8,23,3,23,373,8,23,1,
  	24,1,24,1,24,3,24,378,8,24,1,25,1,25,1,25,1,25,1,25,1,25,3,25,386,8,25,
  	1,26,1,26,1,27,1,27,1,27,1,27,1,28,1,28,1,28,5,28,397,8,28,10,28,12,28,
  	400,9,28,1,29,1,29,1,29,1,30,1,30,4,30,407,8,30,11,30,12,30,408,1,30,
  	3,30,412,8,30,1,31,1,31,1,31,5,31,417,8,31,10,31,12,31,420,9,31,1,32,
  	1,32,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,434,8,33,
  	3,33,436,8,33,1,33,1,33,1,33,1,33,1,33,1,33,5,33,444,8,33,10,33,12,33,
  	447,9,33,1,34,3,34,450,8,34,1,34,3,34,453,8,34,1,34,3,34,456,8,34,1,35,
  	1,35,1,35,1,35,1,35,5,35,463,8,35,10,35,12,35,466,9,35,1,35,1,35,1,35,
  	1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,35,478,8,35,10,35,12,35,481,9,35,
  	1,35,1,35,3,35,485,8,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,35,
  	495,8,35,10,35,12,35,498,9,35,1,35,1,35,3,35,502,8,35,1,36,1,36,1,36,
  	1,36,5,36,508,8,36,10,36,12,36,511,9,36,3,36,513,8,36,1,36,1,36,3,36,
  	517,8,36,1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,39,1,39,1,39,1,39,
  	1,39,1,40,1,40,3,40,534,8,40,1,41,1,41,1,41,1,41,1,41,3,41,541,8,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,551,8,41,1,41,1,41,1,41,1,
  	41,1,41,3,41,558,8,41,1,42,1,42,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,
  	44,1,44,1,44,1,44,1,44,1,45,1,45,1,46,1,46,1,47,1,47,1,48,1,48,1,48,3,
  	48,583,8,48,1,49,1,49,1,49,1,49,1,49,1,49,3,49,591,8,49,1,50,1,50,1,50,
  	1,50,1,50,1,50,1,50,1,50,1,50,1,51,3,51,603,8,51,1,51,1,51,1,52,1,52,
  	1,53,1,53,1,54,1,54,1,55,1,55,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,
  	1,56,1,57,1,57,1,58,1,58,1,59,1,59,1,60,1,60,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,62,1,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
  	1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,64,1,64,1,65,
  	1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,66,1,66,1,67,1,67,
  	3,67,679,8,67,1,67,1,67,3,67,683,8,67,1,68,3,68,686,8,68,1,68,1,68,1,
  	68,1,68,1,68,1,68,3,68,694,8,68,1,68,1,68,1,68,1,68,1,68,5,68,701,8,68,
  	10,68,12,68,704,9,68,1,68,1,68,1,68,3,68,709,8,68,1,68,1,68,1,68,1,68,
  	1,68,1,68,3,68,717,8,68,1,68,1,68,1,68,3,68,722,8,68,1,68,1,68,1,68,1,
  	68,1,68,1,68,1,68,1,68,5,68,732,8,68,10,68,12,68,735,9,68,1,68,1,68,3,
  	68,739,8,68,1,68,3,68,742,8,68,1,68,1,68,1,68,1,68,3,68,748,8,68,1,68,
  	1,68,1,68,1,68,3,68,754,8,68,1,68,1,68,1,68,3,68,759,8,68,1,68,1,68,1,
  	68,3,68,764,8,68,1,69,1,69,1,69,1,69,3,69,770,8,69,1,69,1,69,1,69,1,69,
  	1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,
  	1,69,5,69,791,8,69,10,69,12,69,794,9,69,1,70,1,70,1,71,1,71,1,71,3,71,
  	801,8,71,1,71,5,71,804,8,71,10,71,12,71,807,9,71,1,71,1,71,1,72,1,72,
  	1,72,1,72,1,72,1,72,5,72,817,8,72,10,72,12,72,820,9,72,1,72,1,72,3,72,
  	824,8,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,4,73,840,8,73,11,73,12,73,841,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,5,73,851,8,73,10,73,12,73,854,9,73,3,73,856,8,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,3,73,866,8,73,1,73,1,73,1,73,5,73,871,8,73,10,
  	73,12,73,874,9,73,1,74,1,74,1,74,5,74,879,8,74,10,74,12,74,882,9,74,1,
  	75,1,75,3,75,886,8,75,1,75,1,75,1,75,3,75,891,8,75,1,75,1,75,1,75,3,75,
  	896,8,75,1,75,1,75,3,75,900,8,75,1,75,1,75,3,75,904,8,75,1,75,1,75,3,
  	75,908,8,75,1,75,1,75,3,75,912,8,75,1,75,1,75,3,75,916,8,75,1,75,1,75,
  	3,75,920,8,75,1,75,1,75,3,75,924,8,75,1,75,3,75,927,8,75,1,76,1,76,1,
  	76,1,76,1,76,1,76,1,76,4,76,936,8,76,11,76,12,76,937,3,76,940,8,76,1,
  	77,1,77,1,78,1,78,1,79,1,79,1,80,1,80,1,80,0,4,8,66,138,146,81,0,2,4,
  	6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,
  	54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
  	100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,
  	136,138,140,142,144,146,148,150,152,154,156,158,160,0,18,1,0,83,87,2,
  	0,85,85,88,91,2,0,100,100,139,139,1,0,101,103,1,0,104,105,2,0,13,13,20,
  	20,2,0,29,29,43,43,3,0,9,9,11,11,64,64,3,0,28,28,68,68,71,71,2,0,115,
  	116,120,120,2,0,22,22,117,119,2,0,115,116,123,123,1,0,107,114,1,0,130,
  	131,2,0,28,28,68,68,9,0,32,32,38,38,42,42,44,44,49,49,54,54,59,59,70,
  	70,73,73,17,0,13,16,18,20,22,23,27,27,29,29,34,34,39,39,43,43,45,46,48,
  	48,52,52,57,57,60,61,63,63,68,69,74,74,77,77,17,0,9,16,18,23,26,29,31,
  	31,33,35,37,37,39,41,43,43,45,46,48,48,50,52,55,57,60,64,66,66,68,69,
  	74,74,76,78,1012,0,162,1,0,0,0,2,171,1,0,0,0,4,173,1,0,0,0,6,186,1,0,
  	0,0,8,199,1,0,0,0,10,219,1,0,0,0,12,221,1,0,0,0,14,233,1,0,0,0,16,242,
  	1,0,0,0,18,260,1,0,0,0,20,263,1,0,0,0,22,265,1,0,0,0,24,283,1,0,0,0,26,
  	285,1,0,0,0,28,300,1,0,0,0,30,306,1,0,0,0,32,313,1,0,0,0,34,322,1,0,0,
  	0,36,325,1,0,0,0,38,328,1,0,0,0,40,346,1,0,0,0,42,348,1,0,0,0,44,356,
  	1,0,0,0,46,364,1,0,0,0,48,377,1,0,0,0,50,385,1,0,0,0,52,387,1,0,0,0,54,
  	389,1,0,0,0,56,393,1,0,0,0,58,401,1,0,0,0,60,411,1,0,0,0,62,413,1,0,0,
  	0,64,421,1,0,0,0,66,435,1,0,0,0,68,449,1,0,0,0,70,501,1,0,0,0,72,516,
  	1,0,0,0,74,518,1,0,0,0,76,521,1,0,0,0,78,526,1,0,0,0,80,533,1,0,0,0,82,
  	557,1,0,0,0,84,559,1,0,0,0,86,564,1,0,0,0,88,568,1,0,0,0,90,573,1,0,0,
  	0,92,575,1,0,0,0,94,577,1,0,0,0,96,579,1,0,0,0,98,590,1,0,0,0,100,592,
  	1,0,0,0,102,602,1,0,0,0,104,606,1,0,0,0,106,608,1,0,0,0,108,610,1,0,0,
  	0,110,612,1,0,0,0,112,614,1,0,0,0,114,623,1,0,0,0,116,625,1,0,0,0,118,
  	627,1,0,0,0,120,629,1,0,0,0,122,631,1,0,0,0,124,640,1,0,0,0,126,642,1,
  	0,0,0,128,661,1,0,0,0,130,663,1,0,0,0,132,674,1,0,0,0,134,676,1,0,0,0,
  	136,763,1,0,0,0,138,769,1,0,0,0,140,795,1,0,0,0,142,797,1,0,0,0,144,823,
  	1,0,0,0,146,865,1,0,0,0,148,875,1,0,0,0,150,926,1,0,0,0,152,939,1,0,0,
  	0,154,941,1,0,0,0,156,943,1,0,0,0,158,945,1,0,0,0,160,947,1,0,0,0,162,
  	166,3,2,1,0,163,165,5,1,0,0,164,163,1,0,0,0,165,168,1,0,0,0,166,164,1,
  	0,0,0,166,167,1,0,0,0,167,169,1,0,0,0,168,166,1,0,0,0,169,170,5,0,0,1,
  	170,1,1,0,0,0,171,172,3,4,2,0,172,3,1,0,0,0,173,174,3,8,4,0,174,175,3,
  	6,3,0,175,5,1,0,0,0,176,177,5,56,0,0,177,178,5,16,0,0,178,183,3,134,67,
  	0,179,180,5,2,0,0,180,182,3,134,67,0,181,179,1,0,0,0,182,185,1,0,0,0,
  	183,181,1,0,0,0,183,184,1,0,0,0,184,187,1,0,0,0,185,183,1,0,0,0,186,176,
  	1,0,0,0,186,187,1,0,0,0,187,193,1,0,0,0,188,191,5,46,0,0,189,192,5,9,
  	0,0,190,192,5,129,0,0,191,189,1,0,0,0,191,190,1,0,0,0,192,194,1,0,0,0,
  	193,188,1,0,0,0,193,194,1,0,0,0,194,197,1,0,0,0,195,196,5,93,0,0,196,
  	198,5,129,0,0,197,195,1,0,0,0,197,198,1,0,0,0,198,7,1,0,0,0,199,200,6,
  	4,-1,0,200,201,3,10,5,0,201,207,1,0,0,0,202,203,10,1,0,0,203,204,5,70,
  	0,0,204,206,3,8,4,2,205,202,1,0,0,0,206,209,1,0,0,0,207,205,1,0,0,0,207,
  	208,1,0,0,0,208,9,1,0,0,0,209,207,1,0,0,0,210,220,3,12,6,0,211,220,3,
  	28,14,0,212,213,5,66,0,0,213,220,3,44,22,0,214,220,3,38,19,0,215,216,
  	5,3,0,0,216,217,3,4,2,0,217,218,5,4,0,0,218,220,1,0,0,0,219,210,1,0,0,
  	0,219,211,1,0,0,0,219,212,1,0,0,0,219,214,1,0,0,0,219,215,1,0,0,0,220,
  	11,1,0,0,0,221,222,3,32,16,0,222,224,3,14,7,0,223,225,3,34,17,0,224,223,
  	1,0,0,0,224,225,1,0,0,0,225,226,1,0,0,0,226,228,3,96,48,0,227,229,3,68,
  	34,0,228,227,1,0,0,0,228,229,1,0,0,0,229,231,1,0,0,0,230,232,3,36,18,
  	0,231,230,1,0,0,0,231,232,1,0,0,0,232,13,1,0,0,0,233,234,5,31,0,0,234,
  	239,3,16,8,0,235,236,5,2,0,0,236,238,3,16,8,0,237,235,1,0,0,0,238,241,
  	1,0,0,0,239,237,1,0,0,0,239,240,1,0,0,0,240,15,1,0,0,0,241,239,1,0,0,
  	0,242,246,3,24,12,0,243,245,3,18,9,0,244,243,1,0,0,0,245,248,1,0,0,0,
  	246,244,1,0,0,0,246,247,1,0,0,0,247,17,1,0,0,0,248,246,1,0,0,0,249,250,
  	3,20,10,0,250,251,5,42,0,0,251,253,3,24,12,0,252,254,3,22,11,0,253,252,
  	1,0,0,0,253,254,1,0,0,0,254,261,1,0,0,0,255,256,5,49,0,0,256,257,3,20,
  	10,0,257,258,5,42,0,0,258,259,3,24,12,0,259,261,1,0,0,0,260,249,1,0,0,
  	0,260,255,1,0,0,0,261,19,1,0,0,0,262,264,5,38,0,0,263,262,1,0,0,0,263,
  	264,1,0,0,0,264,21,1,0,0,0,265,266,5,54,0,0,266,267,3,66,33,0,267,23,
  	1,0,0,0,268,269,3,44,22,0,269,270,3,40,20,0,270,284,1,0,0,0,271,272,5,
  	3,0,0,272,273,3,4,2,0,273,274,5,4,0,0,274,275,3,40,20,0,275,284,1,0,0,
  	0,276,277,5,3,0,0,277,278,3,16,8,0,278,279,5,4,0,0,279,280,3,40,20,0,
  	280,284,1,0,0,0,281,284,3,38,19,0,282,284,3,26,13,0,283,268,1,0,0,0,283,
  	271,1,0,0,0,283,276,1,0,0,0,283,281,1,0,0,0,283,282,1,0,0,0,284,25,1,
  	0,0,0,285,286,3,58,29,0,286,295,5,3,0,0,287,292,3,64,32,0,288,289,5,2,
  	0,0,289,291,3,64,32,0,290,288,1,0,0,0,291,294,1,0,0,0,292,290,1,0,0,0,
  	292,293,1,0,0,0,293,296,1,0,0,0,294,292,1,0,0,0,295,287,1,0,0,0,295,296,
  	1,0,0,0,296,297,1,0,0,0,297,298,5,4,0,0,298,299,3,40,20,0,299,27,1,0,
  	0,0,300,302,3,14,7,0,301,303,3,30,15,0,302,301,1,0,0,0,303,304,1,0,0,
  	0,304,302,1,0,0,0,304,305,1,0,0,0,305,29,1,0,0,0,306,308,3,32,16,0,307,
  	309,3,34,17,0,308,307,1,0,0,0,308,309,1,0,0,0,309,311,1,0,0,0,310,312,
  	3,70,35,0,311,310,1,0,0,0,311,312,1,0,0,0,312,31,1,0,0,0,313,317,5,62,
  	0,0,314,316,3,142,71,0,315,314,1,0,0,0,316,319,1,0,0,0,317,315,1,0,0,
  	0,317,318,1,0,0,0,318,320,1,0,0,0,319,317,1,0,0,0,320,321,3,62,31,0,321,
  	33,1,0,0,0,322,323,5,76,0,0,323,324,3,66,33,0,324,35,1,0,0,0,325,326,
  	5,35,0,0,326,327,3,66,33,0,327,37,1,0,0,0,328,329,5,74,0,0,329,334,3,
  	64,32,0,330,331,5,2,0,0,331,333,3,64,32,0,332,330,1,0,0,0,333,336,1,0,
  	0,0,334,332,1,0,0,0,334,335,1,0,0,0,335,337,1,0,0,0,336,334,1,0,0,0,337,
  	338,3,40,20,0,338,39,1,0,0,0,339,341,5,12,0,0,340,339,1,0,0,0,340,341,
  	1,0,0,0,341,342,1,0,0,0,342,344,3,50,25,0,343,345,3,54,27,0,344,343,1,
  	0,0,0,344,345,1,0,0,0,345,347,1,0,0,0,346,340,1,0,0,0,346,347,1,0,0,0,
  	347,41,1,0,0,0,348,353,3,44,22,0,349,350,5,2,0,0,350,352,3,44,22,0,351,
  	349,1,0,0,0,352,355,1,0,0,0,353,351,1,0,0,0,353,354,1,0,0,0,354,43,1,
  	0,0,0,355,353,1,0,0,0,356,361,3,58,29,0,357,358,5,5,0,0,358,360,3,58,
  	29,0,359,357,1,0,0,0,360,363,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,
  	362,45,1,0,0,0,363,361,1,0,0,0,364,372,3,64,32,0,365,367,5,12,0,0,366,
  	365,1,0,0,0,366,367,1,0,0,0,367,370,1,0,0,0,368,371,3,58,29,0,369,371,
  	3,54,27,0,370,368,1,0,0,0,370,369,1,0,0,0,371,373,1,0,0,0,372,366,1,0,
  	0,0,372,373,1,0,0,0,373,47,1,0,0,0,374,378,3,50,25,0,375,376,4,24,1,0,
  	376,378,3,156,78,0,377,374,1,0,0,0,377,375,1,0,0,0,378,49,1,0,0,0,379,
  	386,5,135,0,0,380,386,3,52,26,0,381,382,4,25,2,0,382,386,3,158,79,0,383,
  	384,4,25,3,0,384,386,3,160,80,0,385,379,1,0,0,0,385,380,1,0,0,0,385,381,
  	1,0,0,0,385,383,1,0,0,0,386,51,1,0,0,0,387,388,5,8,0,0,388,53,1,0,0,0,
  	389,390,5,3,0,0,390,391,3,56,28,0,391,392,5,4,0,0,392,55,1,0,0,0,393,
  	398,3,58,29,0,394,395,5,2,0,0,395,397,3,58,29,0,396,394,1,0,0,0,397,400,
  	1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,57,1,0,0,0,400,398,1,0,0,
  	0,401,402,3,48,24,0,402,403,3,60,30,0,403,59,1,0,0,0,404,405,5,116,0,
  	0,405,407,3,48,24,0,406,404,1,0,0,0,407,408,1,0,0,0,408,406,1,0,0,0,408,
  	409,1,0,0,0,409,412,1,0,0,0,410,412,1,0,0,0,411,406,1,0,0,0,411,410,1,
  	0,0,0,412,61,1,0,0,0,413,418,3,46,23,0,414,415,5,2,0,0,415,417,3,46,23,
  	0,416,414,1,0,0,0,417,420,1,0,0,0,418,416,1,0,0,0,418,419,1,0,0,0,419,
  	63,1,0,0,0,420,418,1,0,0,0,421,422,3,66,33,0,422,65,1,0,0,0,423,424,6,
  	33,-1,0,424,425,5,50,0,0,425,436,3,66,33,5,426,427,5,27,0,0,427,428,5,
  	3,0,0,428,429,3,4,2,0,429,430,5,4,0,0,430,436,1,0,0,0,431,433,3,138,69,
  	0,432,434,3,136,68,0,433,432,1,0,0,0,433,434,1,0,0,0,434,436,1,0,0,0,
  	435,423,1,0,0,0,435,426,1,0,0,0,435,431,1,0,0,0,436,445,1,0,0,0,437,438,
  	10,2,0,0,438,439,5,10,0,0,439,444,3,66,33,3,440,441,10,1,0,0,441,442,
  	5,55,0,0,442,444,3,66,33,2,443,437,1,0,0,0,443,440,1,0,0,0,444,447,1,
  	0,0,0,445,443,1,0,0,0,445,446,1,0,0,0,446,67,1,0,0,0,447,445,1,0,0,0,
  	448,450,3,70,35,0,449,448,1,0,0,0,449,450,1,0,0,0,450,452,1,0,0,0,451,
  	453,3,74,37,0,452,451,1,0,0,0,452,453,1,0,0,0,453,455,1,0,0,0,454,456,
  	3,76,38,0,455,454,1,0,0,0,455,456,1,0,0,0,456,69,1,0,0,0,457,458,5,33,
  	0,0,458,459,5,16,0,0,459,464,3,64,32,0,460,461,5,2,0,0,461,463,3,64,32,
  	0,462,460,1,0,0,0,463,466,1,0,0,0,464,462,1,0,0,0,464,465,1,0,0,0,465,
  	484,1,0,0,0,466,464,1,0,0,0,467,468,5,78,0,0,468,485,5,61,0,0,469,470,
  	5,78,0,0,470,485,5,18,0,0,471,472,5,34,0,0,472,473,5,63,0,0,473,474,5,
  	3,0,0,474,479,3,72,36,0,475,476,5,2,0,0,476,478,3,72,36,0,477,475,1,0,
  	0,0,478,481,1,0,0,0,479,477,1,0,0,0,479,480,1,0,0,0,480,482,1,0,0,0,481,
  	479,1,0,0,0,482,483,5,4,0,0,483,485,1,0,0,0,484,467,1,0,0,0,484,469,1,
  	0,0,0,484,471,1,0,0,0,484,485,1,0,0,0,485,502,1,0,0,0,486,487,5,33,0,
  	0,487,488,5,16,0,0,488,489,5,34,0,0,489,490,5,63,0,0,490,491,5,3,0,0,
  	491,496,3,72,36,0,492,493,5,2,0,0,493,495,3,72,36,0,494,492,1,0,0,0,495,
  	498,1,0,0,0,496,494,1,0,0,0,496,497,1,0,0,0,497,499,1,0,0,0,498,496,1,
  	0,0,0,499,500,5,4,0,0,500,502,1,0,0,0,501,457,1,0,0,0,501,486,1,0,0,0,
  	502,71,1,0,0,0,503,512,5,3,0,0,504,509,3,64,32,0,505,506,5,2,0,0,506,
  	508,3,64,32,0,507,505,1,0,0,0,508,511,1,0,0,0,509,507,1,0,0,0,509,510,
  	1,0,0,0,510,513,1,0,0,0,511,509,1,0,0,0,512,504,1,0,0,0,512,513,1,0,0,
  	0,513,514,1,0,0,0,514,517,5,4,0,0,515,517,3,64,32,0,516,503,1,0,0,0,516,
  	515,1,0,0,0,517,73,1,0,0,0,518,519,5,77,0,0,519,520,3,80,40,0,520,75,
  	1,0,0,0,521,522,5,92,0,0,522,523,5,3,0,0,523,524,3,78,39,0,524,525,5,
  	4,0,0,525,77,1,0,0,0,526,527,3,48,24,0,527,528,5,2,0,0,528,529,5,129,
  	0,0,529,530,3,90,45,0,530,79,1,0,0,0,531,534,3,82,41,0,532,534,3,84,42,
  	0,533,531,1,0,0,0,533,532,1,0,0,0,534,81,1,0,0,0,535,536,5,79,0,0,536,
  	540,5,3,0,0,537,538,3,92,46,0,538,539,5,2,0,0,539,541,1,0,0,0,540,537,
  	1,0,0,0,540,541,1,0,0,0,541,542,1,0,0,0,542,543,3,86,43,0,543,544,5,4,
  	0,0,544,558,1,0,0,0,545,546,5,80,0,0,546,550,5,3,0,0,547,548,3,92,46,
  	0,548,549,5,2,0,0,549,551,1,0,0,0,550,547,1,0,0,0,550,551,1,0,0,0,551,
  	552,1,0,0,0,552,553,3,86,43,0,553,554,5,2,0,0,554,555,3,88,44,0,555,556,
  	5,4,0,0,556,558,1,0,0,0,557,535,1,0,0,0,557,545,1,0,0,0,558,83,1,0,0,
  	0,559,560,5,79,0,0,560,561,5,3,0,0,561,562,5,129,0,0,562,563,5,4,0,0,
  	563,85,1,0,0,0,564,565,5,81,0,0,565,566,5,129,0,0,566,567,3,90,45,0,567,
  	87,1,0,0,0,568,569,5,82,0,0,569,570,5,16,0,0,570,571,5,129,0,0,571,572,
  	3,90,45,0,572,89,1,0,0,0,573,574,7,0,0,0,574,91,1,0,0,0,575,576,5,135,
  	0,0,576,93,1,0,0,0,577,578,7,1,0,0,578,95,1,0,0,0,579,580,5,40,0,0,580,
  	582,3,98,49,0,581,583,5,12,0,0,582,581,1,0,0,0,582,583,1,0,0,0,583,97,
  	1,0,0,0,584,591,3,100,50,0,585,591,3,112,56,0,586,591,3,122,61,0,587,
  	591,3,126,63,0,588,591,3,130,65,0,589,591,3,132,66,0,590,584,1,0,0,0,
  	590,585,1,0,0,0,590,586,1,0,0,0,590,587,1,0,0,0,590,588,1,0,0,0,590,589,
  	1,0,0,0,591,99,1,0,0,0,592,593,3,104,52,0,593,594,5,3,0,0,594,595,3,106,
  	53,0,595,596,5,2,0,0,596,597,3,108,54,0,597,598,5,2,0,0,598,599,3,110,
  	55,0,599,600,5,4,0,0,600,101,1,0,0,0,601,603,5,50,0,0,602,601,1,0,0,0,
  	602,603,1,0,0,0,603,604,1,0,0,0,604,605,5,51,0,0,605,103,1,0,0,0,606,
  	607,5,94,0,0,607,105,1,0,0,0,608,609,5,135,0,0,609,107,1,0,0,0,610,611,
  	7,2,0,0,611,109,1,0,0,0,612,613,5,129,0,0,613,111,1,0,0,0,614,615,3,114,
  	57,0,615,616,5,3,0,0,616,617,3,116,58,0,617,618,5,2,0,0,618,619,3,118,
  	59,0,619,620,5,2,0,0,620,621,3,120,60,0,621,622,5,4,0,0,622,113,1,0,0,
  	0,623,624,5,95,0,0,624,115,1,0,0,0,625,626,5,135,0,0,626,117,1,0,0,0,
  	627,628,5,135,0,0,628,119,1,0,0,0,629,630,5,129,0,0,630,121,1,0,0,0,631,
  	632,5,96,0,0,632,633,5,3,0,0,633,634,5,125,0,0,634,635,5,2,0,0,635,636,
  	3,124,62,0,636,637,5,2,0,0,637,638,5,125,0,0,638,639,5,4,0,0,639,123,
  	1,0,0,0,640,641,7,3,0,0,641,125,1,0,0,0,642,643,5,97,0,0,643,644,5,3,
  	0,0,644,645,5,125,0,0,645,646,5,2,0,0,646,647,5,125,0,0,647,648,5,2,0,
  	0,648,649,5,125,0,0,649,650,5,2,0,0,650,651,5,129,0,0,651,652,5,2,0,0,
  	652,653,3,90,45,0,653,654,5,2,0,0,654,655,5,129,0,0,655,656,5,2,0,0,656,
  	657,3,128,64,0,657,658,5,2,0,0,658,659,5,106,0,0,659,660,5,4,0,0,660,
  	127,1,0,0,0,661,662,7,4,0,0,662,129,1,0,0,0,663,664,5,98,0,0,664,665,
  	5,3,0,0,665,666,5,125,0,0,666,667,5,2,0,0,667,668,5,125,0,0,668,669,5,
  	2,0,0,669,670,5,125,0,0,670,671,5,2,0,0,671,672,5,125,0,0,672,673,5,4,
  	0,0,673,131,1,0,0,0,674,675,5,99,0,0,675,133,1,0,0,0,676,678,3,64,32,
  	0,677,679,7,5,0,0,678,677,1,0,0,0,678,679,1,0,0,0,679,682,1,0,0,0,680,
  	681,5,52,0,0,681,683,7,6,0,0,682,680,1,0,0,0,682,683,1,0,0,0,683,135,
  	1,0,0,0,684,686,5,50,0,0,685,684,1,0,0,0,685,686,1,0,0,0,686,687,1,0,
  	0,0,687,688,5,15,0,0,688,689,3,138,69,0,689,690,5,10,0,0,690,691,3,138,
  	69,0,691,764,1,0,0,0,692,694,5,50,0,0,693,692,1,0,0,0,693,694,1,0,0,0,
  	694,695,1,0,0,0,695,696,5,37,0,0,696,697,5,3,0,0,697,702,3,64,32,0,698,
  	699,5,2,0,0,699,701,3,64,32,0,700,698,1,0,0,0,701,704,1,0,0,0,702,700,
  	1,0,0,0,702,703,1,0,0,0,703,705,1,0,0,0,704,702,1,0,0,0,705,706,5,4,0,
  	0,706,764,1,0,0,0,707,709,5,50,0,0,708,707,1,0,0,0,708,709,1,0,0,0,709,
  	710,1,0,0,0,710,711,5,37,0,0,711,712,5,3,0,0,712,713,3,4,2,0,713,714,
  	5,4,0,0,714,764,1,0,0,0,715,717,5,50,0,0,716,715,1,0,0,0,716,717,1,0,
  	0,0,717,718,1,0,0,0,718,719,5,60,0,0,719,764,3,138,69,0,720,722,5,50,
  	0,0,721,720,1,0,0,0,721,722,1,0,0,0,722,723,1,0,0,0,723,724,5,45,0,0,
  	724,738,7,7,0,0,725,726,5,3,0,0,726,739,5,4,0,0,727,728,5,3,0,0,728,733,
  	3,64,32,0,729,730,5,2,0,0,730,732,3,64,32,0,731,729,1,0,0,0,732,735,1,
  	0,0,0,733,731,1,0,0,0,733,734,1,0,0,0,734,736,1,0,0,0,735,733,1,0,0,0,
  	736,737,5,4,0,0,737,739,1,0,0,0,738,725,1,0,0,0,738,727,1,0,0,0,739,764,
  	1,0,0,0,740,742,5,50,0,0,741,740,1,0,0,0,741,742,1,0,0,0,742,743,1,0,
  	0,0,743,744,5,45,0,0,744,747,3,138,69,0,745,746,5,26,0,0,746,748,5,125,
  	0,0,747,745,1,0,0,0,747,748,1,0,0,0,748,764,1,0,0,0,749,750,5,41,0,0,
  	750,764,3,102,51,0,751,753,5,41,0,0,752,754,5,50,0,0,753,752,1,0,0,0,
  	753,754,1,0,0,0,754,755,1,0,0,0,755,764,7,8,0,0,756,758,5,41,0,0,757,
  	759,5,50,0,0,758,757,1,0,0,0,758,759,1,0,0,0,759,760,1,0,0,0,760,761,
  	5,21,0,0,761,762,5,31,0,0,762,764,3,138,69,0,763,685,1,0,0,0,763,693,
  	1,0,0,0,763,708,1,0,0,0,763,716,1,0,0,0,763,721,1,0,0,0,763,741,1,0,0,
  	0,763,749,1,0,0,0,763,751,1,0,0,0,763,756,1,0,0,0,764,137,1,0,0,0,765,
  	766,6,69,-1,0,766,770,3,146,73,0,767,768,7,9,0,0,768,770,3,138,69,7,769,
  	765,1,0,0,0,769,767,1,0,0,0,770,792,1,0,0,0,771,772,10,6,0,0,772,773,
  	7,10,0,0,773,791,3,138,69,7,774,775,10,5,0,0,775,776,7,11,0,0,776,791,
  	3,138,69,6,777,778,10,4,0,0,778,779,5,121,0,0,779,791,3,138,69,5,780,
  	781,10,3,0,0,781,782,5,124,0,0,782,791,3,138,69,4,783,784,10,2,0,0,784,
  	785,5,122,0,0,785,791,3,138,69,3,786,787,10,1,0,0,787,788,3,140,70,0,
  	788,789,3,138,69,2,789,791,1,0,0,0,790,771,1,0,0,0,790,774,1,0,0,0,790,
  	777,1,0,0,0,790,780,1,0,0,0,790,783,1,0,0,0,790,786,1,0,0,0,791,794,1,
  	0,0,0,792,790,1,0,0,0,792,793,1,0,0,0,793,139,1,0,0,0,794,792,1,0,0,0,
  	795,796,7,12,0,0,796,141,1,0,0,0,797,798,5,6,0,0,798,805,3,144,72,0,799,
  	801,5,2,0,0,800,799,1,0,0,0,800,801,1,0,0,0,801,802,1,0,0,0,802,804,3,
  	144,72,0,803,800,1,0,0,0,804,807,1,0,0,0,805,803,1,0,0,0,805,806,1,0,
  	0,0,806,808,1,0,0,0,807,805,1,0,0,0,808,809,5,7,0,0,809,143,1,0,0,0,810,
  	824,3,48,24,0,811,812,3,48,24,0,812,813,5,3,0,0,813,818,3,146,73,0,814,
  	815,5,2,0,0,815,817,3,146,73,0,816,814,1,0,0,0,817,820,1,0,0,0,818,816,
  	1,0,0,0,818,819,1,0,0,0,819,821,1,0,0,0,820,818,1,0,0,0,821,822,5,4,0,
  	0,822,824,1,0,0,0,823,810,1,0,0,0,823,811,1,0,0,0,824,145,1,0,0,0,825,
  	826,6,73,-1,0,826,866,5,117,0,0,827,828,3,148,74,0,828,829,5,5,0,0,829,
  	830,5,117,0,0,830,866,1,0,0,0,831,832,5,3,0,0,832,833,3,4,2,0,833,834,
  	5,4,0,0,834,866,1,0,0,0,835,836,5,3,0,0,836,839,3,46,23,0,837,838,5,2,
  	0,0,838,840,3,46,23,0,839,837,1,0,0,0,840,841,1,0,0,0,841,839,1,0,0,0,
  	841,842,1,0,0,0,842,843,1,0,0,0,843,844,5,4,0,0,844,866,1,0,0,0,845,846,
  	3,94,47,0,846,855,5,3,0,0,847,852,3,64,32,0,848,849,5,2,0,0,849,851,3,
  	64,32,0,850,848,1,0,0,0,851,854,1,0,0,0,852,850,1,0,0,0,852,853,1,0,0,
  	0,853,856,1,0,0,0,854,852,1,0,0,0,855,847,1,0,0,0,855,856,1,0,0,0,856,
  	857,1,0,0,0,857,858,5,4,0,0,858,866,1,0,0,0,859,860,5,3,0,0,860,861,3,
  	64,32,0,861,862,5,4,0,0,862,866,1,0,0,0,863,866,3,152,76,0,864,866,3,
  	48,24,0,865,825,1,0,0,0,865,827,1,0,0,0,865,831,1,0,0,0,865,835,1,0,0,
  	0,865,845,1,0,0,0,865,859,1,0,0,0,865,863,1,0,0,0,865,864,1,0,0,0,866,
  	872,1,0,0,0,867,868,10,7,0,0,868,869,5,5,0,0,869,871,3,48,24,0,870,867,
  	1,0,0,0,871,874,1,0,0,0,872,870,1,0,0,0,872,873,1,0,0,0,873,147,1,0,0,
  	0,874,872,1,0,0,0,875,880,3,48,24,0,876,877,5,5,0,0,877,879,3,48,24,0,
  	878,876,1,0,0,0,879,882,1,0,0,0,880,878,1,0,0,0,880,881,1,0,0,0,881,149,
  	1,0,0,0,882,880,1,0,0,0,883,885,4,75,13,0,884,886,5,116,0,0,885,884,1,
  	0,0,0,885,886,1,0,0,0,886,887,1,0,0,0,887,927,5,130,0,0,888,890,4,75,
  	14,0,889,891,5,116,0,0,890,889,1,0,0,0,890,891,1,0,0,0,891,892,1,0,0,
  	0,892,927,5,131,0,0,893,895,4,75,15,0,894,896,5,116,0,0,895,894,1,0,0,
  	0,895,896,1,0,0,0,896,897,1,0,0,0,897,927,7,13,0,0,898,900,5,116,0,0,
  	899,898,1,0,0,0,899,900,1,0,0,0,900,901,1,0,0,0,901,927,5,129,0,0,902,
  	904,5,116,0,0,903,902,1,0,0,0,903,904,1,0,0,0,904,905,1,0,0,0,905,927,
  	5,126,0,0,906,908,5,116,0,0,907,906,1,0,0,0,907,908,1,0,0,0,908,909,1,
  	0,0,0,909,927,5,127,0,0,910,912,5,116,0,0,911,910,1,0,0,0,911,912,1,0,
  	0,0,912,913,1,0,0,0,913,927,5,128,0,0,914,916,5,116,0,0,915,914,1,0,0,
  	0,915,916,1,0,0,0,916,917,1,0,0,0,917,927,5,133,0,0,918,920,5,116,0,0,
  	919,918,1,0,0,0,919,920,1,0,0,0,920,921,1,0,0,0,921,927,5,132,0,0,922,
  	924,5,116,0,0,923,922,1,0,0,0,923,924,1,0,0,0,924,925,1,0,0,0,925,927,
  	5,134,0,0,926,883,1,0,0,0,926,888,1,0,0,0,926,893,1,0,0,0,926,899,1,0,
  	0,0,926,903,1,0,0,0,926,907,1,0,0,0,926,911,1,0,0,0,926,915,1,0,0,0,926,
  	919,1,0,0,0,926,923,1,0,0,0,927,151,1,0,0,0,928,940,5,51,0,0,929,930,
  	3,48,24,0,930,931,5,125,0,0,931,940,1,0,0,0,932,940,3,150,75,0,933,940,
  	3,154,77,0,934,936,5,125,0,0,935,934,1,0,0,0,936,937,1,0,0,0,937,935,
  	1,0,0,0,937,938,1,0,0,0,938,940,1,0,0,0,939,928,1,0,0,0,939,929,1,0,0,
  	0,939,932,1,0,0,0,939,933,1,0,0,0,939,935,1,0,0,0,940,153,1,0,0,0,941,
  	942,7,14,0,0,942,155,1,0,0,0,943,944,7,15,0,0,944,157,1,0,0,0,945,946,
  	7,16,0,0,946,159,1,0,0,0,947,948,7,17,0,0,948,161,1,0,0,0,101,166,183,
  	186,191,193,197,207,219,224,228,231,239,246,253,260,263,283,292,295,304,
  	308,311,317,334,340,344,346,353,361,366,370,372,377,385,398,408,411,418,
  	433,435,443,445,449,452,455,464,479,484,496,501,509,512,516,533,540,550,
  	557,582,590,602,678,682,685,693,702,708,716,721,733,738,741,747,753,758,
  	763,769,790,792,800,805,818,823,841,852,855,865,872,880,885,890,895,899,
  	903,907,911,915,919,923,926,937,939
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  nebulasqlParserStaticData = staticData.release();
}

}

NebulaSQLParser::NebulaSQLParser(TokenStream *input) : NebulaSQLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

NebulaSQLParser::NebulaSQLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  NebulaSQLParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *nebulasqlParserStaticData->atn, nebulasqlParserStaticData->decisionToDFA, nebulasqlParserStaticData->sharedContextCache, options);
}

NebulaSQLParser::~NebulaSQLParser() {
  delete _interpreter;
}

const atn::ATN& NebulaSQLParser::getATN() const {
  return *nebulasqlParserStaticData->atn;
}

std::string NebulaSQLParser::getGrammarFileName() const {
  return "NebulaSQL.g4";
}

const std::vector<std::string>& NebulaSQLParser::getRuleNames() const {
  return nebulasqlParserStaticData->ruleNames;
}

const dfa::Vocabulary& NebulaSQLParser::getVocabulary() const {
  return nebulasqlParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NebulaSQLParser::getSerializedATN() const {
  return nebulasqlParserStaticData->serializedATN;
}


//----------------- SingleStatementContext ------------------------------------------------------------------

NebulaSQLParser::SingleStatementContext::SingleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StatementContext* NebulaSQLParser::SingleStatementContext::statement() {
  return getRuleContext<NebulaSQLParser::StatementContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SingleStatementContext::EOF() {
  return getToken(NebulaSQLParser::EOF, 0);
}


size_t NebulaSQLParser::SingleStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSingleStatement;
}

void NebulaSQLParser::SingleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleStatement(this);
}

void NebulaSQLParser::SingleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleStatement(this);
}

NebulaSQLParser::SingleStatementContext* NebulaSQLParser::singleStatement() {
  SingleStatementContext *_localctx = _tracker.createInstance<SingleStatementContext>(_ctx, getState());
  enterRule(_localctx, 0, NebulaSQLParser::RuleSingleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(162);
    statement();
    setState(166);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__0) {
      setState(163);
      match(NebulaSQLParser::T__0);
      setState(168);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(169);
    match(NebulaSQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NebulaSQLParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::QueryContext* NebulaSQLParser::StatementContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}


size_t NebulaSQLParser::StatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStatement;
}

void NebulaSQLParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void NebulaSQLParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

NebulaSQLParser::StatementContext* NebulaSQLParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 2, NebulaSQLParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(171);
    query();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::QueryContext::queryTerm() {
  return getRuleContext<NebulaSQLParser::QueryTermContext>(0);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::QueryContext::queryOrganization() {
  return getRuleContext<NebulaSQLParser::QueryOrganizationContext>(0);
}


size_t NebulaSQLParser::QueryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuery;
}

void NebulaSQLParser::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void NebulaSQLParser::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 4, NebulaSQLParser::RuleQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(173);
    queryTerm(0);
    setState(174);
    queryOrganization();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryOrganizationContext ------------------------------------------------------------------

NebulaSQLParser::QueryOrganizationContext::QueryOrganizationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ORDER() {
  return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::OFFSET() {
  return getToken(NebulaSQLParser::OFFSET, 0);
}

std::vector<NebulaSQLParser::SortItemContext *> NebulaSQLParser::QueryOrganizationContext::sortItem() {
  return getRuleContexts<NebulaSQLParser::SortItemContext>();
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::QueryOrganizationContext::sortItem(size_t i) {
  return getRuleContext<NebulaSQLParser::SortItemContext>(i);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE() {
  return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE(size_t i) {
  return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}


size_t NebulaSQLParser::QueryOrganizationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryOrganization;
}

void NebulaSQLParser::QueryOrganizationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryOrganization(this);
}

void NebulaSQLParser::QueryOrganizationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryOrganization(this);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::queryOrganization() {
  QueryOrganizationContext *_localctx = _tracker.createInstance<QueryOrganizationContext>(_ctx, getState());
  enterRule(_localctx, 6, NebulaSQLParser::RuleQueryOrganization);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(186);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::ORDER) {
      setState(176);
      match(NebulaSQLParser::ORDER);
      setState(177);
      match(NebulaSQLParser::BY);
      setState(178);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
      setState(183);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(179);
        match(NebulaSQLParser::T__1);
        setState(180);
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
        setState(185);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(193);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::LIMIT) {
      setState(188);
      match(NebulaSQLParser::LIMIT);
      setState(191);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NebulaSQLParser::ALL: {
          setState(189);
          match(NebulaSQLParser::ALL);
          break;
        }

        case NebulaSQLParser::INTEGER_VALUE: {
          setState(190);
          antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->limit = match(NebulaSQLParser::INTEGER_VALUE);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(197);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::OFFSET) {
      setState(195);
      match(NebulaSQLParser::OFFSET);
      setState(196);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->offset = match(NebulaSQLParser::INTEGER_VALUE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryTermContext ------------------------------------------------------------------

NebulaSQLParser::QueryTermContext::QueryTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::QueryTermContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryTerm;
}

void NebulaSQLParser::QueryTermContext::copyFrom(QueryTermContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::PrimaryQueryContext::queryPrimary() {
  return getRuleContext<NebulaSQLParser::QueryPrimaryContext>(0);
}

NebulaSQLParser::PrimaryQueryContext::PrimaryQueryContext(QueryTermContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::PrimaryQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryQuery(this);
}
void NebulaSQLParser::PrimaryQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryQuery(this);
}
//----------------- SetOperationContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::QueryTermContext *> NebulaSQLParser::SetOperationContext::queryTerm() {
  return getRuleContexts<NebulaSQLParser::QueryTermContext>();
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::SetOperationContext::queryTerm(size_t i) {
  return getRuleContext<NebulaSQLParser::QueryTermContext>(i);
}

tree::TerminalNode* NebulaSQLParser::SetOperationContext::UNION() {
  return getToken(NebulaSQLParser::UNION, 0);
}

NebulaSQLParser::SetOperationContext::SetOperationContext(QueryTermContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SetOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetOperation(this);
}
void NebulaSQLParser::SetOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetOperation(this);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm() {
   return queryTerm(0);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::QueryTermContext *_localctx = _tracker.createInstance<QueryTermContext>(_ctx, parentState);
  NebulaSQLParser::QueryTermContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 8;
  enterRecursionRule(_localctx, 8, NebulaSQLParser::RuleQueryTerm, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryQueryContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(200);
    queryPrimary();
    _ctx->stop = _input->LT(-1);
    setState(207);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<SetOperationContext>(_tracker.createInstance<QueryTermContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->left = previousContext;
        pushNewRecursionContext(newContext, startState, RuleQueryTerm);
        setState(202);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(203);
        antlrcpp::downCast<SetOperationContext *>(_localctx)->setoperator = match(NebulaSQLParser::UNION);
        setState(204);
        antlrcpp::downCast<SetOperationContext *>(_localctx)->right = queryTerm(2); 
      }
      setState(209);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::QueryPrimaryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryPrimary;
}

void NebulaSQLParser::QueryPrimaryContext::copyFrom(QueryPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryContext::SubqueryContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}
void NebulaSQLParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}
//----------------- QueryPrimaryDefaultContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::QueryPrimaryDefaultContext::querySpecification() {
  return getRuleContext<NebulaSQLParser::QuerySpecificationContext>(0);
}

NebulaSQLParser::QueryPrimaryDefaultContext::QueryPrimaryDefaultContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::QueryPrimaryDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimaryDefault(this);
}
void NebulaSQLParser::QueryPrimaryDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimaryDefault(this);
}
//----------------- InlineTableDefault1Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault1Context::inlineTable() {
  return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault1Context::InlineTableDefault1Context(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::InlineTableDefault1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTableDefault1(this);
}
void NebulaSQLParser::InlineTableDefault1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTableDefault1(this);
}
//----------------- FromStmtContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext* NebulaSQLParser::FromStmtContext::fromStatement() {
  return getRuleContext<NebulaSQLParser::FromStatementContext>(0);
}

NebulaSQLParser::FromStmtContext::FromStmtContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FromStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStmt(this);
}
void NebulaSQLParser::FromStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStmt(this);
}
//----------------- TableContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TableContext::TABLE() {
  return getToken(NebulaSQLParser::TABLE, 0);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableContext::multipartIdentifier() {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableContext::TableContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable(this);
}
void NebulaSQLParser::TableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable(this);
}
NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::queryPrimary() {
  QueryPrimaryContext *_localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 10, NebulaSQLParser::RuleQueryPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(219);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::SELECT: {
        _localctx = _tracker.createInstance<NebulaSQLParser::QueryPrimaryDefaultContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(210);
        querySpecification();
        break;
      }

      case NebulaSQLParser::FROM: {
        _localctx = _tracker.createInstance<NebulaSQLParser::FromStmtContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(211);
        fromStatement();
        break;
      }

      case NebulaSQLParser::TABLE: {
        _localctx = _tracker.createInstance<NebulaSQLParser::TableContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(212);
        match(NebulaSQLParser::TABLE);
        setState(213);
        multipartIdentifier();
        break;
      }

      case NebulaSQLParser::VALUES: {
        _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault1Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(214);
        inlineTable();
        break;
      }

      case NebulaSQLParser::T__2: {
        _localctx = _tracker.createInstance<NebulaSQLParser::SubqueryContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(215);
        match(NebulaSQLParser::T__2);
        setState(216);
        query();
        setState(217);
        match(NebulaSQLParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::QuerySpecificationContext::selectClause() {
  return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::QuerySpecificationContext::sinkClause() {
  return getRuleContext<NebulaSQLParser::SinkClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::QuerySpecificationContext::windowedAggregationClause() {
  return getRuleContext<NebulaSQLParser::WindowedAggregationClauseContext>(0);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<NebulaSQLParser::HavingClauseContext>(0);
}


size_t NebulaSQLParser::QuerySpecificationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuerySpecification;
}

void NebulaSQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void NebulaSQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 12, NebulaSQLParser::RuleQuerySpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(221);
    selectClause();
    setState(222);
    fromClause();
    setState(224);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::WHERE) {
      setState(223);
      whereClause();
    }
    setState(226);
    sinkClause();
    setState(228);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(227);
      windowedAggregationClause();
      break;
    }

    default:
      break;
    }
    setState(231);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      setState(230);
      havingClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

NebulaSQLParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FromClauseContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

std::vector<NebulaSQLParser::RelationContext *> NebulaSQLParser::FromClauseContext::relation() {
  return getRuleContexts<NebulaSQLParser::RelationContext>();
}

NebulaSQLParser::RelationContext* NebulaSQLParser::FromClauseContext::relation(size_t i) {
  return getRuleContext<NebulaSQLParser::RelationContext>(i);
}


size_t NebulaSQLParser::FromClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromClause;
}

void NebulaSQLParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void NebulaSQLParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 14, NebulaSQLParser::RuleFromClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(233);
    match(NebulaSQLParser::FROM);
    setState(234);
    relation();
    setState(239);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(235);
      match(NebulaSQLParser::T__1);
      setState(236);
      relation();
      setState(241);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::RelationContext::relationPrimary() {
  return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

std::vector<NebulaSQLParser::JoinRelationContext *> NebulaSQLParser::RelationContext::joinRelation() {
  return getRuleContexts<NebulaSQLParser::JoinRelationContext>();
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::RelationContext::joinRelation(size_t i) {
  return getRuleContext<NebulaSQLParser::JoinRelationContext>(i);
}


size_t NebulaSQLParser::RelationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleRelation;
}

void NebulaSQLParser::RelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelation(this);
}

void NebulaSQLParser::RelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelation(this);
}

NebulaSQLParser::RelationContext* NebulaSQLParser::relation() {
  RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
  enterRule(_localctx, 16, NebulaSQLParser::RuleRelation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(242);
    relationPrimary();
    setState(246);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 567622877839360) != 0)) {
      setState(243);
      joinRelation();
      setState(248);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinRelationContext ------------------------------------------------------------------

NebulaSQLParser::JoinRelationContext::JoinRelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::JOIN() {
  return getToken(NebulaSQLParser::JOIN, 0);
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::JoinRelationContext::relationPrimary() {
  return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::JoinRelationContext::joinType() {
  return getRuleContext<NebulaSQLParser::JoinTypeContext>(0);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::JoinRelationContext::joinCriteria() {
  return getRuleContext<NebulaSQLParser::JoinCriteriaContext>(0);
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::NATURAL() {
  return getToken(NebulaSQLParser::NATURAL, 0);
}


size_t NebulaSQLParser::JoinRelationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinRelation;
}

void NebulaSQLParser::JoinRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinRelation(this);
}

void NebulaSQLParser::JoinRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinRelation(this);
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::joinRelation() {
  JoinRelationContext *_localctx = _tracker.createInstance<JoinRelationContext>(_ctx, getState());
  enterRule(_localctx, 18, NebulaSQLParser::RuleJoinRelation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(260);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::INNER:
      case NebulaSQLParser::JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(249);
        joinType();
        setState(250);
        match(NebulaSQLParser::JOIN);
        setState(251);
        antlrcpp::downCast<JoinRelationContext *>(_localctx)->right = relationPrimary();
        setState(253);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::ON) {
          setState(252);
          joinCriteria();
        }
        break;
      }

      case NebulaSQLParser::NATURAL: {
        enterOuterAlt(_localctx, 2);
        setState(255);
        match(NebulaSQLParser::NATURAL);
        setState(256);
        joinType();
        setState(257);
        match(NebulaSQLParser::JOIN);
        setState(258);
        antlrcpp::downCast<JoinRelationContext *>(_localctx)->right = relationPrimary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinTypeContext ------------------------------------------------------------------

NebulaSQLParser::JoinTypeContext::JoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinTypeContext::INNER() {
  return getToken(NebulaSQLParser::INNER, 0);
}


size_t NebulaSQLParser::JoinTypeContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinType;
}

void NebulaSQLParser::JoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinType(this);
}

void NebulaSQLParser::JoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinType(this);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::joinType() {
  JoinTypeContext *_localctx = _tracker.createInstance<JoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 20, NebulaSQLParser::RuleJoinType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(263);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::INNER) {
      setState(262);
      match(NebulaSQLParser::INNER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinCriteriaContext ------------------------------------------------------------------

NebulaSQLParser::JoinCriteriaContext::JoinCriteriaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinCriteriaContext::ON() {
  return getToken(NebulaSQLParser::ON, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::JoinCriteriaContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::JoinCriteriaContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinCriteria;
}

void NebulaSQLParser::JoinCriteriaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinCriteria(this);
}

void NebulaSQLParser::JoinCriteriaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinCriteria(this);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::joinCriteria() {
  JoinCriteriaContext *_localctx = _tracker.createInstance<JoinCriteriaContext>(_ctx, getState());
  enterRule(_localctx, 22, NebulaSQLParser::RuleJoinCriteria);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(265);
    match(NebulaSQLParser::ON);
    setState(266);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::RelationPrimaryContext::RelationPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::RelationPrimaryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleRelationPrimary;
}

void NebulaSQLParser::RelationPrimaryContext::copyFrom(RelationPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TableValuedFunctionContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::TableValuedFunctionContext::functionTable() {
  return getRuleContext<NebulaSQLParser::FunctionTableContext>(0);
}

NebulaSQLParser::TableValuedFunctionContext::TableValuedFunctionContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableValuedFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableValuedFunction(this);
}
void NebulaSQLParser::TableValuedFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableValuedFunction(this);
}
//----------------- InlineTableDefault2Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault2Context::inlineTable() {
  return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault2Context::InlineTableDefault2Context(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::InlineTableDefault2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTableDefault2(this);
}
void NebulaSQLParser::InlineTableDefault2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTableDefault2(this);
}
//----------------- AliasedRelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext* NebulaSQLParser::AliasedRelationContext::relation() {
  return getRuleContext<NebulaSQLParser::RelationContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedRelationContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedRelationContext::AliasedRelationContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::AliasedRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasedRelation(this);
}
void NebulaSQLParser::AliasedRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasedRelation(this);
}
//----------------- AliasedQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::AliasedQueryContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedQueryContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedQueryContext::AliasedQueryContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::AliasedQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasedQuery(this);
}
void NebulaSQLParser::AliasedQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasedQuery(this);
}
//----------------- TableNameContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableNameContext::multipartIdentifier() {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::TableNameContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::TableNameContext::TableNameContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}
void NebulaSQLParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}
NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::relationPrimary() {
  RelationPrimaryContext *_localctx = _tracker.createInstance<RelationPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 24, NebulaSQLParser::RuleRelationPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(283);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TableNameContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(268);
      multipartIdentifier();
      setState(269);
      tableAlias();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::AliasedQueryContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(271);
      match(NebulaSQLParser::T__2);
      setState(272);
      query();
      setState(273);
      match(NebulaSQLParser::T__3);
      setState(274);
      tableAlias();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::AliasedRelationContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(276);
      match(NebulaSQLParser::T__2);
      setState(277);
      relation();
      setState(278);
      match(NebulaSQLParser::T__3);
      setState(279);
      tableAlias();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault2Context>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(281);
      inlineTable();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TableValuedFunctionContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(282);
      functionTable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTableContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext::FunctionTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::FunctionTableContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::FunctionTableContext::errorCapturingIdentifier() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::FunctionTableContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionTableContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::FunctionTableContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFunctionTable;
}

void NebulaSQLParser::FunctionTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTable(this);
}

void NebulaSQLParser::FunctionTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTable(this);
}

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::functionTable() {
  FunctionTableContext *_localctx = _tracker.createInstance<FunctionTableContext>(_ctx, getState());
  enterRule(_localctx, 26, NebulaSQLParser::RuleFunctionTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(285);
    antlrcpp::downCast<FunctionTableContext *>(_localctx)->funcName = errorCapturingIdentifier();
    setState(286);
    match(NebulaSQLParser::T__2);
    setState(295);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(287);
      expression();
      setState(292);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(288);
        match(NebulaSQLParser::T__1);
        setState(289);
        expression();
        setState(294);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(297);
    match(NebulaSQLParser::T__3);
    setState(298);
    tableAlias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromStatementContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext::FromStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::FromStatementContext::fromClause() {
  return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

std::vector<NebulaSQLParser::FromStatementBodyContext *> NebulaSQLParser::FromStatementContext::fromStatementBody() {
  return getRuleContexts<NebulaSQLParser::FromStatementBodyContext>();
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::FromStatementContext::fromStatementBody(size_t i) {
  return getRuleContext<NebulaSQLParser::FromStatementBodyContext>(i);
}


size_t NebulaSQLParser::FromStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromStatement;
}

void NebulaSQLParser::FromStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStatement(this);
}

void NebulaSQLParser::FromStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStatement(this);
}

NebulaSQLParser::FromStatementContext* NebulaSQLParser::fromStatement() {
  FromStatementContext *_localctx = _tracker.createInstance<FromStatementContext>(_ctx, getState());
  enterRule(_localctx, 28, NebulaSQLParser::RuleFromStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(300);
    fromClause();
    setState(302); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(301);
              fromStatementBody();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(304); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromStatementBodyContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementBodyContext::FromStatementBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::FromStatementBodyContext::selectClause() {
  return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::FromStatementBodyContext::whereClause() {
  return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::FromStatementBodyContext::aggregationClause() {
  return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}


size_t NebulaSQLParser::FromStatementBodyContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromStatementBody;
}

void NebulaSQLParser::FromStatementBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStatementBody(this);
}

void NebulaSQLParser::FromStatementBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStatementBody(this);
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::fromStatementBody() {
  FromStatementBodyContext *_localctx = _tracker.createInstance<FromStatementBodyContext>(_ctx, getState());
  enterRule(_localctx, 30, NebulaSQLParser::RuleFromStatementBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(306);
    selectClause();
    setState(308);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(307);
      whereClause();
      break;
    }

    default:
      break;
    }
    setState(311);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(310);
      aggregationClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectClauseContext ------------------------------------------------------------------

NebulaSQLParser::SelectClauseContext::SelectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SelectClauseContext::SELECT() {
  return getToken(NebulaSQLParser::SELECT, 0);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::SelectClauseContext::namedExpressionSeq() {
  return getRuleContext<NebulaSQLParser::NamedExpressionSeqContext>(0);
}

std::vector<NebulaSQLParser::HintContext *> NebulaSQLParser::SelectClauseContext::hint() {
  return getRuleContexts<NebulaSQLParser::HintContext>();
}

NebulaSQLParser::HintContext* NebulaSQLParser::SelectClauseContext::hint(size_t i) {
  return getRuleContext<NebulaSQLParser::HintContext>(i);
}


size_t NebulaSQLParser::SelectClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSelectClause;
}

void NebulaSQLParser::SelectClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectClause(this);
}

void NebulaSQLParser::SelectClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectClause(this);
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::selectClause() {
  SelectClauseContext *_localctx = _tracker.createInstance<SelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 32, NebulaSQLParser::RuleSelectClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(313);
    match(NebulaSQLParser::SELECT);
    setState(317);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(314);
        antlrcpp::downCast<SelectClauseContext *>(_localctx)->hintContext = hint();
        antlrcpp::downCast<SelectClauseContext *>(_localctx)->hints.push_back(antlrcpp::downCast<SelectClauseContext *>(_localctx)->hintContext); 
      }
      setState(319);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
    }
    setState(320);
    namedExpressionSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

NebulaSQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WhereClauseContext::WHERE() {
  return getToken(NebulaSQLParser::WHERE, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::WhereClauseContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::WhereClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWhereClause;
}

void NebulaSQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void NebulaSQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 34, NebulaSQLParser::RuleWhereClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(322);
    match(NebulaSQLParser::WHERE);
    setState(323);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

NebulaSQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::HavingClauseContext::HAVING() {
  return getToken(NebulaSQLParser::HAVING, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::HavingClauseContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::HavingClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHavingClause;
}

void NebulaSQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void NebulaSQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 36, NebulaSQLParser::RuleHavingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(325);
    match(NebulaSQLParser::HAVING);
    setState(326);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineTableContext ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext::InlineTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::InlineTableContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::InlineTableContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::InlineTableContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::InlineTableContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}


size_t NebulaSQLParser::InlineTableContext::getRuleIndex() const {
  return NebulaSQLParser::RuleInlineTable;
}

void NebulaSQLParser::InlineTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTable(this);
}

void NebulaSQLParser::InlineTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTable(this);
}

NebulaSQLParser::InlineTableContext* NebulaSQLParser::inlineTable() {
  InlineTableContext *_localctx = _tracker.createInstance<InlineTableContext>(_ctx, getState());
  enterRule(_localctx, 38, NebulaSQLParser::RuleInlineTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(328);
    match(NebulaSQLParser::VALUES);
    setState(329);
    expression();
    setState(334);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(330);
        match(NebulaSQLParser::T__1);
        setState(331);
        expression(); 
      }
      setState(336);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
    setState(337);
    tableAlias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

NebulaSQLParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::TableAliasContext::strictIdentifier() {
  return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TableAliasContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::TableAliasContext::identifierList() {
  return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}


size_t NebulaSQLParser::TableAliasContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTableAlias;
}

void NebulaSQLParser::TableAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAlias(this);
}

void NebulaSQLParser::TableAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAlias(this);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 40, NebulaSQLParser::RuleTableAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(346);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(340);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
      case 1: {
        setState(339);
        match(NebulaSQLParser::AS);
        break;
      }

      default:
        break;
      }
      setState(342);
      strictIdentifier();
      setState(344);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        setState(343);
        identifierList();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierListContext::MultipartIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::MultipartIdentifierContext *> NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier() {
  return getRuleContexts<NebulaSQLParser::MultipartIdentifierContext>();
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierListContext::getRuleIndex() const {
  return NebulaSQLParser::RuleMultipartIdentifierList;
}

void NebulaSQLParser::MultipartIdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipartIdentifierList(this);
}

void NebulaSQLParser::MultipartIdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipartIdentifierList(this);
}

NebulaSQLParser::MultipartIdentifierListContext* NebulaSQLParser::multipartIdentifierList() {
  MultipartIdentifierListContext *_localctx = _tracker.createInstance<MultipartIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 42, NebulaSQLParser::RuleMultipartIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(348);
    multipartIdentifier();
    setState(353);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(349);
      match(NebulaSQLParser::T__1);
      setState(350);
      multipartIdentifier();
      setState(355);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext::MultipartIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext *> NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier() {
  return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleMultipartIdentifier;
}

void NebulaSQLParser::MultipartIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipartIdentifier(this);
}

void NebulaSQLParser::MultipartIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipartIdentifier(this);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::multipartIdentifier() {
  MultipartIdentifierContext *_localctx = _tracker.createInstance<MultipartIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 44, NebulaSQLParser::RuleMultipartIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(356);
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(361);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(357);
        match(NebulaSQLParser::T__4);
        setState(358);
        antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext); 
      }
      setState(363);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionContext::NamedExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::NamedExpressionContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::NamedExpressionContext::identifierList() {
  return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* NebulaSQLParser::NamedExpressionContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::NamedExpressionContext::errorCapturingIdentifier() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}


size_t NebulaSQLParser::NamedExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNamedExpression;
}

void NebulaSQLParser::NamedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedExpression(this);
}

void NebulaSQLParser::NamedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedExpression(this);
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::namedExpression() {
  NamedExpressionContext *_localctx = _tracker.createInstance<NamedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 46, NebulaSQLParser::RuleNamedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(364);
    expression();
    setState(372);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(366);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        setState(365);
        match(NebulaSQLParser::AS);
        break;
      }

      default:
        break;
      }
      setState(370);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
      case 1: {
        setState(368);
        antlrcpp::downCast<NamedExpressionContext *>(_localctx)->name = errorCapturingIdentifier();
        break;
      }

      case 2: {
        setState(369);
        identifierList();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::IdentifierContext::strictIdentifier() {
  return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::IdentifierContext::strictNonReserved() {
  return getRuleContext<NebulaSQLParser::StrictNonReservedContext>(0);
}


size_t NebulaSQLParser::IdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifier;
}

void NebulaSQLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void NebulaSQLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 48, NebulaSQLParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(377);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(374);
      strictIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(375);

      if (!(!SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
      setState(376);
      strictNonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::StrictIdentifierContext::StrictIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::StrictIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStrictIdentifier;
}

void NebulaSQLParser::StrictIdentifierContext::copyFrom(StrictIdentifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- QuotedIdentifierAlternativeContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::QuotedIdentifierAlternativeContext::quotedIdentifier() {
  return getRuleContext<NebulaSQLParser::QuotedIdentifierContext>(0);
}

NebulaSQLParser::QuotedIdentifierAlternativeContext::QuotedIdentifierAlternativeContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::QuotedIdentifierAlternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedIdentifierAlternative(this);
}
void NebulaSQLParser::QuotedIdentifierAlternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedIdentifierAlternative(this);
}
//----------------- UnquotedIdentifierContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnquotedIdentifierContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::ansiNonReserved() {
  return getRuleContext<NebulaSQLParser::AnsiNonReservedContext>(0);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::nonReserved() {
  return getRuleContext<NebulaSQLParser::NonReservedContext>(0);
}

NebulaSQLParser::UnquotedIdentifierContext::UnquotedIdentifierContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::UnquotedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnquotedIdentifier(this);
}
void NebulaSQLParser::UnquotedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnquotedIdentifier(this);
}
NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::strictIdentifier() {
  StrictIdentifierContext *_localctx = _tracker.createInstance<StrictIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 50, NebulaSQLParser::RuleStrictIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(385);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(379);
      match(NebulaSQLParser::IDENTIFIER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::QuotedIdentifierAlternativeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(380);
      quotedIdentifier();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(381);

      if (!(SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "SQL_standard_keyword_behavior");
      setState(382);
      ansiNonReserved();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(383);

      if (!(!SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
      setState(384);
      nonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuotedIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext::QuotedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QuotedIdentifierContext::BACKQUOTED_IDENTIFIER() {
  return getToken(NebulaSQLParser::BACKQUOTED_IDENTIFIER, 0);
}


size_t NebulaSQLParser::QuotedIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuotedIdentifier;
}

void NebulaSQLParser::QuotedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedIdentifier(this);
}

void NebulaSQLParser::QuotedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedIdentifier(this);
}

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::quotedIdentifier() {
  QuotedIdentifierContext *_localctx = _tracker.createInstance<QuotedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 52, NebulaSQLParser::RuleQuotedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(387);
    match(NebulaSQLParser::BACKQUOTED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::IdentifierListContext::identifierSeq() {
  return getRuleContext<NebulaSQLParser::IdentifierSeqContext>(0);
}


size_t NebulaSQLParser::IdentifierListContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifierList;
}

void NebulaSQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void NebulaSQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 54, NebulaSQLParser::RuleIdentifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(389);
    match(NebulaSQLParser::T__2);
    setState(390);
    identifierSeq();
    setState(391);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierSeqContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierSeqContext::IdentifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext *> NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier() {
  return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::IdentifierSeqContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifierSeq;
}

void NebulaSQLParser::IdentifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierSeq(this);
}

void NebulaSQLParser::IdentifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierSeq(this);
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::identifierSeq() {
  IdentifierSeqContext *_localctx = _tracker.createInstance<IdentifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 56, NebulaSQLParser::RuleIdentifierSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(393);
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(398);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(394);
      match(NebulaSQLParser::T__1);
      setState(395);
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
      setState(400);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierContext::ErrorCapturingIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorCapturingIdentifierContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::ErrorCapturingIdentifierContext::errorCapturingIdentifierExtra() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierExtraContext>(0);
}


size_t NebulaSQLParser::ErrorCapturingIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleErrorCapturingIdentifier;
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorCapturingIdentifier(this);
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorCapturingIdentifier(this);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::errorCapturingIdentifier() {
  ErrorCapturingIdentifierContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 58, NebulaSQLParser::RuleErrorCapturingIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(401);
    identifier();
    setState(402);
    errorCapturingIdentifierExtra();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierExtraContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierExtraContext::ErrorCapturingIdentifierExtraContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ErrorCapturingIdentifierExtraContext::getRuleIndex() const {
  return NebulaSQLParser::RuleErrorCapturingIdentifierExtra;
}

void NebulaSQLParser::ErrorCapturingIdentifierExtraContext::copyFrom(ErrorCapturingIdentifierExtraContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorIdentContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> NebulaSQLParser::ErrorIdentContext::MINUS() {
  return getTokens(NebulaSQLParser::MINUS);
}

tree::TerminalNode* NebulaSQLParser::ErrorIdentContext::MINUS(size_t i) {
  return getToken(NebulaSQLParser::MINUS, i);
}

std::vector<NebulaSQLParser::IdentifierContext *> NebulaSQLParser::ErrorIdentContext::identifier() {
  return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorIdentContext::identifier(size_t i) {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}

NebulaSQLParser::ErrorIdentContext::ErrorIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ErrorIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorIdent(this);
}
void NebulaSQLParser::ErrorIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorIdent(this);
}
//----------------- RealIdentContext ------------------------------------------------------------------

NebulaSQLParser::RealIdentContext::RealIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::RealIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealIdent(this);
}
void NebulaSQLParser::RealIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealIdent(this);
}
NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::errorCapturingIdentifierExtra() {
  ErrorCapturingIdentifierExtraContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierExtraContext>(_ctx, getState());
  enterRule(_localctx, 60, NebulaSQLParser::RuleErrorCapturingIdentifierExtra);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(411);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ErrorIdentContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(406); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(404);
                match(NebulaSQLParser::MINUS);
                setState(405);
                identifier();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(408); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::RealIdentContext>(_localctx);
      enterOuterAlt(_localctx, 2);

      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionSeqContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionSeqContext::NamedExpressionSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::NamedExpressionContext *> NebulaSQLParser::NamedExpressionSeqContext::namedExpression() {
  return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::NamedExpressionSeqContext::namedExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}


size_t NebulaSQLParser::NamedExpressionSeqContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNamedExpressionSeq;
}

void NebulaSQLParser::NamedExpressionSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedExpressionSeq(this);
}

void NebulaSQLParser::NamedExpressionSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedExpressionSeq(this);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::namedExpressionSeq() {
  NamedExpressionSeqContext *_localctx = _tracker.createInstance<NamedExpressionSeqContext>(_ctx, getState());
  enterRule(_localctx, 62, NebulaSQLParser::RuleNamedExpressionSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(413);
    namedExpression();
    setState(418);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(414);
        match(NebulaSQLParser::T__1);
        setState(415);
        namedExpression(); 
      }
      setState(420);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::ExpressionContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::ExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleExpression;
}

void NebulaSQLParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void NebulaSQLParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 64, NebulaSQLParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanExpressionContext ------------------------------------------------------------------

NebulaSQLParser::BooleanExpressionContext::BooleanExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::BooleanExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleBooleanExpression;
}

void NebulaSQLParser::BooleanExpressionContext::copyFrom(BooleanExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- LogicalNotContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LogicalNotContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalNotContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}

NebulaSQLParser::LogicalNotContext::LogicalNotContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LogicalNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalNot(this);
}
void NebulaSQLParser::LogicalNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalNot(this);
}
//----------------- PredicatedContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicatedContext::valueExpression() {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::PredicatedContext::predicate() {
  return getRuleContext<NebulaSQLParser::PredicateContext>(0);
}

NebulaSQLParser::PredicatedContext::PredicatedContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::PredicatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicated(this);
}
void NebulaSQLParser::PredicatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicated(this);
}
//----------------- ExistsContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExistsContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::ExistsContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::ExistsContext::ExistsContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExists(this);
}
void NebulaSQLParser::ExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExists(this);
}
//----------------- LogicalBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::BooleanExpressionContext *> NebulaSQLParser::LogicalBinaryContext::booleanExpression() {
  return getRuleContexts<NebulaSQLParser::BooleanExpressionContext>();
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalBinaryContext::booleanExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::OR() {
  return getToken(NebulaSQLParser::OR, 0);
}

NebulaSQLParser::LogicalBinaryContext::LogicalBinaryContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LogicalBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalBinary(this);
}
void NebulaSQLParser::LogicalBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalBinary(this);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression() {
   return booleanExpression(0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::BooleanExpressionContext *_localctx = _tracker.createInstance<BooleanExpressionContext>(_ctx, parentState);
  NebulaSQLParser::BooleanExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 66;
  enterRecursionRule(_localctx, 66, NebulaSQLParser::RuleBooleanExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(435);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LogicalNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(424);
      match(NebulaSQLParser::NOT);
      setState(425);
      booleanExpression(5);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ExistsContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(426);
      match(NebulaSQLParser::EXISTS);
      setState(427);
      match(NebulaSQLParser::T__2);
      setState(428);
      query();
      setState(429);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<PredicatedContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(431);
      valueExpression(0);
      setState(433);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
      case 1: {
        setState(432);
        predicate();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(445);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(443);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(437);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(438);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->op = match(NebulaSQLParser::AND);
          setState(439);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(3);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(440);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(441);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->op = match(NebulaSQLParser::OR);
          setState(442);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(447);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- WindowedAggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowedAggregationClauseContext::WindowedAggregationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::aggregationClause() {
  return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::windowClause() {
  return getRuleContext<NebulaSQLParser::WindowClauseContext>(0);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::watermarkClause() {
  return getRuleContext<NebulaSQLParser::WatermarkClauseContext>(0);
}


size_t NebulaSQLParser::WindowedAggregationClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowedAggregationClause;
}

void NebulaSQLParser::WindowedAggregationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowedAggregationClause(this);
}

void NebulaSQLParser::WindowedAggregationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowedAggregationClause(this);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::windowedAggregationClause() {
  WindowedAggregationClauseContext *_localctx = _tracker.createInstance<WindowedAggregationClauseContext>(_ctx, getState());
  enterRule(_localctx, 68, NebulaSQLParser::RuleWindowedAggregationClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(449);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(448);
      aggregationClause();
      break;
    }

    default:
      break;
    }
    setState(452);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(451);
      windowClause();
      break;
    }

    default:
      break;
    }
    setState(455);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(454);
      watermarkClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::AggregationClauseContext::AggregationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUP() {
  return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::AggregationClauseContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::AggregationClauseContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::WITH() {
  return getToken(NebulaSQLParser::WITH, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

std::vector<NebulaSQLParser::GroupingSetContext *> NebulaSQLParser::AggregationClauseContext::groupingSet() {
  return getRuleContexts<NebulaSQLParser::GroupingSetContext>();
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::AggregationClauseContext::groupingSet(size_t i) {
  return getRuleContext<NebulaSQLParser::GroupingSetContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}


size_t NebulaSQLParser::AggregationClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAggregationClause;
}

void NebulaSQLParser::AggregationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregationClause(this);
}

void NebulaSQLParser::AggregationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregationClause(this);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::aggregationClause() {
  AggregationClauseContext *_localctx = _tracker.createInstance<AggregationClauseContext>(_ctx, getState());
  enterRule(_localctx, 70, NebulaSQLParser::RuleAggregationClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(501);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(457);
      match(NebulaSQLParser::GROUP);
      setState(458);
      match(NebulaSQLParser::BY);
      setState(459);
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext = expression();
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->groupingExpressions.push_back(antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext);
      setState(464);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(460);
          match(NebulaSQLParser::T__1);
          setState(461);
          antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<AggregationClauseContext *>(_localctx)->groupingExpressions.push_back(antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext); 
        }
        setState(466);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      }
      setState(484);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
      case 1: {
        setState(467);
        match(NebulaSQLParser::WITH);
        setState(468);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::ROLLUP);
        break;
      }

      case 2: {
        setState(469);
        match(NebulaSQLParser::WITH);
        setState(470);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::CUBE);
        break;
      }

      case 3: {
        setState(471);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
        setState(472);
        match(NebulaSQLParser::SETS);
        setState(473);
        match(NebulaSQLParser::T__2);
        setState(474);
        groupingSet();
        setState(479);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(475);
          match(NebulaSQLParser::T__1);
          setState(476);
          groupingSet();
          setState(481);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(482);
        match(NebulaSQLParser::T__3);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(486);
      match(NebulaSQLParser::GROUP);
      setState(487);
      match(NebulaSQLParser::BY);
      setState(488);
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
      setState(489);
      match(NebulaSQLParser::SETS);
      setState(490);
      match(NebulaSQLParser::T__2);
      setState(491);
      groupingSet();
      setState(496);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(492);
        match(NebulaSQLParser::T__1);
        setState(493);
        groupingSet();
        setState(498);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(499);
      match(NebulaSQLParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingSetContext ------------------------------------------------------------------

NebulaSQLParser::GroupingSetContext::GroupingSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::GroupingSetContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::GroupingSetContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::GroupingSetContext::getRuleIndex() const {
  return NebulaSQLParser::RuleGroupingSet;
}

void NebulaSQLParser::GroupingSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingSet(this);
}

void NebulaSQLParser::GroupingSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingSet(this);
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::groupingSet() {
  GroupingSetContext *_localctx = _tracker.createInstance<GroupingSetContext>(_ctx, getState());
  enterRule(_localctx, 72, NebulaSQLParser::RuleGroupingSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(516);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(503);
      match(NebulaSQLParser::T__2);
      setState(512);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(504);
        expression();
        setState(509);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(505);
          match(NebulaSQLParser::T__1);
          setState(506);
          expression();
          setState(511);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(514);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(515);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WindowClauseContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}

NebulaSQLParser::WindowSpecContext* NebulaSQLParser::WindowClauseContext::windowSpec() {
  return getRuleContext<NebulaSQLParser::WindowSpecContext>(0);
}


size_t NebulaSQLParser::WindowClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowClause;
}

void NebulaSQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void NebulaSQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 74, NebulaSQLParser::RuleWindowClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(518);
    match(NebulaSQLParser::WINDOW);
    setState(519);
    windowSpec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WatermarkClauseContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkClauseContext::WatermarkClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WatermarkClauseContext::WATERMARK() {
  return getToken(NebulaSQLParser::WATERMARK, 0);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::WatermarkClauseContext::watermarkParameters() {
  return getRuleContext<NebulaSQLParser::WatermarkParametersContext>(0);
}


size_t NebulaSQLParser::WatermarkClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWatermarkClause;
}

void NebulaSQLParser::WatermarkClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWatermarkClause(this);
}

void NebulaSQLParser::WatermarkClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWatermarkClause(this);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::watermarkClause() {
  WatermarkClauseContext *_localctx = _tracker.createInstance<WatermarkClauseContext>(_ctx, getState());
  enterRule(_localctx, 76, NebulaSQLParser::RuleWatermarkClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(521);
    match(NebulaSQLParser::WATERMARK);
    setState(522);
    match(NebulaSQLParser::T__2);
    setState(523);
    watermarkParameters();
    setState(524);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WatermarkParametersContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkParametersContext::WatermarkParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::WatermarkParametersContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::WatermarkParametersContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::WatermarkParametersContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::WatermarkParametersContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWatermarkParameters;
}

void NebulaSQLParser::WatermarkParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWatermarkParameters(this);
}

void NebulaSQLParser::WatermarkParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWatermarkParameters(this);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::watermarkParameters() {
  WatermarkParametersContext *_localctx = _tracker.createInstance<WatermarkParametersContext>(_ctx, getState());
  enterRule(_localctx, 78, NebulaSQLParser::RuleWatermarkParameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(526);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermarkIdentifier = identifier();
    setState(527);
    match(NebulaSQLParser::T__1);
    setState(528);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermark = match(NebulaSQLParser::INTEGER_VALUE);
    setState(529);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermarkTimeUnit = timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

NebulaSQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::WindowSpecContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowSpec;
}

void NebulaSQLParser::WindowSpecContext::copyFrom(WindowSpecContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TimeBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext* NebulaSQLParser::TimeBasedWindowContext::timeWindow() {
  return getRuleContext<NebulaSQLParser::TimeWindowContext>(0);
}

NebulaSQLParser::TimeBasedWindowContext::TimeBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TimeBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeBasedWindow(this);
}
void NebulaSQLParser::TimeBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeBasedWindow(this);
}
//----------------- CountBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext* NebulaSQLParser::CountBasedWindowContext::countWindow() {
  return getRuleContext<NebulaSQLParser::CountWindowContext>(0);
}

NebulaSQLParser::CountBasedWindowContext::CountBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::CountBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountBasedWindow(this);
}
void NebulaSQLParser::CountBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountBasedWindow(this);
}
NebulaSQLParser::WindowSpecContext* NebulaSQLParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 80, NebulaSQLParser::RuleWindowSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(533);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TimeBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(531);
      timeWindow();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(532);
      countWindow();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext::TimeWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::TimeWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimeWindow;
}

void NebulaSQLParser::TimeWindowContext::copyFrom(TimeWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TumblingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TumblingWindowContext::TUMBLING() {
  return getToken(NebulaSQLParser::TUMBLING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::TumblingWindowContext::sizeParameter() {
  return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::TumblingWindowContext::timestampParameter() {
  return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::TumblingWindowContext::TumblingWindowContext(TimeWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TumblingWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTumblingWindow(this);
}
void NebulaSQLParser::TumblingWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTumblingWindow(this);
}
//----------------- SlidingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SlidingWindowContext::SLIDING() {
  return getToken(NebulaSQLParser::SLIDING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::SlidingWindowContext::sizeParameter() {
  return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::SlidingWindowContext::advancebyParameter() {
  return getRuleContext<NebulaSQLParser::AdvancebyParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::SlidingWindowContext::timestampParameter() {
  return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::SlidingWindowContext::SlidingWindowContext(TimeWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SlidingWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlidingWindow(this);
}
void NebulaSQLParser::SlidingWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlidingWindow(this);
}
NebulaSQLParser::TimeWindowContext* NebulaSQLParser::timeWindow() {
  TimeWindowContext *_localctx = _tracker.createInstance<TimeWindowContext>(_ctx, getState());
  enterRule(_localctx, 82, NebulaSQLParser::RuleTimeWindow);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(557);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::TUMBLING: {
        _localctx = _tracker.createInstance<NebulaSQLParser::TumblingWindowContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(535);
        match(NebulaSQLParser::TUMBLING);
        setState(536);
        match(NebulaSQLParser::T__2);
        setState(540);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::IDENTIFIER) {
          setState(537);
          timestampParameter();
          setState(538);
          match(NebulaSQLParser::T__1);
        }
        setState(542);
        sizeParameter();
        setState(543);
        match(NebulaSQLParser::T__3);
        break;
      }

      case NebulaSQLParser::SLIDING: {
        _localctx = _tracker.createInstance<NebulaSQLParser::SlidingWindowContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(545);
        match(NebulaSQLParser::SLIDING);
        setState(546);
        match(NebulaSQLParser::T__2);
        setState(550);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::IDENTIFIER) {
          setState(547);
          timestampParameter();
          setState(548);
          match(NebulaSQLParser::T__1);
        }
        setState(552);
        sizeParameter();
        setState(553);
        match(NebulaSQLParser::T__1);
        setState(554);
        advancebyParameter();
        setState(555);
        match(NebulaSQLParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CountWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext::CountWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::CountWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleCountWindow;
}

void NebulaSQLParser::CountWindowContext::copyFrom(CountWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CountBasedTumblingContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::TUMBLING() {
  return getToken(NebulaSQLParser::TUMBLING, 0);
}

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::CountBasedTumblingContext::CountBasedTumblingContext(CountWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::CountBasedTumblingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountBasedTumbling(this);
}
void NebulaSQLParser::CountBasedTumblingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountBasedTumbling(this);
}
NebulaSQLParser::CountWindowContext* NebulaSQLParser::countWindow() {
  CountWindowContext *_localctx = _tracker.createInstance<CountWindowContext>(_ctx, getState());
  enterRule(_localctx, 84, NebulaSQLParser::RuleCountWindow);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedTumblingContext>(_localctx);
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(NebulaSQLParser::TUMBLING);
    setState(560);
    match(NebulaSQLParser::T__2);
    setState(561);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(562);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::SizeParameterContext::SizeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::SIZE() {
  return getToken(NebulaSQLParser::SIZE, 0);
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SizeParameterContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::SizeParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSizeParameter;
}

void NebulaSQLParser::SizeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeParameter(this);
}

void NebulaSQLParser::SizeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeParameter(this);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::sizeParameter() {
  SizeParameterContext *_localctx = _tracker.createInstance<SizeParameterContext>(_ctx, getState());
  enterRule(_localctx, 86, NebulaSQLParser::RuleSizeParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(564);
    match(NebulaSQLParser::SIZE);
    setState(565);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(566);
    timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdvancebyParameterContext ------------------------------------------------------------------

NebulaSQLParser::AdvancebyParameterContext::AdvancebyParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::ADVANCE() {
  return getToken(NebulaSQLParser::ADVANCE, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::AdvancebyParameterContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::AdvancebyParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAdvancebyParameter;
}

void NebulaSQLParser::AdvancebyParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdvancebyParameter(this);
}

void NebulaSQLParser::AdvancebyParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdvancebyParameter(this);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::advancebyParameter() {
  AdvancebyParameterContext *_localctx = _tracker.createInstance<AdvancebyParameterContext>(_ctx, getState());
  enterRule(_localctx, 88, NebulaSQLParser::RuleAdvancebyParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(568);
    match(NebulaSQLParser::ADVANCE);
    setState(569);
    match(NebulaSQLParser::BY);
    setState(570);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(571);
    timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeUnitContext ------------------------------------------------------------------

NebulaSQLParser::TimeUnitContext::TimeUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MS() {
  return getToken(NebulaSQLParser::MS, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::SEC() {
  return getToken(NebulaSQLParser::SEC, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MIN() {
  return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::HOUR() {
  return getToken(NebulaSQLParser::HOUR, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::DAY() {
  return getToken(NebulaSQLParser::DAY, 0);
}


size_t NebulaSQLParser::TimeUnitContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimeUnit;
}

void NebulaSQLParser::TimeUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnit(this);
}

void NebulaSQLParser::TimeUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnit(this);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::timeUnit() {
  TimeUnitContext *_localctx = _tracker.createInstance<TimeUnitContext>(_ctx, getState());
  enterRule(_localctx, 90, NebulaSQLParser::RuleTimeUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(573);
    _la = _input->LA(1);
    if (!(((((_la - 83) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 83)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimestampParameterContext ------------------------------------------------------------------

NebulaSQLParser::TimestampParameterContext::TimestampParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::TimestampParameterContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::TimestampParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimestampParameter;
}

void NebulaSQLParser::TimestampParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimestampParameter(this);
}

void NebulaSQLParser::TimestampParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimestampParameter(this);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::timestampParameter() {
  TimestampParameterContext *_localctx = _tracker.createInstance<TimestampParameterContext>(_ctx, getState());
  enterRule(_localctx, 92, NebulaSQLParser::RuleTimestampParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(575);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::AVG() {
  return getToken(NebulaSQLParser::AVG, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MAX() {
  return getToken(NebulaSQLParser::MAX, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MIN() {
  return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::SUM() {
  return getToken(NebulaSQLParser::SUM, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::COUNT() {
  return getToken(NebulaSQLParser::COUNT, 0);
}


size_t NebulaSQLParser::FunctionNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFunctionName;
}

void NebulaSQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void NebulaSQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 94, NebulaSQLParser::RuleFunctionName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(577);
    _la = _input->LA(1);
    if (!(((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & 121) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkClauseContext ------------------------------------------------------------------

NebulaSQLParser::SinkClauseContext::SinkClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::INTO() {
  return getToken(NebulaSQLParser::INTO, 0);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::SinkClauseContext::sinkType() {
  return getRuleContext<NebulaSQLParser::SinkTypeContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}


size_t NebulaSQLParser::SinkClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkClause;
}

void NebulaSQLParser::SinkClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkClause(this);
}

void NebulaSQLParser::SinkClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkClause(this);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::sinkClause() {
  SinkClauseContext *_localctx = _tracker.createInstance<SinkClauseContext>(_ctx, getState());
  enterRule(_localctx, 96, NebulaSQLParser::RuleSinkClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(579);
    match(NebulaSQLParser::INTO);
    setState(580);
    sinkType();
    setState(582);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(581);
      match(NebulaSQLParser::AS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeContext::SinkTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SinkTypeZMQContext* NebulaSQLParser::SinkTypeContext::sinkTypeZMQ() {
  return getRuleContext<NebulaSQLParser::SinkTypeZMQContext>(0);
}

NebulaSQLParser::SinkTypeKafkaContext* NebulaSQLParser::SinkTypeContext::sinkTypeKafka() {
  return getRuleContext<NebulaSQLParser::SinkTypeKafkaContext>(0);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::SinkTypeContext::sinkTypeFile() {
  return getRuleContext<NebulaSQLParser::SinkTypeFileContext>(0);
}

NebulaSQLParser::SinkTypeMQTTContext* NebulaSQLParser::SinkTypeContext::sinkTypeMQTT() {
  return getRuleContext<NebulaSQLParser::SinkTypeMQTTContext>(0);
}

NebulaSQLParser::SinkTypeOPCContext* NebulaSQLParser::SinkTypeContext::sinkTypeOPC() {
  return getRuleContext<NebulaSQLParser::SinkTypeOPCContext>(0);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::SinkTypeContext::sinkTypePrint() {
  return getRuleContext<NebulaSQLParser::SinkTypePrintContext>(0);
}


size_t NebulaSQLParser::SinkTypeContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkType;
}

void NebulaSQLParser::SinkTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkType(this);
}

void NebulaSQLParser::SinkTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkType(this);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::sinkType() {
  SinkTypeContext *_localctx = _tracker.createInstance<SinkTypeContext>(_ctx, getState());
  enterRule(_localctx, 98, NebulaSQLParser::RuleSinkType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(590);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::ZMQ: {
        enterOuterAlt(_localctx, 1);
        setState(584);
        sinkTypeZMQ();
        break;
      }

      case NebulaSQLParser::KAFKA: {
        enterOuterAlt(_localctx, 2);
        setState(585);
        sinkTypeKafka();
        break;
      }

      case NebulaSQLParser::FILE: {
        enterOuterAlt(_localctx, 3);
        setState(586);
        sinkTypeFile();
        break;
      }

      case NebulaSQLParser::MQTT: {
        enterOuterAlt(_localctx, 4);
        setState(587);
        sinkTypeMQTT();
        break;
      }

      case NebulaSQLParser::OPC: {
        enterOuterAlt(_localctx, 5);
        setState(588);
        sinkTypeOPC();
        break;
      }

      case NebulaSQLParser::PRINT: {
        enterOuterAlt(_localctx, 6);
        setState(589);
        sinkTypePrint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeZMQContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeZMQContext::SinkTypeZMQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ZmqKeywordContext* NebulaSQLParser::SinkTypeZMQContext::zmqKeyword() {
  return getRuleContext<NebulaSQLParser::ZmqKeywordContext>(0);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::SinkTypeZMQContext::streamName() {
  return getRuleContext<NebulaSQLParser::StreamNameContext>(0);
}

NebulaSQLParser::HostContext* NebulaSQLParser::SinkTypeZMQContext::host() {
  return getRuleContext<NebulaSQLParser::HostContext>(0);
}

NebulaSQLParser::PortContext* NebulaSQLParser::SinkTypeZMQContext::port() {
  return getRuleContext<NebulaSQLParser::PortContext>(0);
}


size_t NebulaSQLParser::SinkTypeZMQContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeZMQ;
}

void NebulaSQLParser::SinkTypeZMQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeZMQ(this);
}

void NebulaSQLParser::SinkTypeZMQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeZMQ(this);
}

NebulaSQLParser::SinkTypeZMQContext* NebulaSQLParser::sinkTypeZMQ() {
  SinkTypeZMQContext *_localctx = _tracker.createInstance<SinkTypeZMQContext>(_ctx, getState());
  enterRule(_localctx, 100, NebulaSQLParser::RuleSinkTypeZMQ);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(592);
    zmqKeyword();
    setState(593);
    match(NebulaSQLParser::T__2);
    setState(594);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqStreamName = streamName();
    setState(595);
    match(NebulaSQLParser::T__1);
    setState(596);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqHostLabel = host();
    setState(597);
    match(NebulaSQLParser::T__1);
    setState(598);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqPort = port();
    setState(599);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullNotnullContext ------------------------------------------------------------------

NebulaSQLParser::NullNotnullContext::NullNotnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}


size_t NebulaSQLParser::NullNotnullContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNullNotnull;
}

void NebulaSQLParser::NullNotnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullNotnull(this);
}

void NebulaSQLParser::NullNotnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullNotnull(this);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::nullNotnull() {
  NullNotnullContext *_localctx = _tracker.createInstance<NullNotnullContext>(_ctx, getState());
  enterRule(_localctx, 102, NebulaSQLParser::RuleNullNotnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::NOT) {
      setState(601);
      match(NebulaSQLParser::NOT);
    }
    setState(604);
    match(NebulaSQLParser::NULLTOKEN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ZmqKeywordContext ------------------------------------------------------------------

NebulaSQLParser::ZmqKeywordContext::ZmqKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ZmqKeywordContext::ZMQ() {
  return getToken(NebulaSQLParser::ZMQ, 0);
}


size_t NebulaSQLParser::ZmqKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleZmqKeyword;
}

void NebulaSQLParser::ZmqKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterZmqKeyword(this);
}

void NebulaSQLParser::ZmqKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitZmqKeyword(this);
}

NebulaSQLParser::ZmqKeywordContext* NebulaSQLParser::zmqKeyword() {
  ZmqKeywordContext *_localctx = _tracker.createInstance<ZmqKeywordContext>(_ctx, getState());
  enterRule(_localctx, 104, NebulaSQLParser::RuleZmqKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(606);
    match(NebulaSQLParser::ZMQ);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamNameContext ------------------------------------------------------------------

NebulaSQLParser::StreamNameContext::StreamNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::StreamNameContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::StreamNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStreamName;
}

void NebulaSQLParser::StreamNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamName(this);
}

void NebulaSQLParser::StreamNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamName(this);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::streamName() {
  StreamNameContext *_localctx = _tracker.createInstance<StreamNameContext>(_ctx, getState());
  enterRule(_localctx, 106, NebulaSQLParser::RuleStreamName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HostContext ------------------------------------------------------------------

NebulaSQLParser::HostContext::HostContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::HostContext::FOUR_OCTETS() {
  return getToken(NebulaSQLParser::FOUR_OCTETS, 0);
}

tree::TerminalNode* NebulaSQLParser::HostContext::LOCALHOST() {
  return getToken(NebulaSQLParser::LOCALHOST, 0);
}


size_t NebulaSQLParser::HostContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHost;
}

void NebulaSQLParser::HostContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHost(this);
}

void NebulaSQLParser::HostContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHost(this);
}

NebulaSQLParser::HostContext* NebulaSQLParser::host() {
  HostContext *_localctx = _tracker.createInstance<HostContext>(_ctx, getState());
  enterRule(_localctx, 108, NebulaSQLParser::RuleHost);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(610);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::LOCALHOST

    || _la == NebulaSQLParser::FOUR_OCTETS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

NebulaSQLParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::PortContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::PortContext::getRuleIndex() const {
  return NebulaSQLParser::RulePort;
}

void NebulaSQLParser::PortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort(this);
}

void NebulaSQLParser::PortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort(this);
}

NebulaSQLParser::PortContext* NebulaSQLParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 110, NebulaSQLParser::RulePort);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(612);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeKafkaContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeKafkaContext::SinkTypeKafkaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::KafkaKeywordContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaKeyword() {
  return getRuleContext<NebulaSQLParser::KafkaKeywordContext>(0);
}

NebulaSQLParser::KafkaBrokerContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaBroker() {
  return getRuleContext<NebulaSQLParser::KafkaBrokerContext>(0);
}

NebulaSQLParser::KafkaTopicContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaTopic() {
  return getRuleContext<NebulaSQLParser::KafkaTopicContext>(0);
}

NebulaSQLParser::KafkaProducerTimoutContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaProducerTimout() {
  return getRuleContext<NebulaSQLParser::KafkaProducerTimoutContext>(0);
}


size_t NebulaSQLParser::SinkTypeKafkaContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeKafka;
}

void NebulaSQLParser::SinkTypeKafkaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeKafka(this);
}

void NebulaSQLParser::SinkTypeKafkaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeKafka(this);
}

NebulaSQLParser::SinkTypeKafkaContext* NebulaSQLParser::sinkTypeKafka() {
  SinkTypeKafkaContext *_localctx = _tracker.createInstance<SinkTypeKafkaContext>(_ctx, getState());
  enterRule(_localctx, 112, NebulaSQLParser::RuleSinkTypeKafka);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    kafkaKeyword();
    setState(615);
    match(NebulaSQLParser::T__2);
    setState(616);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->broker = kafkaBroker();
    setState(617);
    match(NebulaSQLParser::T__1);
    setState(618);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->topic = kafkaTopic();
    setState(619);
    match(NebulaSQLParser::T__1);
    setState(620);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->timeout = kafkaProducerTimout();
    setState(621);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaKeywordContext ------------------------------------------------------------------

NebulaSQLParser::KafkaKeywordContext::KafkaKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaKeywordContext::KAFKA() {
  return getToken(NebulaSQLParser::KAFKA, 0);
}


size_t NebulaSQLParser::KafkaKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaKeyword;
}

void NebulaSQLParser::KafkaKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaKeyword(this);
}

void NebulaSQLParser::KafkaKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaKeyword(this);
}

NebulaSQLParser::KafkaKeywordContext* NebulaSQLParser::kafkaKeyword() {
  KafkaKeywordContext *_localctx = _tracker.createInstance<KafkaKeywordContext>(_ctx, getState());
  enterRule(_localctx, 114, NebulaSQLParser::RuleKafkaKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(623);
    match(NebulaSQLParser::KAFKA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaBrokerContext ------------------------------------------------------------------

NebulaSQLParser::KafkaBrokerContext::KafkaBrokerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaBrokerContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::KafkaBrokerContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaBroker;
}

void NebulaSQLParser::KafkaBrokerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaBroker(this);
}

void NebulaSQLParser::KafkaBrokerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaBroker(this);
}

NebulaSQLParser::KafkaBrokerContext* NebulaSQLParser::kafkaBroker() {
  KafkaBrokerContext *_localctx = _tracker.createInstance<KafkaBrokerContext>(_ctx, getState());
  enterRule(_localctx, 116, NebulaSQLParser::RuleKafkaBroker);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(625);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaTopicContext ------------------------------------------------------------------

NebulaSQLParser::KafkaTopicContext::KafkaTopicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaTopicContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::KafkaTopicContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaTopic;
}

void NebulaSQLParser::KafkaTopicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaTopic(this);
}

void NebulaSQLParser::KafkaTopicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaTopic(this);
}

NebulaSQLParser::KafkaTopicContext* NebulaSQLParser::kafkaTopic() {
  KafkaTopicContext *_localctx = _tracker.createInstance<KafkaTopicContext>(_ctx, getState());
  enterRule(_localctx, 118, NebulaSQLParser::RuleKafkaTopic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(627);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaProducerTimoutContext ------------------------------------------------------------------

NebulaSQLParser::KafkaProducerTimoutContext::KafkaProducerTimoutContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaProducerTimoutContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::KafkaProducerTimoutContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaProducerTimout;
}

void NebulaSQLParser::KafkaProducerTimoutContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaProducerTimout(this);
}

void NebulaSQLParser::KafkaProducerTimoutContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaProducerTimout(this);
}

NebulaSQLParser::KafkaProducerTimoutContext* NebulaSQLParser::kafkaProducerTimout() {
  KafkaProducerTimoutContext *_localctx = _tracker.createInstance<KafkaProducerTimoutContext>(_ctx, getState());
  enterRule(_localctx, 120, NebulaSQLParser::RuleKafkaProducerTimout);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeFileContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeFileContext::SinkTypeFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::FILE() {
  return getToken(NebulaSQLParser::FILE, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeFileContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::SinkTypeFileContext::fileFormat() {
  return getRuleContext<NebulaSQLParser::FileFormatContext>(0);
}


size_t NebulaSQLParser::SinkTypeFileContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeFile;
}

void NebulaSQLParser::SinkTypeFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeFile(this);
}

void NebulaSQLParser::SinkTypeFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeFile(this);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::sinkTypeFile() {
  SinkTypeFileContext *_localctx = _tracker.createInstance<SinkTypeFileContext>(_ctx, getState());
  enterRule(_localctx, 122, NebulaSQLParser::RuleSinkTypeFile);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(631);
    match(NebulaSQLParser::FILE);
    setState(632);
    match(NebulaSQLParser::T__2);
    setState(633);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->path = match(NebulaSQLParser::STRING);
    setState(634);
    match(NebulaSQLParser::T__1);
    setState(635);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->format = fileFormat();
    setState(636);
    match(NebulaSQLParser::T__1);
    setState(637);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->append = match(NebulaSQLParser::STRING);
    setState(638);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileFormatContext ------------------------------------------------------------------

NebulaSQLParser::FileFormatContext::FileFormatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::CSV_FORMAT() {
  return getToken(NebulaSQLParser::CSV_FORMAT, 0);
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::NES_FORMAT() {
  return getToken(NebulaSQLParser::NES_FORMAT, 0);
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::TEXT_FORMAT() {
  return getToken(NebulaSQLParser::TEXT_FORMAT, 0);
}


size_t NebulaSQLParser::FileFormatContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFileFormat;
}

void NebulaSQLParser::FileFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileFormat(this);
}

void NebulaSQLParser::FileFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileFormat(this);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::fileFormat() {
  FileFormatContext *_localctx = _tracker.createInstance<FileFormatContext>(_ctx, getState());
  enterRule(_localctx, 124, NebulaSQLParser::RuleFileFormat);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeMQTTContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeMQTTContext::SinkTypeMQTTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::MQTT() {
  return getToken(NebulaSQLParser::MQTT, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeMQTTContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeMQTTContext::INTEGER_VALUE() {
  return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::INTEGER_VALUE(size_t i) {
  return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SinkTypeMQTTContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}

NebulaSQLParser::QosContext* NebulaSQLParser::SinkTypeMQTTContext::qos() {
  return getRuleContext<NebulaSQLParser::QosContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::BOOLEAN_VALUE() {
  return getToken(NebulaSQLParser::BOOLEAN_VALUE, 0);
}


size_t NebulaSQLParser::SinkTypeMQTTContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeMQTT;
}

void NebulaSQLParser::SinkTypeMQTTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeMQTT(this);
}

void NebulaSQLParser::SinkTypeMQTTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeMQTT(this);
}

NebulaSQLParser::SinkTypeMQTTContext* NebulaSQLParser::sinkTypeMQTT() {
  SinkTypeMQTTContext *_localctx = _tracker.createInstance<SinkTypeMQTTContext>(_ctx, getState());
  enterRule(_localctx, 126, NebulaSQLParser::RuleSinkTypeMQTT);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(642);
    match(NebulaSQLParser::MQTT);
    setState(643);
    match(NebulaSQLParser::T__2);
    setState(644);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->mqttHostLabel = match(NebulaSQLParser::STRING);
    setState(645);
    match(NebulaSQLParser::T__1);
    setState(646);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->topic = match(NebulaSQLParser::STRING);
    setState(647);
    match(NebulaSQLParser::T__1);
    setState(648);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->user = match(NebulaSQLParser::STRING);
    setState(649);
    match(NebulaSQLParser::T__1);
    setState(650);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->maxBufferedMSGs = match(NebulaSQLParser::INTEGER_VALUE);
    setState(651);
    match(NebulaSQLParser::T__1);
    setState(652);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->mqttTimeUnitLabel = timeUnit();
    setState(653);
    match(NebulaSQLParser::T__1);
    setState(654);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->messageDelay = match(NebulaSQLParser::INTEGER_VALUE);
    setState(655);
    match(NebulaSQLParser::T__1);
    setState(656);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->qualityOfService = qos();
    setState(657);
    match(NebulaSQLParser::T__1);
    setState(658);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->asynchronousClient = match(NebulaSQLParser::BOOLEAN_VALUE);
    setState(659);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QosContext ------------------------------------------------------------------

NebulaSQLParser::QosContext::QosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QosContext::AT_MOST_ONCE() {
  return getToken(NebulaSQLParser::AT_MOST_ONCE, 0);
}

tree::TerminalNode* NebulaSQLParser::QosContext::AT_LEAST_ONCE() {
  return getToken(NebulaSQLParser::AT_LEAST_ONCE, 0);
}


size_t NebulaSQLParser::QosContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQos;
}

void NebulaSQLParser::QosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQos(this);
}

void NebulaSQLParser::QosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQos(this);
}

NebulaSQLParser::QosContext* NebulaSQLParser::qos() {
  QosContext *_localctx = _tracker.createInstance<QosContext>(_ctx, getState());
  enterRule(_localctx, 128, NebulaSQLParser::RuleQos);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(661);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::AT_MOST_ONCE

    || _la == NebulaSQLParser::AT_LEAST_ONCE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeOPCContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeOPCContext::SinkTypeOPCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeOPCContext::OPC() {
  return getToken(NebulaSQLParser::OPC, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeOPCContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeOPCContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}


size_t NebulaSQLParser::SinkTypeOPCContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeOPC;
}

void NebulaSQLParser::SinkTypeOPCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeOPC(this);
}

void NebulaSQLParser::SinkTypeOPCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeOPC(this);
}

NebulaSQLParser::SinkTypeOPCContext* NebulaSQLParser::sinkTypeOPC() {
  SinkTypeOPCContext *_localctx = _tracker.createInstance<SinkTypeOPCContext>(_ctx, getState());
  enterRule(_localctx, 130, NebulaSQLParser::RuleSinkTypeOPC);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    match(NebulaSQLParser::OPC);
    setState(664);
    match(NebulaSQLParser::T__2);
    setState(665);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->url = match(NebulaSQLParser::STRING);
    setState(666);
    match(NebulaSQLParser::T__1);
    setState(667);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->nodeId = match(NebulaSQLParser::STRING);
    setState(668);
    match(NebulaSQLParser::T__1);
    setState(669);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->user = match(NebulaSQLParser::STRING);
    setState(670);
    match(NebulaSQLParser::T__1);
    setState(671);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->password = match(NebulaSQLParser::STRING);
    setState(672);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypePrintContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypePrintContext::SinkTypePrintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypePrintContext::PRINT() {
  return getToken(NebulaSQLParser::PRINT, 0);
}


size_t NebulaSQLParser::SinkTypePrintContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypePrint;
}

void NebulaSQLParser::SinkTypePrintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypePrint(this);
}

void NebulaSQLParser::SinkTypePrintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypePrint(this);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::sinkTypePrint() {
  SinkTypePrintContext *_localctx = _tracker.createInstance<SinkTypePrintContext>(_ctx, getState());
  enterRule(_localctx, 132, NebulaSQLParser::RuleSinkTypePrint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    match(NebulaSQLParser::PRINT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

NebulaSQLParser::SortItemContext::SortItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::SortItemContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}


size_t NebulaSQLParser::SortItemContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSortItem;
}

void NebulaSQLParser::SortItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortItem(this);
}

void NebulaSQLParser::SortItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortItem(this);
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::sortItem() {
  SortItemContext *_localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
  enterRule(_localctx, 134, NebulaSQLParser::RuleSortItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(676);
    expression();
    setState(678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::ASC

    || _la == NebulaSQLParser::DESC) {
      setState(677);
      antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::ASC

      || _la == NebulaSQLParser::DESC)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::NULLS) {
      setState(680);
      match(NebulaSQLParser::NULLS);
      setState(681);
      antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::FIRST

      || _la == NebulaSQLParser::LAST)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

NebulaSQLParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::PredicateContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicateContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::PredicateContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::PredicateContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IN() {
  return getToken(NebulaSQLParser::IN, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::PredicateContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ANY() {
  return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::SOME() {
  return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ESCAPE() {
  return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IS() {
  return getToken(NebulaSQLParser::IS, 0);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::PredicateContext::nullNotnull() {
  return getRuleContext<NebulaSQLParser::NullNotnullContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::UNKNOWN() {
  return getToken(NebulaSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::DISTINCT() {
  return getToken(NebulaSQLParser::DISTINCT, 0);
}


size_t NebulaSQLParser::PredicateContext::getRuleIndex() const {
  return NebulaSQLParser::RulePredicate;
}

void NebulaSQLParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void NebulaSQLParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 136, NebulaSQLParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(763);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(685);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(684);
        match(NebulaSQLParser::NOT);
      }
      setState(687);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::BETWEEN);
      setState(688);
      antlrcpp::downCast<PredicateContext *>(_localctx)->lower = valueExpression(0);
      setState(689);
      match(NebulaSQLParser::AND);
      setState(690);
      antlrcpp::downCast<PredicateContext *>(_localctx)->upper = valueExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(693);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(692);
        match(NebulaSQLParser::NOT);
      }
      setState(695);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::IN);
      setState(696);
      match(NebulaSQLParser::T__2);
      setState(697);
      expression();
      setState(702);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(698);
        match(NebulaSQLParser::T__1);
        setState(699);
        expression();
        setState(704);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(705);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(708);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(707);
        match(NebulaSQLParser::NOT);
      }
      setState(710);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::IN);
      setState(711);
      match(NebulaSQLParser::T__2);
      setState(712);
      query();
      setState(713);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(716);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(715);
        match(NebulaSQLParser::NOT);
      }
      setState(718);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::RLIKE);
      setState(719);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(721);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(720);
        match(NebulaSQLParser::NOT);
      }
      setState(723);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::LIKE);
      setState(724);
      antlrcpp::downCast<PredicateContext *>(_localctx)->quantifier = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 9) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 9)) & 36028797018963973) != 0))) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->quantifier = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(738);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(725);
        match(NebulaSQLParser::T__2);
        setState(726);
        match(NebulaSQLParser::T__3);
        break;
      }

      case 2: {
        setState(727);
        match(NebulaSQLParser::T__2);
        setState(728);
        expression();
        setState(733);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(729);
          match(NebulaSQLParser::T__1);
          setState(730);
          expression();
          setState(735);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(736);
        match(NebulaSQLParser::T__3);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(741);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(740);
        match(NebulaSQLParser::NOT);
      }
      setState(743);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::LIKE);
      setState(744);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      setState(747);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
      case 1: {
        setState(745);
        match(NebulaSQLParser::ESCAPE);
        setState(746);
        antlrcpp::downCast<PredicateContext *>(_localctx)->escapeChar = match(NebulaSQLParser::STRING);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(749);
      match(NebulaSQLParser::IS);
      setState(750);
      nullNotnull();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(751);
      match(NebulaSQLParser::IS);
      setState(753);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(752);
        match(NebulaSQLParser::NOT);
      }
      setState(755);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 28) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 28)) & 9895604649985) != 0))) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(756);
      match(NebulaSQLParser::IS);
      setState(758);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(757);
        match(NebulaSQLParser::NOT);
      }
      setState(760);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::DISTINCT);
      setState(761);
      match(NebulaSQLParser::FROM);
      setState(762);
      antlrcpp::downCast<PredicateContext *>(_localctx)->right = valueExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext::ValueExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ValueExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleValueExpression;
}

void NebulaSQLParser::ValueExpressionContext::copyFrom(ValueExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ValueExpressionDefaultContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::ValueExpressionDefaultContext::primaryExpression() {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::ValueExpressionDefaultContext::ValueExpressionDefaultContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ValueExpressionDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueExpressionDefault(this);
}
void NebulaSQLParser::ValueExpressionDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueExpressionDefault(this);
}
//----------------- ComparisonContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::ComparisonContext::comparisonOperator() {
  return getRuleContext<NebulaSQLParser::ComparisonOperatorContext>(0);
}

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::ComparisonContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ComparisonContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

NebulaSQLParser::ComparisonContext::ComparisonContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}
void NebulaSQLParser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}
//----------------- ArithmeticBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::ArithmeticBinaryContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticBinaryContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::ASTERISK() {
  return getToken(NebulaSQLParser::ASTERISK, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::SLASH() {
  return getToken(NebulaSQLParser::SLASH, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PERCENT() {
  return getToken(NebulaSQLParser::PERCENT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PLUS() {
  return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::CONCAT_PIPE() {
  return getToken(NebulaSQLParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::AMPERSAND() {
  return getToken(NebulaSQLParser::AMPERSAND, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::HAT() {
  return getToken(NebulaSQLParser::HAT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PIPE() {
  return getToken(NebulaSQLParser::PIPE, 0);
}

NebulaSQLParser::ArithmeticBinaryContext::ArithmeticBinaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ArithmeticBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticBinary(this);
}
void NebulaSQLParser::ArithmeticBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticBinary(this);
}
//----------------- ArithmeticUnaryContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticUnaryContext::valueExpression() {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::PLUS() {
  return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::TILDE() {
  return getToken(NebulaSQLParser::TILDE, 0);
}

NebulaSQLParser::ArithmeticUnaryContext::ArithmeticUnaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ArithmeticUnaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticUnary(this);
}
void NebulaSQLParser::ArithmeticUnaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticUnary(this);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression() {
   return valueExpression(0);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::ValueExpressionContext *_localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
  NebulaSQLParser::ValueExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 138;
  enterRecursionRule(_localctx, 138, NebulaSQLParser::RuleValueExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(769);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ValueExpressionDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(766);
      primaryExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ArithmeticUnaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(767);
      antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 115) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 115)) & 35) != 0))) {
        antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(768);
      valueExpression(7);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(792);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(790);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(771);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(772);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == NebulaSQLParser::DIV || ((((_la - 117) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 117)) & 7) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(773);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(7);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(774);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(775);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 115) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 115)) & 259) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(776);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(6);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(777);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(778);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::AMPERSAND);
          setState(779);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(5);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(780);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(781);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::HAT);
          setState(782);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(4);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(783);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(784);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::PIPE);
          setState(785);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(3);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ComparisonContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(786);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(787);
          comparisonOperator();
          setState(788);
          antlrcpp::downCast<ComparisonContext *>(_localctx)->right = valueExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(794);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::EQ() {
  return getToken(NebulaSQLParser::EQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQ() {
  return getToken(NebulaSQLParser::NEQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQJ() {
  return getToken(NebulaSQLParser::NEQJ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LT() {
  return getToken(NebulaSQLParser::LT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LTE() {
  return getToken(NebulaSQLParser::LTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GT() {
  return getToken(NebulaSQLParser::GT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GTE() {
  return getToken(NebulaSQLParser::GTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NSEQ() {
  return getToken(NebulaSQLParser::NSEQ, 0);
}


size_t NebulaSQLParser::ComparisonOperatorContext::getRuleIndex() const {
  return NebulaSQLParser::RuleComparisonOperator;
}

void NebulaSQLParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void NebulaSQLParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 140, NebulaSQLParser::RuleComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    _la = _input->LA(1);
    if (!(((((_la - 107) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 107)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HintContext ------------------------------------------------------------------

NebulaSQLParser::HintContext::HintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::HintStatementContext *> NebulaSQLParser::HintContext::hintStatement() {
  return getRuleContexts<NebulaSQLParser::HintStatementContext>();
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::HintContext::hintStatement(size_t i) {
  return getRuleContext<NebulaSQLParser::HintStatementContext>(i);
}


size_t NebulaSQLParser::HintContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHint;
}

void NebulaSQLParser::HintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHint(this);
}

void NebulaSQLParser::HintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHint(this);
}

NebulaSQLParser::HintContext* NebulaSQLParser::hint() {
  HintContext *_localctx = _tracker.createInstance<HintContext>(_ctx, getState());
  enterRule(_localctx, 142, NebulaSQLParser::RuleHint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(797);
    match(NebulaSQLParser::T__5);
    setState(798);
    antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext = hintStatement();
    antlrcpp::downCast<HintContext *>(_localctx)->hintStatements.push_back(antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext);
    setState(805);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(800);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
        case 1: {
          setState(799);
          match(NebulaSQLParser::T__1);
          break;
        }

        default:
          break;
        }
        setState(802);
        antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext = hintStatement();
        antlrcpp::downCast<HintContext *>(_localctx)->hintStatements.push_back(antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext); 
      }
      setState(807);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
    }
    setState(808);
    match(NebulaSQLParser::T__6);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HintStatementContext ------------------------------------------------------------------

NebulaSQLParser::HintStatementContext::HintStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::HintStatementContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

std::vector<NebulaSQLParser::PrimaryExpressionContext *> NebulaSQLParser::HintStatementContext::primaryExpression() {
  return getRuleContexts<NebulaSQLParser::PrimaryExpressionContext>();
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::HintStatementContext::primaryExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(i);
}


size_t NebulaSQLParser::HintStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHintStatement;
}

void NebulaSQLParser::HintStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHintStatement(this);
}

void NebulaSQLParser::HintStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHintStatement(this);
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::hintStatement() {
  HintStatementContext *_localctx = _tracker.createInstance<HintStatementContext>(_ctx, getState());
  enterRule(_localctx, 144, NebulaSQLParser::RuleHintStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(823);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(810);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->hintName = identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(811);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->hintName = identifier();
      setState(812);
      match(NebulaSQLParser::T__2);
      setState(813);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext = primaryExpression(0);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->parameters.push_back(antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext);
      setState(818);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(814);
        match(NebulaSQLParser::T__1);
        setState(815);
        antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext = primaryExpression(0);
        antlrcpp::downCast<HintStatementContext *>(_localctx)->parameters.push_back(antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext);
        setState(820);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(821);
      match(NebulaSQLParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::PrimaryExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RulePrimaryExpression;
}

void NebulaSQLParser::PrimaryExpressionContext::copyFrom(PrimaryExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DereferenceContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::DereferenceContext::primaryExpression() {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::DereferenceContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::DereferenceContext::DereferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DereferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDereference(this);
}
void NebulaSQLParser::DereferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDereference(this);
}
//----------------- ConstantDefaultContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext* NebulaSQLParser::ConstantDefaultContext::constant() {
  return getRuleContext<NebulaSQLParser::ConstantContext>(0);
}

NebulaSQLParser::ConstantDefaultContext::ConstantDefaultContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ConstantDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantDefault(this);
}
void NebulaSQLParser::ConstantDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantDefault(this);
}
//----------------- ColumnReferenceContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ColumnReferenceContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ColumnReferenceContext::ColumnReferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ColumnReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnReference(this);
}
void NebulaSQLParser::ColumnReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnReference(this);
}
//----------------- RowConstructorContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::NamedExpressionContext *> NebulaSQLParser::RowConstructorContext::namedExpression() {
  return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::RowConstructorContext::namedExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}

NebulaSQLParser::RowConstructorContext::RowConstructorContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::RowConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowConstructor(this);
}
void NebulaSQLParser::RowConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowConstructor(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ParenthesizedExpressionContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void NebulaSQLParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- StarContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::StarContext::ASTERISK() {
  return getToken(NebulaSQLParser::ASTERISK, 0);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::StarContext::qualifiedName() {
  return getRuleContext<NebulaSQLParser::QualifiedNameContext>(0);
}

NebulaSQLParser::StarContext::StarContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::StarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar(this);
}
void NebulaSQLParser::StarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::FunctionCallContext::functionName() {
  return getRuleContext<NebulaSQLParser::FunctionNameContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::FunctionCallContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionCallContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::FunctionCallContext::FunctionCallContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}
void NebulaSQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}
//----------------- SubqueryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryExpressionContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryExpressionContext::SubqueryExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SubqueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubqueryExpression(this);
}
void NebulaSQLParser::SubqueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubqueryExpression(this);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression() {
   return primaryExpression(0);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
  NebulaSQLParser::PrimaryExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 146;
  enterRecursionRule(_localctx, 146, NebulaSQLParser::RulePrimaryExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(865);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(826);
      match(NebulaSQLParser::ASTERISK);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(827);
      qualifiedName();
      setState(828);
      match(NebulaSQLParser::T__4);
      setState(829);
      match(NebulaSQLParser::ASTERISK);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SubqueryExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(831);
      match(NebulaSQLParser::T__2);
      setState(832);
      query();
      setState(833);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<RowConstructorContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(835);
      match(NebulaSQLParser::T__2);
      setState(836);
      namedExpression();
      setState(839); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(837);
        match(NebulaSQLParser::T__1);
        setState(838);
        namedExpression();
        setState(841); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == NebulaSQLParser::T__1);
      setState(843);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(845);
      functionName();
      setState(846);
      match(NebulaSQLParser::T__2);
      setState(855);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
      case 1: {
        setState(847);
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
        setState(852);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(848);
          match(NebulaSQLParser::T__1);
          setState(849);
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
          setState(854);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(857);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(859);
      match(NebulaSQLParser::T__2);
      setState(860);
      expression();
      setState(861);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<ConstantDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(863);
      constant();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<ColumnReferenceContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(864);
      identifier();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(872);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<DereferenceContext>(_tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->base = previousContext;
        pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
        setState(867);

        if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
        setState(868);
        match(NebulaSQLParser::T__4);
        setState(869);
        antlrcpp::downCast<DereferenceContext *>(_localctx)->fieldName = identifier(); 
      }
      setState(874);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

NebulaSQLParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::IdentifierContext *> NebulaSQLParser::QualifiedNameContext::identifier() {
  return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::QualifiedNameContext::identifier(size_t i) {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}


size_t NebulaSQLParser::QualifiedNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQualifiedName;
}

void NebulaSQLParser::QualifiedNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedName(this);
}

void NebulaSQLParser::QualifiedNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedName(this);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::qualifiedName() {
  QualifiedNameContext *_localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
  enterRule(_localctx, 148, NebulaSQLParser::RuleQualifiedName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(875);
    identifier();
    setState(880);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(876);
        match(NebulaSQLParser::T__4);
        setState(877);
        identifier(); 
      }
      setState(882);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::NumberContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNumber;
}

void NebulaSQLParser::NumberContext::copyFrom(NumberContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DecimalLiteralContext::DecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecimalLiteral(this);
}
void NebulaSQLParser::DecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecimalLiteral(this);
}
//----------------- BigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::BIGINT_LITERAL() {
  return getToken(NebulaSQLParser::BIGINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigIntLiteralContext::BigIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BigIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigIntLiteral(this);
}
void NebulaSQLParser::BigIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigIntLiteral(this);
}
//----------------- TinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::TINYINT_LITERAL() {
  return getToken(NebulaSQLParser::TINYINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::TinyIntLiteralContext::TinyIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TinyIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTinyIntLiteral(this);
}
void NebulaSQLParser::TinyIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTinyIntLiteral(this);
}
//----------------- LegacyDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::EXPONENT_VALUE() {
  return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::LegacyDecimalLiteralContext::LegacyDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LegacyDecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLegacyDecimalLiteral(this);
}
void NebulaSQLParser::LegacyDecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLegacyDecimalLiteral(this);
}
//----------------- BigDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::BIGDECIMAL_LITERAL() {
  return getToken(NebulaSQLParser::BIGDECIMAL_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigDecimalLiteralContext::BigDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BigDecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigDecimalLiteral(this);
}
void NebulaSQLParser::BigDecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigDecimalLiteral(this);
}
//----------------- ExponentLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::EXPONENT_VALUE() {
  return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::ExponentLiteralContext::ExponentLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ExponentLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExponentLiteral(this);
}
void NebulaSQLParser::ExponentLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExponentLiteral(this);
}
//----------------- DoubleLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::DOUBLE_LITERAL() {
  return getToken(NebulaSQLParser::DOUBLE_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DoubleLiteralContext::DoubleLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DoubleLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoubleLiteral(this);
}
void NebulaSQLParser::DoubleLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoubleLiteral(this);
}
//----------------- IntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::IntegerLiteralContext::IntegerLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::IntegerLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerLiteral(this);
}
void NebulaSQLParser::IntegerLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerLiteral(this);
}
//----------------- FloatLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::FLOAT_LITERAL() {
  return getToken(NebulaSQLParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::FloatLiteralContext::FloatLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FloatLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloatLiteral(this);
}
void NebulaSQLParser::FloatLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloatLiteral(this);
}
//----------------- SmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::SMALLINT_LITERAL() {
  return getToken(NebulaSQLParser::SMALLINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::SmallIntLiteralContext::SmallIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SmallIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSmallIntLiteral(this);
}
void NebulaSQLParser::SmallIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSmallIntLiteral(this);
}
NebulaSQLParser::NumberContext* NebulaSQLParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 150, NebulaSQLParser::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(926);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ExponentLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(883);

      if (!(!legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
      setState(885);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(884);
        match(NebulaSQLParser::MINUS);
      }
      setState(887);
      match(NebulaSQLParser::EXPONENT_VALUE);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::DecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(888);

      if (!(!legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
      setState(890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(889);
        match(NebulaSQLParser::MINUS);
      }
      setState(892);
      match(NebulaSQLParser::DECIMAL_VALUE);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::LegacyDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(893);

      if (!(legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "legacy_exponent_literal_as_decimal_enabled");
      setState(895);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(894);
        match(NebulaSQLParser::MINUS);
      }
      setState(897);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::EXPONENT_VALUE

      || _la == NebulaSQLParser::DECIMAL_VALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::IntegerLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(898);
        match(NebulaSQLParser::MINUS);
      }
      setState(901);
      match(NebulaSQLParser::INTEGER_VALUE);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BigIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(903);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(902);
        match(NebulaSQLParser::MINUS);
      }
      setState(905);
      match(NebulaSQLParser::BIGINT_LITERAL);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<NebulaSQLParser::SmallIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(907);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(906);
        match(NebulaSQLParser::MINUS);
      }
      setState(909);
      match(NebulaSQLParser::SMALLINT_LITERAL);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TinyIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(911);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(910);
        match(NebulaSQLParser::MINUS);
      }
      setState(913);
      match(NebulaSQLParser::TINYINT_LITERAL);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<NebulaSQLParser::DoubleLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(914);
        match(NebulaSQLParser::MINUS);
      }
      setState(917);
      match(NebulaSQLParser::DOUBLE_LITERAL);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<NebulaSQLParser::FloatLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(919);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(918);
        match(NebulaSQLParser::MINUS);
      }
      setState(921);
      match(NebulaSQLParser::FLOAT_LITERAL);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BigDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(922);
        match(NebulaSQLParser::MINUS);
      }
      setState(925);
      match(NebulaSQLParser::BIGDECIMAL_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ConstantContext::getRuleIndex() const {
  return NebulaSQLParser::RuleConstant;
}

void NebulaSQLParser::ConstantContext::copyFrom(ConstantContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NullLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::NullLiteralContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

NebulaSQLParser::NullLiteralContext::NullLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullLiteral(this);
}
void NebulaSQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullLiteral(this);
}
//----------------- StringLiteralContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> NebulaSQLParser::StringLiteralContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::StringLiteralContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::StringLiteralContext::StringLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}
void NebulaSQLParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}
//----------------- TypeConstructorContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::TypeConstructorContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TypeConstructorContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}

NebulaSQLParser::TypeConstructorContext::TypeConstructorContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TypeConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeConstructor(this);
}
void NebulaSQLParser::TypeConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeConstructor(this);
}
//----------------- NumericLiteralContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext* NebulaSQLParser::NumericLiteralContext::number() {
  return getRuleContext<NebulaSQLParser::NumberContext>(0);
}

NebulaSQLParser::NumericLiteralContext::NumericLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}
void NebulaSQLParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}
//----------------- BooleanLiteralContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::BooleanLiteralContext::booleanValue() {
  return getRuleContext<NebulaSQLParser::BooleanValueContext>(0);
}

NebulaSQLParser::BooleanLiteralContext::BooleanLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}
void NebulaSQLParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}
NebulaSQLParser::ConstantContext* NebulaSQLParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 152, NebulaSQLParser::RuleConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(939);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::NullLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(928);
      match(NebulaSQLParser::NULLTOKEN);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TypeConstructorContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(929);
      identifier();
      setState(930);
      match(NebulaSQLParser::STRING);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::NumericLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(932);
      number();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BooleanLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(933);
      booleanValue();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::StringLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(935); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(934);
                match(NebulaSQLParser::STRING);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(937); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext::BooleanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}


size_t NebulaSQLParser::BooleanValueContext::getRuleIndex() const {
  return NebulaSQLParser::RuleBooleanValue;
}

void NebulaSQLParser::BooleanValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanValue(this);
}

void NebulaSQLParser::BooleanValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanValue(this);
}

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::booleanValue() {
  BooleanValueContext *_localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
  enterRule(_localctx, 154, NebulaSQLParser::RuleBooleanValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(941);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::FALSE

    || _la == NebulaSQLParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::StrictNonReservedContext::StrictNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::FULL() {
  return getToken(NebulaSQLParser::FULL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::INNER() {
  return getToken(NebulaSQLParser::INNER, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::JOIN() {
  return getToken(NebulaSQLParser::JOIN, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::LEFT() {
  return getToken(NebulaSQLParser::LEFT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::NATURAL() {
  return getToken(NebulaSQLParser::NATURAL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::ON() {
  return getToken(NebulaSQLParser::ON, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::RIGHT() {
  return getToken(NebulaSQLParser::RIGHT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::UNION() {
  return getToken(NebulaSQLParser::UNION, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::USING() {
  return getToken(NebulaSQLParser::USING, 0);
}


size_t NebulaSQLParser::StrictNonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStrictNonReserved;
}

void NebulaSQLParser::StrictNonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrictNonReserved(this);
}

void NebulaSQLParser::StrictNonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrictNonReserved(this);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::strictNonReserved() {
  StrictNonReservedContext *_localctx = _tracker.createInstance<StrictNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 156, NebulaSQLParser::RuleStrictNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(943);
    _la = _input->LA(1);
    if (!(((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 2474039710785) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnsiNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::AnsiNonReservedContext::AnsiNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::AT() {
  return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DELETE() {
  return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DROP() {
  return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::INSERT() {
  return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::MERGE() {
  return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::QUERY() {
  return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TYPE() {
  return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}


size_t NebulaSQLParser::AnsiNonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAnsiNonReserved;
}

void NebulaSQLParser::AnsiNonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnsiNonReserved(this);
}

void NebulaSQLParser::AnsiNonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnsiNonReserved(this);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::ansiNonReserved() {
  AnsiNonReservedContext *_localctx = _tracker.createInstance<AnsiNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 158, NebulaSQLParser::RuleAnsiNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(945);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5615592343523696640) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 579) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonReservedContext ------------------------------------------------------------------

NebulaSQLParser::NonReservedContext::NonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AT() {
  return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DELETE() {
  return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DROP() {
  return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INSERT() {
  return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::MERGE() {
  return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::QUERY() {
  return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TYPE() {
  return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ANY() {
  return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DISTINCT() {
  return getToken(NebulaSQLParser::DISTINCT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ESCAPE() {
  return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUP() {
  return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::HAVING() {
  return getToken(NebulaSQLParser::HAVING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IN() {
  return getToken(NebulaSQLParser::IN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INTO() {
  return getToken(NebulaSQLParser::INTO, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IS() {
  return getToken(NebulaSQLParser::IS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::OR() {
  return getToken(NebulaSQLParser::OR, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ORDER() {
  return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SELECT() {
  return getToken(NebulaSQLParser::SELECT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SOME() {
  return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TABLE() {
  return getToken(NebulaSQLParser::TABLE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WHERE() {
  return getToken(NebulaSQLParser::WHERE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WITH() {
  return getToken(NebulaSQLParser::WITH, 0);
}


size_t NebulaSQLParser::NonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNonReserved;
}

void NebulaSQLParser::NonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonReserved(this);
}

void NebulaSQLParser::NonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonReserved(this);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::nonReserved() {
  NonReservedContext *_localctx = _tracker.createInstance<NonReservedContext>(_ctx, getState());
  enterRule(_localctx, 160, NebulaSQLParser::RuleNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(947);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -892438752910246400) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 29749) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool NebulaSQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return queryTermSempred(antlrcpp::downCast<QueryTermContext *>(context), predicateIndex);
    case 24: return identifierSempred(antlrcpp::downCast<IdentifierContext *>(context), predicateIndex);
    case 25: return strictIdentifierSempred(antlrcpp::downCast<StrictIdentifierContext *>(context), predicateIndex);
    case 33: return booleanExpressionSempred(antlrcpp::downCast<BooleanExpressionContext *>(context), predicateIndex);
    case 69: return valueExpressionSempred(antlrcpp::downCast<ValueExpressionContext *>(context), predicateIndex);
    case 73: return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext *>(context), predicateIndex);
    case 75: return numberSempred(antlrcpp::downCast<NumberContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::queryTermSempred(QueryTermContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::identifierSempred(IdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return !SQL_standard_keyword_behavior;

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::strictIdentifierSempred(StrictIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return SQL_standard_keyword_behavior;
    case 3: return !SQL_standard_keyword_behavior;

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::booleanExpressionSempred(BooleanExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::valueExpressionSempred(ValueExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 6);
    case 7: return precpred(_ctx, 5);
    case 8: return precpred(_ctx, 4);
    case 9: return precpred(_ctx, 3);
    case 10: return precpred(_ctx, 2);
    case 11: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::primaryExpressionSempred(PrimaryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::numberSempred(NumberContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return !legacy_exponent_literal_as_decimal_enabled;
    case 14: return !legacy_exponent_literal_as_decimal_enabled;
    case 15: return legacy_exponent_literal_as_decimal_enabled;

  default:
    break;
  }
  return true;
}

void NebulaSQLParser::initialize() {
  ::antlr4::internal::call_once(nebulasqlParserOnceFlag, nebulasqlParserInitialize);
}
