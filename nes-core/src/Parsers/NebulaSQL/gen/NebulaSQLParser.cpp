
// Generated from NebulaSQL.g4 by ANTLR 4.12.0


#include "NebulaSQLListener.h"

#include "NebulaSQLParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct NebulaSQLParserStaticData final {
  NebulaSQLParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  NebulaSQLParserStaticData(const NebulaSQLParserStaticData&) = delete;
  NebulaSQLParserStaticData(NebulaSQLParserStaticData&&) = delete;
  NebulaSQLParserStaticData& operator=(const NebulaSQLParserStaticData&) = delete;
  NebulaSQLParserStaticData& operator=(NebulaSQLParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag nebulasqlParserOnceFlag;
NebulaSQLParserStaticData *nebulasqlParserStaticData = nullptr;

void nebulasqlParserInitialize() {
  assert(nebulasqlParserStaticData == nullptr);
  auto staticData = std::make_unique<NebulaSQLParserStaticData>(
    std::vector<std::string>{
      "singleStatement", "statement", "query", "queryOrganization", "queryTerm", 
      "queryPrimary", "querySpecification", "fromClause", "relation", "joinRelation", 
      "joinType", "joinCriteria", "relationPrimary", "functionTable", "fromStatement", 
      "fromStatementBody", "selectClause", "whereClause", "havingClause", 
      "inlineTable", "tableAlias", "multipartIdentifierList", "multipartIdentifier", 
      "namedExpression", "identifier", "strictIdentifier", "quotedIdentifier", 
      "identifierList", "identifierSeq", "errorCapturingIdentifier", "errorCapturingIdentifierExtra", 
      "namedExpressionSeq", "expression", "booleanExpression", "windowedAggregationClause", 
      "aggregationClause", "groupingSet", "windowClause", "watermarkClause", 
      "watermarkParameters", "windowSpec", "timeWindow", "countWindow", 
      "sizeParameter", "advancebyParameter", "timeUnit", "timestampParameter", 
      "functionName", "sinkClause", "sinkType", "sinkTypeCSV", "csvKeyword", 
      "sinkTypeZMQ", "nullNotnull", "zmqKeyword", "streamName", "host", 
      "port", "sinkTypeKafka", "kafkaKeyword", "kafkaBroker", "kafkaTopic", 
      "kafkaProducerTimout", "sinkTypeFile", "fileFormat", "sinkTypeMQTT", 
      "qos", "sinkTypeOPC", "sinkTypePrint", "sortItem", "predicate", "valueExpression", 
      "comparisonOperator", "hint", "hintStatement", "primaryExpression", 
      "qualifiedName", "number", "constant", "booleanValue", "strictNonReserved", 
      "ansiNonReserved", "nonReserved"
    },
    std::vector<std::string>{
      "", "';'", "','", "'('", "')'", "'.'", "'/*+'", "'*/'", "", "", "", 
      "'ANY'", "", "", "'AT'", "", "", "'COMMENT'", "'CUBE'", "'DELETE'", 
      "", "'DISTINCT'", "'DIV'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", 
      "'EXISTS'", "'FALSE'", "'FIRST'", "'FOR'", "", "'FULL'", "", "'GROUPING'", 
      "", "'IF'", "", "", "", "", "", "", "'LAST'", "'LEFT'", "'LIKE'", 
      "", "'LIST'", "", "'NATURAL'", "", "'NULL'", "'NULLS'", "'OF'", "", 
      "", "", "'QUERY'", "'RECOVER'", "'RIGHT'", "", "'ROLLUP'", "", "'SETS'", 
      "'SOME'", "'START'", "'TABLE'", "'TO'", "'TRUE'", "'TYPE'", "", "'UNKNOWN'", 
      "'USE'", "'USING'", "'VALUES'", "'WHEN'", "", "", "'WITH'", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'FILE'", 
      "'MQTT'", "'OPC'", "'PRINT'", "", "'CSV_FORMAT'", "'NES_FORMAT'", 
      "'TEXT_FORMAT'", "'AT_MOST_ONCE'", "'AT_LEAST_ONCE'", "", "", "'<=>'", 
      "'<>'", "'!='", "'<'", "", "'>'", "", "'+'", "'-'", "'*'", "'/'", 
      "'%'", "'~'", "'&'", "'|'", "'||'", "'^'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "BACKQUOTED_IDENTIFIER", "ALL", "AND", 
      "ANY", "AS", "ASC", "AT", "BETWEEN", "BY", "COMMENT", "CUBE", "DELETE", 
      "DESC", "DISTINCT", "DIV", "DROP", "ELSE", "END", "ESCAPE", "EXISTS", 
      "FALSE", "FIRST", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "HAVING", 
      "IF", "IN", "INNER", "INSERT", "INTO", "IS", "JOIN", "LAST", "LEFT", 
      "LIKE", "LIMIT", "LIST", "MERGE", "NATURAL", "NOT", "NULLTOKEN", "NULLS", 
      "OF", "ON", "OR", "ORDER", "QUERY", "RECOVER", "RIGHT", "RLIKE", "ROLLUP", 
      "SELECT", "SETS", "SOME", "START", "TABLE", "TO", "TRUE", "TYPE", 
      "UNION", "UNKNOWN", "USE", "USING", "VALUES", "WHEN", "WHERE", "WINDOW", 
      "WITH", "TUMBLING", "SLIDING", "SIZE", "ADVANCE", "MS", "SEC", "MIN", 
      "HOUR", "DAY", "MAX", "AVG", "SUM", "COUNT", "WATERMARK", "OFFSET", 
      "CSV", "ZMQ", "KAFKA", "FILE", "MQTT", "OPC", "PRINT", "LOCALHOST", 
      "CSV_FORMAT", "NES_FORMAT", "TEXT_FORMAT", "AT_MOST_ONCE", "AT_LEAST_ONCE", 
      "BOOLEAN_VALUE", "EQ", "NSEQ", "NEQ", "NEQJ", "LT", "LTE", "GT", "GTE", 
      "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", "TILDE", "AMPERSAND", 
      "PIPE", "CONCAT_PIPE", "HAT", "STRING", "BIGINT_LITERAL", "SMALLINT_LITERAL", 
      "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE", "DECIMAL_VALUE", 
      "FLOAT_LITERAL", "DOUBLE_LITERAL", "BIGDECIMAL_LITERAL", "IDENTIFIER", 
      "SIMPLE_COMMENT", "BRACKETED_COMMENT", "WS", "FOUR_OCTETS", "OCTET", 
      "UNRECOGNIZED"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,142,961,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,1,0,1,0,5,0,169,
  	8,0,10,0,12,0,172,9,0,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,
  	5,3,186,8,3,10,3,12,3,189,9,3,3,3,191,8,3,1,3,1,3,1,3,3,3,196,8,3,3,3,
  	198,8,3,1,3,1,3,3,3,202,8,3,1,4,1,4,1,4,1,4,1,4,1,4,5,4,210,8,4,10,4,
  	12,4,213,9,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,224,8,5,1,6,1,6,
  	1,6,3,6,229,8,6,1,6,1,6,3,6,233,8,6,1,6,3,6,236,8,6,1,7,1,7,1,7,1,7,5,
  	7,242,8,7,10,7,12,7,245,9,7,1,8,1,8,5,8,249,8,8,10,8,12,8,252,9,8,1,9,
  	1,9,1,9,1,9,3,9,258,8,9,1,9,1,9,1,9,1,9,1,9,3,9,265,8,9,1,10,3,10,268,
  	8,10,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,
  	1,12,1,12,1,12,1,12,1,12,3,12,288,8,12,1,13,1,13,1,13,1,13,1,13,5,13,
  	295,8,13,10,13,12,13,298,9,13,3,13,300,8,13,1,13,1,13,1,13,1,14,1,14,
  	4,14,307,8,14,11,14,12,14,308,1,15,1,15,3,15,313,8,15,1,15,3,15,316,8,
  	15,1,16,1,16,5,16,320,8,16,10,16,12,16,323,9,16,1,16,1,16,1,17,1,17,1,
  	17,1,18,1,18,1,18,1,19,1,19,1,19,1,19,5,19,337,8,19,10,19,12,19,340,9,
  	19,1,19,1,19,1,20,3,20,345,8,20,1,20,1,20,3,20,349,8,20,3,20,351,8,20,
  	1,21,1,21,1,21,5,21,356,8,21,10,21,12,21,359,9,21,1,22,1,22,1,22,5,22,
  	364,8,22,10,22,12,22,367,9,22,1,23,1,23,3,23,371,8,23,1,23,1,23,3,23,
  	375,8,23,3,23,377,8,23,1,24,1,24,1,24,3,24,382,8,24,1,25,1,25,1,25,1,
  	25,1,25,1,25,3,25,390,8,25,1,26,1,26,1,27,1,27,1,27,1,27,1,28,1,28,1,
  	28,5,28,401,8,28,10,28,12,28,404,9,28,1,29,1,29,1,29,1,30,1,30,4,30,411,
  	8,30,11,30,12,30,412,1,30,3,30,416,8,30,1,31,1,31,1,31,5,31,421,8,31,
  	10,31,12,31,424,9,31,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,
  	1,33,1,33,3,33,438,8,33,3,33,440,8,33,1,33,1,33,1,33,1,33,1,33,1,33,5,
  	33,448,8,33,10,33,12,33,451,9,33,1,34,3,34,454,8,34,1,34,3,34,457,8,34,
  	1,34,3,34,460,8,34,1,35,1,35,1,35,1,35,1,35,5,35,467,8,35,10,35,12,35,
  	470,9,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,35,482,8,
  	35,10,35,12,35,485,9,35,1,35,1,35,3,35,489,8,35,1,35,1,35,1,35,1,35,1,
  	35,1,35,1,35,1,35,5,35,499,8,35,10,35,12,35,502,9,35,1,35,1,35,3,35,506,
  	8,35,1,36,1,36,1,36,1,36,5,36,512,8,36,10,36,12,36,515,9,36,3,36,517,
  	8,36,1,36,1,36,3,36,521,8,36,1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,
  	1,39,1,39,1,39,1,39,1,39,1,40,1,40,3,40,538,8,40,1,41,1,41,1,41,1,41,
  	1,41,3,41,545,8,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,555,8,
  	41,1,41,1,41,1,41,1,41,1,41,3,41,562,8,41,1,42,1,42,1,42,1,42,1,42,1,
  	43,1,43,1,43,1,43,1,44,1,44,1,44,1,44,1,44,1,45,1,45,1,46,1,46,1,47,1,
  	47,1,48,1,48,1,48,3,48,587,8,48,1,49,1,49,1,49,1,49,1,49,1,49,3,49,595,
  	8,49,1,50,1,50,1,50,1,50,1,50,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,
  	1,52,1,52,1,52,1,53,3,53,614,8,53,1,53,1,53,1,54,1,54,1,55,1,55,1,56,
  	1,56,1,57,1,57,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,59,1,59,
  	1,60,1,60,1,61,1,61,1,62,1,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
  	1,63,1,64,1,64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,
  	1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,66,1,66,1,67,1,67,1,67,1,67,
  	1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,68,1,68,1,69,1,69,3,69,690,8,69,
  	1,69,1,69,3,69,694,8,69,1,70,3,70,697,8,70,1,70,1,70,1,70,1,70,1,70,1,
  	70,3,70,705,8,70,1,70,1,70,1,70,1,70,1,70,5,70,712,8,70,10,70,12,70,715,
  	9,70,1,70,1,70,1,70,3,70,720,8,70,1,70,1,70,1,70,1,70,1,70,1,70,3,70,
  	728,8,70,1,70,1,70,1,70,3,70,733,8,70,1,70,1,70,1,70,1,70,1,70,1,70,1,
  	70,1,70,5,70,743,8,70,10,70,12,70,746,9,70,1,70,1,70,3,70,750,8,70,1,
  	70,3,70,753,8,70,1,70,1,70,1,70,1,70,3,70,759,8,70,1,70,1,70,1,70,1,70,
  	3,70,765,8,70,1,70,1,70,1,70,3,70,770,8,70,1,70,1,70,1,70,3,70,775,8,
  	70,1,71,1,71,1,71,1,71,3,71,781,8,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
  	71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,5,71,802,
  	8,71,10,71,12,71,805,9,71,1,72,1,72,1,73,1,73,1,73,3,73,812,8,73,1,73,
  	5,73,815,8,73,10,73,12,73,818,9,73,1,73,1,73,1,74,1,74,1,74,1,74,1,74,
  	1,74,5,74,828,8,74,10,74,12,74,831,9,74,1,74,1,74,3,74,835,8,74,1,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,4,75,
  	851,8,75,11,75,12,75,852,1,75,1,75,1,75,1,75,1,75,1,75,1,75,5,75,862,
  	8,75,10,75,12,75,865,9,75,3,75,867,8,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,3,75,877,8,75,1,75,1,75,1,75,5,75,882,8,75,10,75,12,75,885,
  	9,75,1,76,1,76,1,76,5,76,890,8,76,10,76,12,76,893,9,76,1,77,1,77,3,77,
  	897,8,77,1,77,1,77,1,77,3,77,902,8,77,1,77,1,77,1,77,3,77,907,8,77,1,
  	77,1,77,3,77,911,8,77,1,77,1,77,3,77,915,8,77,1,77,1,77,3,77,919,8,77,
  	1,77,1,77,3,77,923,8,77,1,77,1,77,3,77,927,8,77,1,77,1,77,3,77,931,8,
  	77,1,77,1,77,3,77,935,8,77,1,77,3,77,938,8,77,1,78,1,78,1,78,1,78,1,78,
  	1,78,1,78,4,78,947,8,78,11,78,12,78,948,3,78,951,8,78,1,79,1,79,1,80,
  	1,80,1,81,1,81,1,82,1,82,1,82,0,4,8,66,142,150,83,0,2,4,6,8,10,12,14,
  	16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
  	62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,148,150,152,154,156,158,160,162,164,0,18,1,0,83,87,2,0,85,
  	85,88,91,2,0,101,101,140,140,1,0,102,104,1,0,105,106,2,0,13,13,20,20,
  	2,0,29,29,43,43,3,0,9,9,11,11,64,64,3,0,28,28,68,68,71,71,2,0,116,117,
  	121,121,2,0,22,22,118,120,2,0,116,117,124,124,1,0,108,115,1,0,131,132,
  	2,0,28,28,68,68,9,0,32,32,38,38,42,42,44,44,49,49,54,54,59,59,70,70,73,
  	73,17,0,13,16,18,20,22,23,27,27,29,29,34,34,39,39,43,43,45,46,48,48,52,
  	52,57,57,60,61,63,63,68,69,74,74,77,77,17,0,9,16,18,23,26,29,31,31,33,
  	35,37,37,39,41,43,43,45,46,48,48,50,52,55,57,60,64,66,66,68,69,74,74,
  	76,78,1021,0,166,1,0,0,0,2,175,1,0,0,0,4,177,1,0,0,0,6,190,1,0,0,0,8,
  	203,1,0,0,0,10,223,1,0,0,0,12,225,1,0,0,0,14,237,1,0,0,0,16,246,1,0,0,
  	0,18,264,1,0,0,0,20,267,1,0,0,0,22,269,1,0,0,0,24,287,1,0,0,0,26,289,
  	1,0,0,0,28,304,1,0,0,0,30,310,1,0,0,0,32,317,1,0,0,0,34,326,1,0,0,0,36,
  	329,1,0,0,0,38,332,1,0,0,0,40,350,1,0,0,0,42,352,1,0,0,0,44,360,1,0,0,
  	0,46,368,1,0,0,0,48,381,1,0,0,0,50,389,1,0,0,0,52,391,1,0,0,0,54,393,
  	1,0,0,0,56,397,1,0,0,0,58,405,1,0,0,0,60,415,1,0,0,0,62,417,1,0,0,0,64,
  	425,1,0,0,0,66,439,1,0,0,0,68,453,1,0,0,0,70,505,1,0,0,0,72,520,1,0,0,
  	0,74,522,1,0,0,0,76,525,1,0,0,0,78,530,1,0,0,0,80,537,1,0,0,0,82,561,
  	1,0,0,0,84,563,1,0,0,0,86,568,1,0,0,0,88,572,1,0,0,0,90,577,1,0,0,0,92,
  	579,1,0,0,0,94,581,1,0,0,0,96,583,1,0,0,0,98,594,1,0,0,0,100,596,1,0,
  	0,0,102,601,1,0,0,0,104,603,1,0,0,0,106,613,1,0,0,0,108,617,1,0,0,0,110,
  	619,1,0,0,0,112,621,1,0,0,0,114,623,1,0,0,0,116,625,1,0,0,0,118,634,1,
  	0,0,0,120,636,1,0,0,0,122,638,1,0,0,0,124,640,1,0,0,0,126,642,1,0,0,0,
  	128,651,1,0,0,0,130,653,1,0,0,0,132,672,1,0,0,0,134,674,1,0,0,0,136,685,
  	1,0,0,0,138,687,1,0,0,0,140,774,1,0,0,0,142,780,1,0,0,0,144,806,1,0,0,
  	0,146,808,1,0,0,0,148,834,1,0,0,0,150,876,1,0,0,0,152,886,1,0,0,0,154,
  	937,1,0,0,0,156,950,1,0,0,0,158,952,1,0,0,0,160,954,1,0,0,0,162,956,1,
  	0,0,0,164,958,1,0,0,0,166,170,3,2,1,0,167,169,5,1,0,0,168,167,1,0,0,0,
  	169,172,1,0,0,0,170,168,1,0,0,0,170,171,1,0,0,0,171,173,1,0,0,0,172,170,
  	1,0,0,0,173,174,5,0,0,1,174,1,1,0,0,0,175,176,3,4,2,0,176,3,1,0,0,0,177,
  	178,3,8,4,0,178,179,3,6,3,0,179,5,1,0,0,0,180,181,5,56,0,0,181,182,5,
  	16,0,0,182,187,3,138,69,0,183,184,5,2,0,0,184,186,3,138,69,0,185,183,
  	1,0,0,0,186,189,1,0,0,0,187,185,1,0,0,0,187,188,1,0,0,0,188,191,1,0,0,
  	0,189,187,1,0,0,0,190,180,1,0,0,0,190,191,1,0,0,0,191,197,1,0,0,0,192,
  	195,5,46,0,0,193,196,5,9,0,0,194,196,5,130,0,0,195,193,1,0,0,0,195,194,
  	1,0,0,0,196,198,1,0,0,0,197,192,1,0,0,0,197,198,1,0,0,0,198,201,1,0,0,
  	0,199,200,5,93,0,0,200,202,5,130,0,0,201,199,1,0,0,0,201,202,1,0,0,0,
  	202,7,1,0,0,0,203,204,6,4,-1,0,204,205,3,10,5,0,205,211,1,0,0,0,206,207,
  	10,1,0,0,207,208,5,70,0,0,208,210,3,8,4,2,209,206,1,0,0,0,210,213,1,0,
  	0,0,211,209,1,0,0,0,211,212,1,0,0,0,212,9,1,0,0,0,213,211,1,0,0,0,214,
  	224,3,12,6,0,215,224,3,28,14,0,216,217,5,66,0,0,217,224,3,44,22,0,218,
  	224,3,38,19,0,219,220,5,3,0,0,220,221,3,4,2,0,221,222,5,4,0,0,222,224,
  	1,0,0,0,223,214,1,0,0,0,223,215,1,0,0,0,223,216,1,0,0,0,223,218,1,0,0,
  	0,223,219,1,0,0,0,224,11,1,0,0,0,225,226,3,32,16,0,226,228,3,14,7,0,227,
  	229,3,34,17,0,228,227,1,0,0,0,228,229,1,0,0,0,229,230,1,0,0,0,230,232,
  	3,96,48,0,231,233,3,68,34,0,232,231,1,0,0,0,232,233,1,0,0,0,233,235,1,
  	0,0,0,234,236,3,36,18,0,235,234,1,0,0,0,235,236,1,0,0,0,236,13,1,0,0,
  	0,237,238,5,31,0,0,238,243,3,16,8,0,239,240,5,2,0,0,240,242,3,16,8,0,
  	241,239,1,0,0,0,242,245,1,0,0,0,243,241,1,0,0,0,243,244,1,0,0,0,244,15,
  	1,0,0,0,245,243,1,0,0,0,246,250,3,24,12,0,247,249,3,18,9,0,248,247,1,
  	0,0,0,249,252,1,0,0,0,250,248,1,0,0,0,250,251,1,0,0,0,251,17,1,0,0,0,
  	252,250,1,0,0,0,253,254,3,20,10,0,254,255,5,42,0,0,255,257,3,24,12,0,
  	256,258,3,22,11,0,257,256,1,0,0,0,257,258,1,0,0,0,258,265,1,0,0,0,259,
  	260,5,49,0,0,260,261,3,20,10,0,261,262,5,42,0,0,262,263,3,24,12,0,263,
  	265,1,0,0,0,264,253,1,0,0,0,264,259,1,0,0,0,265,19,1,0,0,0,266,268,5,
  	38,0,0,267,266,1,0,0,0,267,268,1,0,0,0,268,21,1,0,0,0,269,270,5,54,0,
  	0,270,271,3,66,33,0,271,23,1,0,0,0,272,273,3,44,22,0,273,274,3,40,20,
  	0,274,288,1,0,0,0,275,276,5,3,0,0,276,277,3,4,2,0,277,278,5,4,0,0,278,
  	279,3,40,20,0,279,288,1,0,0,0,280,281,5,3,0,0,281,282,3,16,8,0,282,283,
  	5,4,0,0,283,284,3,40,20,0,284,288,1,0,0,0,285,288,3,38,19,0,286,288,3,
  	26,13,0,287,272,1,0,0,0,287,275,1,0,0,0,287,280,1,0,0,0,287,285,1,0,0,
  	0,287,286,1,0,0,0,288,25,1,0,0,0,289,290,3,58,29,0,290,299,5,3,0,0,291,
  	296,3,64,32,0,292,293,5,2,0,0,293,295,3,64,32,0,294,292,1,0,0,0,295,298,
  	1,0,0,0,296,294,1,0,0,0,296,297,1,0,0,0,297,300,1,0,0,0,298,296,1,0,0,
  	0,299,291,1,0,0,0,299,300,1,0,0,0,300,301,1,0,0,0,301,302,5,4,0,0,302,
  	303,3,40,20,0,303,27,1,0,0,0,304,306,3,14,7,0,305,307,3,30,15,0,306,305,
  	1,0,0,0,307,308,1,0,0,0,308,306,1,0,0,0,308,309,1,0,0,0,309,29,1,0,0,
  	0,310,312,3,32,16,0,311,313,3,34,17,0,312,311,1,0,0,0,312,313,1,0,0,0,
  	313,315,1,0,0,0,314,316,3,70,35,0,315,314,1,0,0,0,315,316,1,0,0,0,316,
  	31,1,0,0,0,317,321,5,62,0,0,318,320,3,146,73,0,319,318,1,0,0,0,320,323,
  	1,0,0,0,321,319,1,0,0,0,321,322,1,0,0,0,322,324,1,0,0,0,323,321,1,0,0,
  	0,324,325,3,62,31,0,325,33,1,0,0,0,326,327,5,76,0,0,327,328,3,66,33,0,
  	328,35,1,0,0,0,329,330,5,35,0,0,330,331,3,66,33,0,331,37,1,0,0,0,332,
  	333,5,74,0,0,333,338,3,64,32,0,334,335,5,2,0,0,335,337,3,64,32,0,336,
  	334,1,0,0,0,337,340,1,0,0,0,338,336,1,0,0,0,338,339,1,0,0,0,339,341,1,
  	0,0,0,340,338,1,0,0,0,341,342,3,40,20,0,342,39,1,0,0,0,343,345,5,12,0,
  	0,344,343,1,0,0,0,344,345,1,0,0,0,345,346,1,0,0,0,346,348,3,50,25,0,347,
  	349,3,54,27,0,348,347,1,0,0,0,348,349,1,0,0,0,349,351,1,0,0,0,350,344,
  	1,0,0,0,350,351,1,0,0,0,351,41,1,0,0,0,352,357,3,44,22,0,353,354,5,2,
  	0,0,354,356,3,44,22,0,355,353,1,0,0,0,356,359,1,0,0,0,357,355,1,0,0,0,
  	357,358,1,0,0,0,358,43,1,0,0,0,359,357,1,0,0,0,360,365,3,58,29,0,361,
  	362,5,5,0,0,362,364,3,58,29,0,363,361,1,0,0,0,364,367,1,0,0,0,365,363,
  	1,0,0,0,365,366,1,0,0,0,366,45,1,0,0,0,367,365,1,0,0,0,368,376,3,64,32,
  	0,369,371,5,12,0,0,370,369,1,0,0,0,370,371,1,0,0,0,371,374,1,0,0,0,372,
  	375,3,58,29,0,373,375,3,54,27,0,374,372,1,0,0,0,374,373,1,0,0,0,375,377,
  	1,0,0,0,376,370,1,0,0,0,376,377,1,0,0,0,377,47,1,0,0,0,378,382,3,50,25,
  	0,379,380,4,24,1,0,380,382,3,160,80,0,381,378,1,0,0,0,381,379,1,0,0,0,
  	382,49,1,0,0,0,383,390,5,136,0,0,384,390,3,52,26,0,385,386,4,25,2,0,386,
  	390,3,162,81,0,387,388,4,25,3,0,388,390,3,164,82,0,389,383,1,0,0,0,389,
  	384,1,0,0,0,389,385,1,0,0,0,389,387,1,0,0,0,390,51,1,0,0,0,391,392,5,
  	8,0,0,392,53,1,0,0,0,393,394,5,3,0,0,394,395,3,56,28,0,395,396,5,4,0,
  	0,396,55,1,0,0,0,397,402,3,58,29,0,398,399,5,2,0,0,399,401,3,58,29,0,
  	400,398,1,0,0,0,401,404,1,0,0,0,402,400,1,0,0,0,402,403,1,0,0,0,403,57,
  	1,0,0,0,404,402,1,0,0,0,405,406,3,48,24,0,406,407,3,60,30,0,407,59,1,
  	0,0,0,408,409,5,117,0,0,409,411,3,48,24,0,410,408,1,0,0,0,411,412,1,0,
  	0,0,412,410,1,0,0,0,412,413,1,0,0,0,413,416,1,0,0,0,414,416,1,0,0,0,415,
  	410,1,0,0,0,415,414,1,0,0,0,416,61,1,0,0,0,417,422,3,46,23,0,418,419,
  	5,2,0,0,419,421,3,46,23,0,420,418,1,0,0,0,421,424,1,0,0,0,422,420,1,0,
  	0,0,422,423,1,0,0,0,423,63,1,0,0,0,424,422,1,0,0,0,425,426,3,66,33,0,
  	426,65,1,0,0,0,427,428,6,33,-1,0,428,429,5,50,0,0,429,440,3,66,33,5,430,
  	431,5,27,0,0,431,432,5,3,0,0,432,433,3,4,2,0,433,434,5,4,0,0,434,440,
  	1,0,0,0,435,437,3,142,71,0,436,438,3,140,70,0,437,436,1,0,0,0,437,438,
  	1,0,0,0,438,440,1,0,0,0,439,427,1,0,0,0,439,430,1,0,0,0,439,435,1,0,0,
  	0,440,449,1,0,0,0,441,442,10,2,0,0,442,443,5,10,0,0,443,448,3,66,33,3,
  	444,445,10,1,0,0,445,446,5,55,0,0,446,448,3,66,33,2,447,441,1,0,0,0,447,
  	444,1,0,0,0,448,451,1,0,0,0,449,447,1,0,0,0,449,450,1,0,0,0,450,67,1,
  	0,0,0,451,449,1,0,0,0,452,454,3,70,35,0,453,452,1,0,0,0,453,454,1,0,0,
  	0,454,456,1,0,0,0,455,457,3,74,37,0,456,455,1,0,0,0,456,457,1,0,0,0,457,
  	459,1,0,0,0,458,460,3,76,38,0,459,458,1,0,0,0,459,460,1,0,0,0,460,69,
  	1,0,0,0,461,462,5,33,0,0,462,463,5,16,0,0,463,468,3,64,32,0,464,465,5,
  	2,0,0,465,467,3,64,32,0,466,464,1,0,0,0,467,470,1,0,0,0,468,466,1,0,0,
  	0,468,469,1,0,0,0,469,488,1,0,0,0,470,468,1,0,0,0,471,472,5,78,0,0,472,
  	489,5,61,0,0,473,474,5,78,0,0,474,489,5,18,0,0,475,476,5,34,0,0,476,477,
  	5,63,0,0,477,478,5,3,0,0,478,483,3,72,36,0,479,480,5,2,0,0,480,482,3,
  	72,36,0,481,479,1,0,0,0,482,485,1,0,0,0,483,481,1,0,0,0,483,484,1,0,0,
  	0,484,486,1,0,0,0,485,483,1,0,0,0,486,487,5,4,0,0,487,489,1,0,0,0,488,
  	471,1,0,0,0,488,473,1,0,0,0,488,475,1,0,0,0,488,489,1,0,0,0,489,506,1,
  	0,0,0,490,491,5,33,0,0,491,492,5,16,0,0,492,493,5,34,0,0,493,494,5,63,
  	0,0,494,495,5,3,0,0,495,500,3,72,36,0,496,497,5,2,0,0,497,499,3,72,36,
  	0,498,496,1,0,0,0,499,502,1,0,0,0,500,498,1,0,0,0,500,501,1,0,0,0,501,
  	503,1,0,0,0,502,500,1,0,0,0,503,504,5,4,0,0,504,506,1,0,0,0,505,461,1,
  	0,0,0,505,490,1,0,0,0,506,71,1,0,0,0,507,516,5,3,0,0,508,513,3,64,32,
  	0,509,510,5,2,0,0,510,512,3,64,32,0,511,509,1,0,0,0,512,515,1,0,0,0,513,
  	511,1,0,0,0,513,514,1,0,0,0,514,517,1,0,0,0,515,513,1,0,0,0,516,508,1,
  	0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,521,5,4,0,0,519,521,3,64,32,
  	0,520,507,1,0,0,0,520,519,1,0,0,0,521,73,1,0,0,0,522,523,5,77,0,0,523,
  	524,3,80,40,0,524,75,1,0,0,0,525,526,5,92,0,0,526,527,5,3,0,0,527,528,
  	3,78,39,0,528,529,5,4,0,0,529,77,1,0,0,0,530,531,3,48,24,0,531,532,5,
  	2,0,0,532,533,5,130,0,0,533,534,3,90,45,0,534,79,1,0,0,0,535,538,3,82,
  	41,0,536,538,3,84,42,0,537,535,1,0,0,0,537,536,1,0,0,0,538,81,1,0,0,0,
  	539,540,5,79,0,0,540,544,5,3,0,0,541,542,3,92,46,0,542,543,5,2,0,0,543,
  	545,1,0,0,0,544,541,1,0,0,0,544,545,1,0,0,0,545,546,1,0,0,0,546,547,3,
  	86,43,0,547,548,5,4,0,0,548,562,1,0,0,0,549,550,5,80,0,0,550,554,5,3,
  	0,0,551,552,3,92,46,0,552,553,5,2,0,0,553,555,1,0,0,0,554,551,1,0,0,0,
  	554,555,1,0,0,0,555,556,1,0,0,0,556,557,3,86,43,0,557,558,5,2,0,0,558,
  	559,3,88,44,0,559,560,5,4,0,0,560,562,1,0,0,0,561,539,1,0,0,0,561,549,
  	1,0,0,0,562,83,1,0,0,0,563,564,5,79,0,0,564,565,5,3,0,0,565,566,5,130,
  	0,0,566,567,5,4,0,0,567,85,1,0,0,0,568,569,5,81,0,0,569,570,5,130,0,0,
  	570,571,3,90,45,0,571,87,1,0,0,0,572,573,5,82,0,0,573,574,5,16,0,0,574,
  	575,5,130,0,0,575,576,3,90,45,0,576,89,1,0,0,0,577,578,7,0,0,0,578,91,
  	1,0,0,0,579,580,5,136,0,0,580,93,1,0,0,0,581,582,7,1,0,0,582,95,1,0,0,
  	0,583,584,5,40,0,0,584,586,3,98,49,0,585,587,5,12,0,0,586,585,1,0,0,0,
  	586,587,1,0,0,0,587,97,1,0,0,0,588,595,3,104,52,0,589,595,3,116,58,0,
  	590,595,3,126,63,0,591,595,3,130,65,0,592,595,3,134,67,0,593,595,3,136,
  	68,0,594,588,1,0,0,0,594,589,1,0,0,0,594,590,1,0,0,0,594,591,1,0,0,0,
  	594,592,1,0,0,0,594,593,1,0,0,0,595,99,1,0,0,0,596,597,3,102,51,0,597,
  	598,5,3,0,0,598,599,5,126,0,0,599,600,5,4,0,0,600,101,1,0,0,0,601,602,
  	5,94,0,0,602,103,1,0,0,0,603,604,3,108,54,0,604,605,5,3,0,0,605,606,3,
  	110,55,0,606,607,5,2,0,0,607,608,3,112,56,0,608,609,5,2,0,0,609,610,3,
  	114,57,0,610,611,5,4,0,0,611,105,1,0,0,0,612,614,5,50,0,0,613,612,1,0,
  	0,0,613,614,1,0,0,0,614,615,1,0,0,0,615,616,5,51,0,0,616,107,1,0,0,0,
  	617,618,5,95,0,0,618,109,1,0,0,0,619,620,5,136,0,0,620,111,1,0,0,0,621,
  	622,7,2,0,0,622,113,1,0,0,0,623,624,5,130,0,0,624,115,1,0,0,0,625,626,
  	3,118,59,0,626,627,5,3,0,0,627,628,3,120,60,0,628,629,5,2,0,0,629,630,
  	3,122,61,0,630,631,5,2,0,0,631,632,3,124,62,0,632,633,5,4,0,0,633,117,
  	1,0,0,0,634,635,5,96,0,0,635,119,1,0,0,0,636,637,5,136,0,0,637,121,1,
  	0,0,0,638,639,5,136,0,0,639,123,1,0,0,0,640,641,5,130,0,0,641,125,1,0,
  	0,0,642,643,5,97,0,0,643,644,5,3,0,0,644,645,5,126,0,0,645,646,5,2,0,
  	0,646,647,3,128,64,0,647,648,5,2,0,0,648,649,5,126,0,0,649,650,5,4,0,
  	0,650,127,1,0,0,0,651,652,7,3,0,0,652,129,1,0,0,0,653,654,5,98,0,0,654,
  	655,5,3,0,0,655,656,5,126,0,0,656,657,5,2,0,0,657,658,5,126,0,0,658,659,
  	5,2,0,0,659,660,5,126,0,0,660,661,5,2,0,0,661,662,5,130,0,0,662,663,5,
  	2,0,0,663,664,3,90,45,0,664,665,5,2,0,0,665,666,5,130,0,0,666,667,5,2,
  	0,0,667,668,3,132,66,0,668,669,5,2,0,0,669,670,5,107,0,0,670,671,5,4,
  	0,0,671,131,1,0,0,0,672,673,7,4,0,0,673,133,1,0,0,0,674,675,5,99,0,0,
  	675,676,5,3,0,0,676,677,5,126,0,0,677,678,5,2,0,0,678,679,5,126,0,0,679,
  	680,5,2,0,0,680,681,5,126,0,0,681,682,5,2,0,0,682,683,5,126,0,0,683,684,
  	5,4,0,0,684,135,1,0,0,0,685,686,5,100,0,0,686,137,1,0,0,0,687,689,3,64,
  	32,0,688,690,7,5,0,0,689,688,1,0,0,0,689,690,1,0,0,0,690,693,1,0,0,0,
  	691,692,5,52,0,0,692,694,7,6,0,0,693,691,1,0,0,0,693,694,1,0,0,0,694,
  	139,1,0,0,0,695,697,5,50,0,0,696,695,1,0,0,0,696,697,1,0,0,0,697,698,
  	1,0,0,0,698,699,5,15,0,0,699,700,3,142,71,0,700,701,5,10,0,0,701,702,
  	3,142,71,0,702,775,1,0,0,0,703,705,5,50,0,0,704,703,1,0,0,0,704,705,1,
  	0,0,0,705,706,1,0,0,0,706,707,5,37,0,0,707,708,5,3,0,0,708,713,3,64,32,
  	0,709,710,5,2,0,0,710,712,3,64,32,0,711,709,1,0,0,0,712,715,1,0,0,0,713,
  	711,1,0,0,0,713,714,1,0,0,0,714,716,1,0,0,0,715,713,1,0,0,0,716,717,5,
  	4,0,0,717,775,1,0,0,0,718,720,5,50,0,0,719,718,1,0,0,0,719,720,1,0,0,
  	0,720,721,1,0,0,0,721,722,5,37,0,0,722,723,5,3,0,0,723,724,3,4,2,0,724,
  	725,5,4,0,0,725,775,1,0,0,0,726,728,5,50,0,0,727,726,1,0,0,0,727,728,
  	1,0,0,0,728,729,1,0,0,0,729,730,5,60,0,0,730,775,3,142,71,0,731,733,5,
  	50,0,0,732,731,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,735,5,45,0,
  	0,735,749,7,7,0,0,736,737,5,3,0,0,737,750,5,4,0,0,738,739,5,3,0,0,739,
  	744,3,64,32,0,740,741,5,2,0,0,741,743,3,64,32,0,742,740,1,0,0,0,743,746,
  	1,0,0,0,744,742,1,0,0,0,744,745,1,0,0,0,745,747,1,0,0,0,746,744,1,0,0,
  	0,747,748,5,4,0,0,748,750,1,0,0,0,749,736,1,0,0,0,749,738,1,0,0,0,750,
  	775,1,0,0,0,751,753,5,50,0,0,752,751,1,0,0,0,752,753,1,0,0,0,753,754,
  	1,0,0,0,754,755,5,45,0,0,755,758,3,142,71,0,756,757,5,26,0,0,757,759,
  	5,126,0,0,758,756,1,0,0,0,758,759,1,0,0,0,759,775,1,0,0,0,760,761,5,41,
  	0,0,761,775,3,106,53,0,762,764,5,41,0,0,763,765,5,50,0,0,764,763,1,0,
  	0,0,764,765,1,0,0,0,765,766,1,0,0,0,766,775,7,8,0,0,767,769,5,41,0,0,
  	768,770,5,50,0,0,769,768,1,0,0,0,769,770,1,0,0,0,770,771,1,0,0,0,771,
  	772,5,21,0,0,772,773,5,31,0,0,773,775,3,142,71,0,774,696,1,0,0,0,774,
  	704,1,0,0,0,774,719,1,0,0,0,774,727,1,0,0,0,774,732,1,0,0,0,774,752,1,
  	0,0,0,774,760,1,0,0,0,774,762,1,0,0,0,774,767,1,0,0,0,775,141,1,0,0,0,
  	776,777,6,71,-1,0,777,781,3,150,75,0,778,779,7,9,0,0,779,781,3,142,71,
  	7,780,776,1,0,0,0,780,778,1,0,0,0,781,803,1,0,0,0,782,783,10,6,0,0,783,
  	784,7,10,0,0,784,802,3,142,71,7,785,786,10,5,0,0,786,787,7,11,0,0,787,
  	802,3,142,71,6,788,789,10,4,0,0,789,790,5,122,0,0,790,802,3,142,71,5,
  	791,792,10,3,0,0,792,793,5,125,0,0,793,802,3,142,71,4,794,795,10,2,0,
  	0,795,796,5,123,0,0,796,802,3,142,71,3,797,798,10,1,0,0,798,799,3,144,
  	72,0,799,800,3,142,71,2,800,802,1,0,0,0,801,782,1,0,0,0,801,785,1,0,0,
  	0,801,788,1,0,0,0,801,791,1,0,0,0,801,794,1,0,0,0,801,797,1,0,0,0,802,
  	805,1,0,0,0,803,801,1,0,0,0,803,804,1,0,0,0,804,143,1,0,0,0,805,803,1,
  	0,0,0,806,807,7,12,0,0,807,145,1,0,0,0,808,809,5,6,0,0,809,816,3,148,
  	74,0,810,812,5,2,0,0,811,810,1,0,0,0,811,812,1,0,0,0,812,813,1,0,0,0,
  	813,815,3,148,74,0,814,811,1,0,0,0,815,818,1,0,0,0,816,814,1,0,0,0,816,
  	817,1,0,0,0,817,819,1,0,0,0,818,816,1,0,0,0,819,820,5,7,0,0,820,147,1,
  	0,0,0,821,835,3,48,24,0,822,823,3,48,24,0,823,824,5,3,0,0,824,829,3,150,
  	75,0,825,826,5,2,0,0,826,828,3,150,75,0,827,825,1,0,0,0,828,831,1,0,0,
  	0,829,827,1,0,0,0,829,830,1,0,0,0,830,832,1,0,0,0,831,829,1,0,0,0,832,
  	833,5,4,0,0,833,835,1,0,0,0,834,821,1,0,0,0,834,822,1,0,0,0,835,149,1,
  	0,0,0,836,837,6,75,-1,0,837,877,5,118,0,0,838,839,3,152,76,0,839,840,
  	5,5,0,0,840,841,5,118,0,0,841,877,1,0,0,0,842,843,5,3,0,0,843,844,3,4,
  	2,0,844,845,5,4,0,0,845,877,1,0,0,0,846,847,5,3,0,0,847,850,3,46,23,0,
  	848,849,5,2,0,0,849,851,3,46,23,0,850,848,1,0,0,0,851,852,1,0,0,0,852,
  	850,1,0,0,0,852,853,1,0,0,0,853,854,1,0,0,0,854,855,5,4,0,0,855,877,1,
  	0,0,0,856,857,3,94,47,0,857,866,5,3,0,0,858,863,3,64,32,0,859,860,5,2,
  	0,0,860,862,3,64,32,0,861,859,1,0,0,0,862,865,1,0,0,0,863,861,1,0,0,0,
  	863,864,1,0,0,0,864,867,1,0,0,0,865,863,1,0,0,0,866,858,1,0,0,0,866,867,
  	1,0,0,0,867,868,1,0,0,0,868,869,5,4,0,0,869,877,1,0,0,0,870,871,5,3,0,
  	0,871,872,3,64,32,0,872,873,5,4,0,0,873,877,1,0,0,0,874,877,3,156,78,
  	0,875,877,3,48,24,0,876,836,1,0,0,0,876,838,1,0,0,0,876,842,1,0,0,0,876,
  	846,1,0,0,0,876,856,1,0,0,0,876,870,1,0,0,0,876,874,1,0,0,0,876,875,1,
  	0,0,0,877,883,1,0,0,0,878,879,10,7,0,0,879,880,5,5,0,0,880,882,3,48,24,
  	0,881,878,1,0,0,0,882,885,1,0,0,0,883,881,1,0,0,0,883,884,1,0,0,0,884,
  	151,1,0,0,0,885,883,1,0,0,0,886,891,3,48,24,0,887,888,5,5,0,0,888,890,
  	3,48,24,0,889,887,1,0,0,0,890,893,1,0,0,0,891,889,1,0,0,0,891,892,1,0,
  	0,0,892,153,1,0,0,0,893,891,1,0,0,0,894,896,4,77,13,0,895,897,5,117,0,
  	0,896,895,1,0,0,0,896,897,1,0,0,0,897,898,1,0,0,0,898,938,5,131,0,0,899,
  	901,4,77,14,0,900,902,5,117,0,0,901,900,1,0,0,0,901,902,1,0,0,0,902,903,
  	1,0,0,0,903,938,5,132,0,0,904,906,4,77,15,0,905,907,5,117,0,0,906,905,
  	1,0,0,0,906,907,1,0,0,0,907,908,1,0,0,0,908,938,7,13,0,0,909,911,5,117,
  	0,0,910,909,1,0,0,0,910,911,1,0,0,0,911,912,1,0,0,0,912,938,5,130,0,0,
  	913,915,5,117,0,0,914,913,1,0,0,0,914,915,1,0,0,0,915,916,1,0,0,0,916,
  	938,5,127,0,0,917,919,5,117,0,0,918,917,1,0,0,0,918,919,1,0,0,0,919,920,
  	1,0,0,0,920,938,5,128,0,0,921,923,5,117,0,0,922,921,1,0,0,0,922,923,1,
  	0,0,0,923,924,1,0,0,0,924,938,5,129,0,0,925,927,5,117,0,0,926,925,1,0,
  	0,0,926,927,1,0,0,0,927,928,1,0,0,0,928,938,5,134,0,0,929,931,5,117,0,
  	0,930,929,1,0,0,0,930,931,1,0,0,0,931,932,1,0,0,0,932,938,5,133,0,0,933,
  	935,5,117,0,0,934,933,1,0,0,0,934,935,1,0,0,0,935,936,1,0,0,0,936,938,
  	5,135,0,0,937,894,1,0,0,0,937,899,1,0,0,0,937,904,1,0,0,0,937,910,1,0,
  	0,0,937,914,1,0,0,0,937,918,1,0,0,0,937,922,1,0,0,0,937,926,1,0,0,0,937,
  	930,1,0,0,0,937,934,1,0,0,0,938,155,1,0,0,0,939,951,5,51,0,0,940,941,
  	3,48,24,0,941,942,5,126,0,0,942,951,1,0,0,0,943,951,3,154,77,0,944,951,
  	3,158,79,0,945,947,5,126,0,0,946,945,1,0,0,0,947,948,1,0,0,0,948,946,
  	1,0,0,0,948,949,1,0,0,0,949,951,1,0,0,0,950,939,1,0,0,0,950,940,1,0,0,
  	0,950,943,1,0,0,0,950,944,1,0,0,0,950,946,1,0,0,0,951,157,1,0,0,0,952,
  	953,7,14,0,0,953,159,1,0,0,0,954,955,7,15,0,0,955,161,1,0,0,0,956,957,
  	7,16,0,0,957,163,1,0,0,0,958,959,7,17,0,0,959,165,1,0,0,0,101,170,187,
  	190,195,197,201,211,223,228,232,235,243,250,257,264,267,287,296,299,308,
  	312,315,321,338,344,348,350,357,365,370,374,376,381,389,402,412,415,422,
  	437,439,447,449,453,456,459,468,483,488,500,505,513,516,520,537,544,554,
  	561,586,594,613,689,693,696,704,713,719,727,732,744,749,752,758,764,769,
  	774,780,801,803,811,816,829,834,852,863,866,876,883,891,896,901,906,910,
  	914,918,922,926,930,934,937,948,950
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  nebulasqlParserStaticData = staticData.release();
}

}

NebulaSQLParser::NebulaSQLParser(TokenStream *input) : NebulaSQLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

NebulaSQLParser::NebulaSQLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  NebulaSQLParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *nebulasqlParserStaticData->atn, nebulasqlParserStaticData->decisionToDFA, nebulasqlParserStaticData->sharedContextCache, options);
}

NebulaSQLParser::~NebulaSQLParser() {
  delete _interpreter;
}

const atn::ATN& NebulaSQLParser::getATN() const {
  return *nebulasqlParserStaticData->atn;
}

std::string NebulaSQLParser::getGrammarFileName() const {
  return "NebulaSQL.g4";
}

const std::vector<std::string>& NebulaSQLParser::getRuleNames() const {
  return nebulasqlParserStaticData->ruleNames;
}

const dfa::Vocabulary& NebulaSQLParser::getVocabulary() const {
  return nebulasqlParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NebulaSQLParser::getSerializedATN() const {
  return nebulasqlParserStaticData->serializedATN;
}


//----------------- SingleStatementContext ------------------------------------------------------------------

NebulaSQLParser::SingleStatementContext::SingleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StatementContext* NebulaSQLParser::SingleStatementContext::statement() {
  return getRuleContext<NebulaSQLParser::StatementContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SingleStatementContext::EOF() {
  return getToken(NebulaSQLParser::EOF, 0);
}


size_t NebulaSQLParser::SingleStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSingleStatement;
}

void NebulaSQLParser::SingleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleStatement(this);
}

void NebulaSQLParser::SingleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleStatement(this);
}

NebulaSQLParser::SingleStatementContext* NebulaSQLParser::singleStatement() {
  SingleStatementContext *_localctx = _tracker.createInstance<SingleStatementContext>(_ctx, getState());
  enterRule(_localctx, 0, NebulaSQLParser::RuleSingleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(166);
    statement();
    setState(170);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__0) {
      setState(167);
      match(NebulaSQLParser::T__0);
      setState(172);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(173);
    match(NebulaSQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NebulaSQLParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::QueryContext* NebulaSQLParser::StatementContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}


size_t NebulaSQLParser::StatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStatement;
}

void NebulaSQLParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void NebulaSQLParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

NebulaSQLParser::StatementContext* NebulaSQLParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 2, NebulaSQLParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(175);
    query();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::QueryContext::queryTerm() {
  return getRuleContext<NebulaSQLParser::QueryTermContext>(0);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::QueryContext::queryOrganization() {
  return getRuleContext<NebulaSQLParser::QueryOrganizationContext>(0);
}


size_t NebulaSQLParser::QueryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuery;
}

void NebulaSQLParser::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void NebulaSQLParser::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 4, NebulaSQLParser::RuleQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(177);
    queryTerm(0);
    setState(178);
    queryOrganization();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryOrganizationContext ------------------------------------------------------------------

NebulaSQLParser::QueryOrganizationContext::QueryOrganizationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ORDER() {
  return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::OFFSET() {
  return getToken(NebulaSQLParser::OFFSET, 0);
}

std::vector<NebulaSQLParser::SortItemContext *> NebulaSQLParser::QueryOrganizationContext::sortItem() {
  return getRuleContexts<NebulaSQLParser::SortItemContext>();
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::QueryOrganizationContext::sortItem(size_t i) {
  return getRuleContext<NebulaSQLParser::SortItemContext>(i);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE() {
  return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE(size_t i) {
  return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}


size_t NebulaSQLParser::QueryOrganizationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryOrganization;
}

void NebulaSQLParser::QueryOrganizationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryOrganization(this);
}

void NebulaSQLParser::QueryOrganizationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryOrganization(this);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::queryOrganization() {
  QueryOrganizationContext *_localctx = _tracker.createInstance<QueryOrganizationContext>(_ctx, getState());
  enterRule(_localctx, 6, NebulaSQLParser::RuleQueryOrganization);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(190);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::ORDER) {
      setState(180);
      match(NebulaSQLParser::ORDER);
      setState(181);
      match(NebulaSQLParser::BY);
      setState(182);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
      setState(187);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(183);
        match(NebulaSQLParser::T__1);
        setState(184);
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
        setState(189);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(197);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::LIMIT) {
      setState(192);
      match(NebulaSQLParser::LIMIT);
      setState(195);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NebulaSQLParser::ALL: {
          setState(193);
          match(NebulaSQLParser::ALL);
          break;
        }

        case NebulaSQLParser::INTEGER_VALUE: {
          setState(194);
          antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->limit = match(NebulaSQLParser::INTEGER_VALUE);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(201);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::OFFSET) {
      setState(199);
      match(NebulaSQLParser::OFFSET);
      setState(200);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->offset = match(NebulaSQLParser::INTEGER_VALUE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryTermContext ------------------------------------------------------------------

NebulaSQLParser::QueryTermContext::QueryTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::QueryTermContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryTerm;
}

void NebulaSQLParser::QueryTermContext::copyFrom(QueryTermContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::PrimaryQueryContext::queryPrimary() {
  return getRuleContext<NebulaSQLParser::QueryPrimaryContext>(0);
}

NebulaSQLParser::PrimaryQueryContext::PrimaryQueryContext(QueryTermContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::PrimaryQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryQuery(this);
}
void NebulaSQLParser::PrimaryQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryQuery(this);
}
//----------------- SetOperationContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::QueryTermContext *> NebulaSQLParser::SetOperationContext::queryTerm() {
  return getRuleContexts<NebulaSQLParser::QueryTermContext>();
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::SetOperationContext::queryTerm(size_t i) {
  return getRuleContext<NebulaSQLParser::QueryTermContext>(i);
}

tree::TerminalNode* NebulaSQLParser::SetOperationContext::UNION() {
  return getToken(NebulaSQLParser::UNION, 0);
}

NebulaSQLParser::SetOperationContext::SetOperationContext(QueryTermContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SetOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetOperation(this);
}
void NebulaSQLParser::SetOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetOperation(this);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm() {
   return queryTerm(0);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::QueryTermContext *_localctx = _tracker.createInstance<QueryTermContext>(_ctx, parentState);
  NebulaSQLParser::QueryTermContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 8;
  enterRecursionRule(_localctx, 8, NebulaSQLParser::RuleQueryTerm, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryQueryContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(204);
    queryPrimary();
    _ctx->stop = _input->LT(-1);
    setState(211);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<SetOperationContext>(_tracker.createInstance<QueryTermContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->left = previousContext;
        pushNewRecursionContext(newContext, startState, RuleQueryTerm);
        setState(206);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(207);
        antlrcpp::downCast<SetOperationContext *>(_localctx)->setoperator = match(NebulaSQLParser::UNION);
        setState(208);
        antlrcpp::downCast<SetOperationContext *>(_localctx)->right = queryTerm(2); 
      }
      setState(213);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::QueryPrimaryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryPrimary;
}

void NebulaSQLParser::QueryPrimaryContext::copyFrom(QueryPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryContext::SubqueryContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}
void NebulaSQLParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}
//----------------- QueryPrimaryDefaultContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::QueryPrimaryDefaultContext::querySpecification() {
  return getRuleContext<NebulaSQLParser::QuerySpecificationContext>(0);
}

NebulaSQLParser::QueryPrimaryDefaultContext::QueryPrimaryDefaultContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::QueryPrimaryDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimaryDefault(this);
}
void NebulaSQLParser::QueryPrimaryDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimaryDefault(this);
}
//----------------- InlineTableDefault1Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault1Context::inlineTable() {
  return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault1Context::InlineTableDefault1Context(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::InlineTableDefault1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTableDefault1(this);
}
void NebulaSQLParser::InlineTableDefault1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTableDefault1(this);
}
//----------------- FromStmtContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext* NebulaSQLParser::FromStmtContext::fromStatement() {
  return getRuleContext<NebulaSQLParser::FromStatementContext>(0);
}

NebulaSQLParser::FromStmtContext::FromStmtContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FromStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStmt(this);
}
void NebulaSQLParser::FromStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStmt(this);
}
//----------------- TableContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TableContext::TABLE() {
  return getToken(NebulaSQLParser::TABLE, 0);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableContext::multipartIdentifier() {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableContext::TableContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable(this);
}
void NebulaSQLParser::TableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable(this);
}
NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::queryPrimary() {
  QueryPrimaryContext *_localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 10, NebulaSQLParser::RuleQueryPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(223);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::SELECT: {
        _localctx = _tracker.createInstance<NebulaSQLParser::QueryPrimaryDefaultContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(214);
        querySpecification();
        break;
      }

      case NebulaSQLParser::FROM: {
        _localctx = _tracker.createInstance<NebulaSQLParser::FromStmtContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(215);
        fromStatement();
        break;
      }

      case NebulaSQLParser::TABLE: {
        _localctx = _tracker.createInstance<NebulaSQLParser::TableContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(216);
        match(NebulaSQLParser::TABLE);
        setState(217);
        multipartIdentifier();
        break;
      }

      case NebulaSQLParser::VALUES: {
        _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault1Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(218);
        inlineTable();
        break;
      }

      case NebulaSQLParser::T__2: {
        _localctx = _tracker.createInstance<NebulaSQLParser::SubqueryContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(219);
        match(NebulaSQLParser::T__2);
        setState(220);
        query();
        setState(221);
        match(NebulaSQLParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::QuerySpecificationContext::selectClause() {
  return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::QuerySpecificationContext::sinkClause() {
  return getRuleContext<NebulaSQLParser::SinkClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::QuerySpecificationContext::windowedAggregationClause() {
  return getRuleContext<NebulaSQLParser::WindowedAggregationClauseContext>(0);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<NebulaSQLParser::HavingClauseContext>(0);
}


size_t NebulaSQLParser::QuerySpecificationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuerySpecification;
}

void NebulaSQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void NebulaSQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 12, NebulaSQLParser::RuleQuerySpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(225);
    selectClause();
    setState(226);
    fromClause();
    setState(228);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::WHERE) {
      setState(227);
      whereClause();
    }
    setState(230);
    sinkClause();
    setState(232);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(231);
      windowedAggregationClause();
      break;
    }

    default:
      break;
    }
    setState(235);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      setState(234);
      havingClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

NebulaSQLParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FromClauseContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

std::vector<NebulaSQLParser::RelationContext *> NebulaSQLParser::FromClauseContext::relation() {
  return getRuleContexts<NebulaSQLParser::RelationContext>();
}

NebulaSQLParser::RelationContext* NebulaSQLParser::FromClauseContext::relation(size_t i) {
  return getRuleContext<NebulaSQLParser::RelationContext>(i);
}


size_t NebulaSQLParser::FromClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromClause;
}

void NebulaSQLParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void NebulaSQLParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 14, NebulaSQLParser::RuleFromClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(237);
    match(NebulaSQLParser::FROM);
    setState(238);
    relation();
    setState(243);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(239);
      match(NebulaSQLParser::T__1);
      setState(240);
      relation();
      setState(245);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::RelationContext::relationPrimary() {
  return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

std::vector<NebulaSQLParser::JoinRelationContext *> NebulaSQLParser::RelationContext::joinRelation() {
  return getRuleContexts<NebulaSQLParser::JoinRelationContext>();
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::RelationContext::joinRelation(size_t i) {
  return getRuleContext<NebulaSQLParser::JoinRelationContext>(i);
}


size_t NebulaSQLParser::RelationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleRelation;
}

void NebulaSQLParser::RelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelation(this);
}

void NebulaSQLParser::RelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelation(this);
}

NebulaSQLParser::RelationContext* NebulaSQLParser::relation() {
  RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
  enterRule(_localctx, 16, NebulaSQLParser::RuleRelation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(246);
    relationPrimary();
    setState(250);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 567622877839360) != 0)) {
      setState(247);
      joinRelation();
      setState(252);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinRelationContext ------------------------------------------------------------------

NebulaSQLParser::JoinRelationContext::JoinRelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::JOIN() {
  return getToken(NebulaSQLParser::JOIN, 0);
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::JoinRelationContext::relationPrimary() {
  return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::JoinRelationContext::joinType() {
  return getRuleContext<NebulaSQLParser::JoinTypeContext>(0);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::JoinRelationContext::joinCriteria() {
  return getRuleContext<NebulaSQLParser::JoinCriteriaContext>(0);
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::NATURAL() {
  return getToken(NebulaSQLParser::NATURAL, 0);
}


size_t NebulaSQLParser::JoinRelationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinRelation;
}

void NebulaSQLParser::JoinRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinRelation(this);
}

void NebulaSQLParser::JoinRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinRelation(this);
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::joinRelation() {
  JoinRelationContext *_localctx = _tracker.createInstance<JoinRelationContext>(_ctx, getState());
  enterRule(_localctx, 18, NebulaSQLParser::RuleJoinRelation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(264);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::INNER:
      case NebulaSQLParser::JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(253);
        joinType();
        setState(254);
        match(NebulaSQLParser::JOIN);
        setState(255);
        antlrcpp::downCast<JoinRelationContext *>(_localctx)->right = relationPrimary();
        setState(257);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::ON) {
          setState(256);
          joinCriteria();
        }
        break;
      }

      case NebulaSQLParser::NATURAL: {
        enterOuterAlt(_localctx, 2);
        setState(259);
        match(NebulaSQLParser::NATURAL);
        setState(260);
        joinType();
        setState(261);
        match(NebulaSQLParser::JOIN);
        setState(262);
        antlrcpp::downCast<JoinRelationContext *>(_localctx)->right = relationPrimary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinTypeContext ------------------------------------------------------------------

NebulaSQLParser::JoinTypeContext::JoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinTypeContext::INNER() {
  return getToken(NebulaSQLParser::INNER, 0);
}


size_t NebulaSQLParser::JoinTypeContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinType;
}

void NebulaSQLParser::JoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinType(this);
}

void NebulaSQLParser::JoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinType(this);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::joinType() {
  JoinTypeContext *_localctx = _tracker.createInstance<JoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 20, NebulaSQLParser::RuleJoinType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(267);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::INNER) {
      setState(266);
      match(NebulaSQLParser::INNER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinCriteriaContext ------------------------------------------------------------------

NebulaSQLParser::JoinCriteriaContext::JoinCriteriaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinCriteriaContext::ON() {
  return getToken(NebulaSQLParser::ON, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::JoinCriteriaContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::JoinCriteriaContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinCriteria;
}

void NebulaSQLParser::JoinCriteriaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinCriteria(this);
}

void NebulaSQLParser::JoinCriteriaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinCriteria(this);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::joinCriteria() {
  JoinCriteriaContext *_localctx = _tracker.createInstance<JoinCriteriaContext>(_ctx, getState());
  enterRule(_localctx, 22, NebulaSQLParser::RuleJoinCriteria);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(269);
    match(NebulaSQLParser::ON);
    setState(270);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::RelationPrimaryContext::RelationPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::RelationPrimaryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleRelationPrimary;
}

void NebulaSQLParser::RelationPrimaryContext::copyFrom(RelationPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TableValuedFunctionContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::TableValuedFunctionContext::functionTable() {
  return getRuleContext<NebulaSQLParser::FunctionTableContext>(0);
}

NebulaSQLParser::TableValuedFunctionContext::TableValuedFunctionContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableValuedFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableValuedFunction(this);
}
void NebulaSQLParser::TableValuedFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableValuedFunction(this);
}
//----------------- InlineTableDefault2Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault2Context::inlineTable() {
  return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault2Context::InlineTableDefault2Context(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::InlineTableDefault2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTableDefault2(this);
}
void NebulaSQLParser::InlineTableDefault2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTableDefault2(this);
}
//----------------- AliasedRelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext* NebulaSQLParser::AliasedRelationContext::relation() {
  return getRuleContext<NebulaSQLParser::RelationContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedRelationContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedRelationContext::AliasedRelationContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::AliasedRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasedRelation(this);
}
void NebulaSQLParser::AliasedRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasedRelation(this);
}
//----------------- AliasedQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::AliasedQueryContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedQueryContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedQueryContext::AliasedQueryContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::AliasedQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasedQuery(this);
}
void NebulaSQLParser::AliasedQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasedQuery(this);
}
//----------------- TableNameContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableNameContext::multipartIdentifier() {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::TableNameContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::TableNameContext::TableNameContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}
void NebulaSQLParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}
NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::relationPrimary() {
  RelationPrimaryContext *_localctx = _tracker.createInstance<RelationPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 24, NebulaSQLParser::RuleRelationPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(287);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TableNameContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(272);
      multipartIdentifier();
      setState(273);
      tableAlias();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::AliasedQueryContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(275);
      match(NebulaSQLParser::T__2);
      setState(276);
      query();
      setState(277);
      match(NebulaSQLParser::T__3);
      setState(278);
      tableAlias();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::AliasedRelationContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(280);
      match(NebulaSQLParser::T__2);
      setState(281);
      relation();
      setState(282);
      match(NebulaSQLParser::T__3);
      setState(283);
      tableAlias();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault2Context>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(285);
      inlineTable();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TableValuedFunctionContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(286);
      functionTable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTableContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext::FunctionTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::FunctionTableContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::FunctionTableContext::errorCapturingIdentifier() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::FunctionTableContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionTableContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::FunctionTableContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFunctionTable;
}

void NebulaSQLParser::FunctionTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTable(this);
}

void NebulaSQLParser::FunctionTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTable(this);
}

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::functionTable() {
  FunctionTableContext *_localctx = _tracker.createInstance<FunctionTableContext>(_ctx, getState());
  enterRule(_localctx, 26, NebulaSQLParser::RuleFunctionTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(289);
    antlrcpp::downCast<FunctionTableContext *>(_localctx)->funcName = errorCapturingIdentifier();
    setState(290);
    match(NebulaSQLParser::T__2);
    setState(299);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(291);
      expression();
      setState(296);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(292);
        match(NebulaSQLParser::T__1);
        setState(293);
        expression();
        setState(298);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(301);
    match(NebulaSQLParser::T__3);
    setState(302);
    tableAlias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromStatementContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext::FromStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::FromStatementContext::fromClause() {
  return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

std::vector<NebulaSQLParser::FromStatementBodyContext *> NebulaSQLParser::FromStatementContext::fromStatementBody() {
  return getRuleContexts<NebulaSQLParser::FromStatementBodyContext>();
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::FromStatementContext::fromStatementBody(size_t i) {
  return getRuleContext<NebulaSQLParser::FromStatementBodyContext>(i);
}


size_t NebulaSQLParser::FromStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromStatement;
}

void NebulaSQLParser::FromStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStatement(this);
}

void NebulaSQLParser::FromStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStatement(this);
}

NebulaSQLParser::FromStatementContext* NebulaSQLParser::fromStatement() {
  FromStatementContext *_localctx = _tracker.createInstance<FromStatementContext>(_ctx, getState());
  enterRule(_localctx, 28, NebulaSQLParser::RuleFromStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(304);
    fromClause();
    setState(306); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(305);
              fromStatementBody();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(308); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromStatementBodyContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementBodyContext::FromStatementBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::FromStatementBodyContext::selectClause() {
  return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::FromStatementBodyContext::whereClause() {
  return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::FromStatementBodyContext::aggregationClause() {
  return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}


size_t NebulaSQLParser::FromStatementBodyContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromStatementBody;
}

void NebulaSQLParser::FromStatementBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStatementBody(this);
}

void NebulaSQLParser::FromStatementBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStatementBody(this);
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::fromStatementBody() {
  FromStatementBodyContext *_localctx = _tracker.createInstance<FromStatementBodyContext>(_ctx, getState());
  enterRule(_localctx, 30, NebulaSQLParser::RuleFromStatementBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(310);
    selectClause();
    setState(312);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      setState(311);
      whereClause();
      break;
    }

    default:
      break;
    }
    setState(315);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(314);
      aggregationClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectClauseContext ------------------------------------------------------------------

NebulaSQLParser::SelectClauseContext::SelectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SelectClauseContext::SELECT() {
  return getToken(NebulaSQLParser::SELECT, 0);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::SelectClauseContext::namedExpressionSeq() {
  return getRuleContext<NebulaSQLParser::NamedExpressionSeqContext>(0);
}

std::vector<NebulaSQLParser::HintContext *> NebulaSQLParser::SelectClauseContext::hint() {
  return getRuleContexts<NebulaSQLParser::HintContext>();
}

NebulaSQLParser::HintContext* NebulaSQLParser::SelectClauseContext::hint(size_t i) {
  return getRuleContext<NebulaSQLParser::HintContext>(i);
}


size_t NebulaSQLParser::SelectClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSelectClause;
}

void NebulaSQLParser::SelectClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectClause(this);
}

void NebulaSQLParser::SelectClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectClause(this);
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::selectClause() {
  SelectClauseContext *_localctx = _tracker.createInstance<SelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 32, NebulaSQLParser::RuleSelectClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(317);
    match(NebulaSQLParser::SELECT);
    setState(321);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(318);
        antlrcpp::downCast<SelectClauseContext *>(_localctx)->hintContext = hint();
        antlrcpp::downCast<SelectClauseContext *>(_localctx)->hints.push_back(antlrcpp::downCast<SelectClauseContext *>(_localctx)->hintContext); 
      }
      setState(323);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx);
    }
    setState(324);
    namedExpressionSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

NebulaSQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WhereClauseContext::WHERE() {
  return getToken(NebulaSQLParser::WHERE, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::WhereClauseContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::WhereClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWhereClause;
}

void NebulaSQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void NebulaSQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 34, NebulaSQLParser::RuleWhereClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(326);
    match(NebulaSQLParser::WHERE);
    setState(327);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

NebulaSQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::HavingClauseContext::HAVING() {
  return getToken(NebulaSQLParser::HAVING, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::HavingClauseContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::HavingClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHavingClause;
}

void NebulaSQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void NebulaSQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 36, NebulaSQLParser::RuleHavingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(329);
    match(NebulaSQLParser::HAVING);
    setState(330);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineTableContext ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext::InlineTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::InlineTableContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::InlineTableContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::InlineTableContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::InlineTableContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}


size_t NebulaSQLParser::InlineTableContext::getRuleIndex() const {
  return NebulaSQLParser::RuleInlineTable;
}

void NebulaSQLParser::InlineTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTable(this);
}

void NebulaSQLParser::InlineTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTable(this);
}

NebulaSQLParser::InlineTableContext* NebulaSQLParser::inlineTable() {
  InlineTableContext *_localctx = _tracker.createInstance<InlineTableContext>(_ctx, getState());
  enterRule(_localctx, 38, NebulaSQLParser::RuleInlineTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(332);
    match(NebulaSQLParser::VALUES);
    setState(333);
    expression();
    setState(338);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(334);
        match(NebulaSQLParser::T__1);
        setState(335);
        expression(); 
      }
      setState(340);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
    setState(341);
    tableAlias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

NebulaSQLParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::TableAliasContext::strictIdentifier() {
  return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TableAliasContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::TableAliasContext::identifierList() {
  return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}


size_t NebulaSQLParser::TableAliasContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTableAlias;
}

void NebulaSQLParser::TableAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAlias(this);
}

void NebulaSQLParser::TableAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAlias(this);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 40, NebulaSQLParser::RuleTableAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(350);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(344);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
      case 1: {
        setState(343);
        match(NebulaSQLParser::AS);
        break;
      }

      default:
        break;
      }
      setState(346);
      strictIdentifier();
      setState(348);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        setState(347);
        identifierList();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierListContext::MultipartIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::MultipartIdentifierContext *> NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier() {
  return getRuleContexts<NebulaSQLParser::MultipartIdentifierContext>();
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierListContext::getRuleIndex() const {
  return NebulaSQLParser::RuleMultipartIdentifierList;
}

void NebulaSQLParser::MultipartIdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipartIdentifierList(this);
}

void NebulaSQLParser::MultipartIdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipartIdentifierList(this);
}

NebulaSQLParser::MultipartIdentifierListContext* NebulaSQLParser::multipartIdentifierList() {
  MultipartIdentifierListContext *_localctx = _tracker.createInstance<MultipartIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 42, NebulaSQLParser::RuleMultipartIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(352);
    multipartIdentifier();
    setState(357);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(353);
      match(NebulaSQLParser::T__1);
      setState(354);
      multipartIdentifier();
      setState(359);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext::MultipartIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext *> NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier() {
  return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleMultipartIdentifier;
}

void NebulaSQLParser::MultipartIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipartIdentifier(this);
}

void NebulaSQLParser::MultipartIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipartIdentifier(this);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::multipartIdentifier() {
  MultipartIdentifierContext *_localctx = _tracker.createInstance<MultipartIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 44, NebulaSQLParser::RuleMultipartIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(360);
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(365);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(361);
        match(NebulaSQLParser::T__4);
        setState(362);
        antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext); 
      }
      setState(367);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionContext::NamedExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::NamedExpressionContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::NamedExpressionContext::identifierList() {
  return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* NebulaSQLParser::NamedExpressionContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::NamedExpressionContext::errorCapturingIdentifier() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}


size_t NebulaSQLParser::NamedExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNamedExpression;
}

void NebulaSQLParser::NamedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedExpression(this);
}

void NebulaSQLParser::NamedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedExpression(this);
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::namedExpression() {
  NamedExpressionContext *_localctx = _tracker.createInstance<NamedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 46, NebulaSQLParser::RuleNamedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(368);
    expression();
    setState(376);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(370);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        setState(369);
        match(NebulaSQLParser::AS);
        break;
      }

      default:
        break;
      }
      setState(374);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
      case 1: {
        setState(372);
        antlrcpp::downCast<NamedExpressionContext *>(_localctx)->name = errorCapturingIdentifier();
        break;
      }

      case 2: {
        setState(373);
        identifierList();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::IdentifierContext::strictIdentifier() {
  return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::IdentifierContext::strictNonReserved() {
  return getRuleContext<NebulaSQLParser::StrictNonReservedContext>(0);
}


size_t NebulaSQLParser::IdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifier;
}

void NebulaSQLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void NebulaSQLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 48, NebulaSQLParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(381);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(378);
      strictIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(379);

      if (!(!SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
      setState(380);
      strictNonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::StrictIdentifierContext::StrictIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::StrictIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStrictIdentifier;
}

void NebulaSQLParser::StrictIdentifierContext::copyFrom(StrictIdentifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- QuotedIdentifierAlternativeContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::QuotedIdentifierAlternativeContext::quotedIdentifier() {
  return getRuleContext<NebulaSQLParser::QuotedIdentifierContext>(0);
}

NebulaSQLParser::QuotedIdentifierAlternativeContext::QuotedIdentifierAlternativeContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::QuotedIdentifierAlternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedIdentifierAlternative(this);
}
void NebulaSQLParser::QuotedIdentifierAlternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedIdentifierAlternative(this);
}
//----------------- UnquotedIdentifierContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnquotedIdentifierContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::ansiNonReserved() {
  return getRuleContext<NebulaSQLParser::AnsiNonReservedContext>(0);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::nonReserved() {
  return getRuleContext<NebulaSQLParser::NonReservedContext>(0);
}

NebulaSQLParser::UnquotedIdentifierContext::UnquotedIdentifierContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::UnquotedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnquotedIdentifier(this);
}
void NebulaSQLParser::UnquotedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnquotedIdentifier(this);
}
NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::strictIdentifier() {
  StrictIdentifierContext *_localctx = _tracker.createInstance<StrictIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 50, NebulaSQLParser::RuleStrictIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(389);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(383);
      match(NebulaSQLParser::IDENTIFIER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::QuotedIdentifierAlternativeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(384);
      quotedIdentifier();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(385);

      if (!(SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "SQL_standard_keyword_behavior");
      setState(386);
      ansiNonReserved();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(387);

      if (!(!SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
      setState(388);
      nonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuotedIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext::QuotedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QuotedIdentifierContext::BACKQUOTED_IDENTIFIER() {
  return getToken(NebulaSQLParser::BACKQUOTED_IDENTIFIER, 0);
}


size_t NebulaSQLParser::QuotedIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuotedIdentifier;
}

void NebulaSQLParser::QuotedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedIdentifier(this);
}

void NebulaSQLParser::QuotedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedIdentifier(this);
}

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::quotedIdentifier() {
  QuotedIdentifierContext *_localctx = _tracker.createInstance<QuotedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 52, NebulaSQLParser::RuleQuotedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(391);
    match(NebulaSQLParser::BACKQUOTED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::IdentifierListContext::identifierSeq() {
  return getRuleContext<NebulaSQLParser::IdentifierSeqContext>(0);
}


size_t NebulaSQLParser::IdentifierListContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifierList;
}

void NebulaSQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void NebulaSQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 54, NebulaSQLParser::RuleIdentifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(393);
    match(NebulaSQLParser::T__2);
    setState(394);
    identifierSeq();
    setState(395);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierSeqContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierSeqContext::IdentifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext *> NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier() {
  return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::IdentifierSeqContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifierSeq;
}

void NebulaSQLParser::IdentifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierSeq(this);
}

void NebulaSQLParser::IdentifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierSeq(this);
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::identifierSeq() {
  IdentifierSeqContext *_localctx = _tracker.createInstance<IdentifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 56, NebulaSQLParser::RuleIdentifierSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(402);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(398);
      match(NebulaSQLParser::T__1);
      setState(399);
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
      setState(404);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierContext::ErrorCapturingIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorCapturingIdentifierContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::ErrorCapturingIdentifierContext::errorCapturingIdentifierExtra() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierExtraContext>(0);
}


size_t NebulaSQLParser::ErrorCapturingIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleErrorCapturingIdentifier;
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorCapturingIdentifier(this);
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorCapturingIdentifier(this);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::errorCapturingIdentifier() {
  ErrorCapturingIdentifierContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 58, NebulaSQLParser::RuleErrorCapturingIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(405);
    identifier();
    setState(406);
    errorCapturingIdentifierExtra();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierExtraContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierExtraContext::ErrorCapturingIdentifierExtraContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ErrorCapturingIdentifierExtraContext::getRuleIndex() const {
  return NebulaSQLParser::RuleErrorCapturingIdentifierExtra;
}

void NebulaSQLParser::ErrorCapturingIdentifierExtraContext::copyFrom(ErrorCapturingIdentifierExtraContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorIdentContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> NebulaSQLParser::ErrorIdentContext::MINUS() {
  return getTokens(NebulaSQLParser::MINUS);
}

tree::TerminalNode* NebulaSQLParser::ErrorIdentContext::MINUS(size_t i) {
  return getToken(NebulaSQLParser::MINUS, i);
}

std::vector<NebulaSQLParser::IdentifierContext *> NebulaSQLParser::ErrorIdentContext::identifier() {
  return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorIdentContext::identifier(size_t i) {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}

NebulaSQLParser::ErrorIdentContext::ErrorIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ErrorIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorIdent(this);
}
void NebulaSQLParser::ErrorIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorIdent(this);
}
//----------------- RealIdentContext ------------------------------------------------------------------

NebulaSQLParser::RealIdentContext::RealIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::RealIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealIdent(this);
}
void NebulaSQLParser::RealIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealIdent(this);
}
NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::errorCapturingIdentifierExtra() {
  ErrorCapturingIdentifierExtraContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierExtraContext>(_ctx, getState());
  enterRule(_localctx, 60, NebulaSQLParser::RuleErrorCapturingIdentifierExtra);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(415);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ErrorIdentContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(410); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(408);
                match(NebulaSQLParser::MINUS);
                setState(409);
                identifier();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(412); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::RealIdentContext>(_localctx);
      enterOuterAlt(_localctx, 2);

      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionSeqContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionSeqContext::NamedExpressionSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::NamedExpressionContext *> NebulaSQLParser::NamedExpressionSeqContext::namedExpression() {
  return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::NamedExpressionSeqContext::namedExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}


size_t NebulaSQLParser::NamedExpressionSeqContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNamedExpressionSeq;
}

void NebulaSQLParser::NamedExpressionSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedExpressionSeq(this);
}

void NebulaSQLParser::NamedExpressionSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedExpressionSeq(this);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::namedExpressionSeq() {
  NamedExpressionSeqContext *_localctx = _tracker.createInstance<NamedExpressionSeqContext>(_ctx, getState());
  enterRule(_localctx, 62, NebulaSQLParser::RuleNamedExpressionSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(417);
    namedExpression();
    setState(422);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(418);
        match(NebulaSQLParser::T__1);
        setState(419);
        namedExpression(); 
      }
      setState(424);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::ExpressionContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::ExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleExpression;
}

void NebulaSQLParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void NebulaSQLParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 64, NebulaSQLParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(425);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanExpressionContext ------------------------------------------------------------------

NebulaSQLParser::BooleanExpressionContext::BooleanExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::BooleanExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleBooleanExpression;
}

void NebulaSQLParser::BooleanExpressionContext::copyFrom(BooleanExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- LogicalNotContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LogicalNotContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalNotContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}

NebulaSQLParser::LogicalNotContext::LogicalNotContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LogicalNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalNot(this);
}
void NebulaSQLParser::LogicalNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalNot(this);
}
//----------------- PredicatedContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicatedContext::valueExpression() {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::PredicatedContext::predicate() {
  return getRuleContext<NebulaSQLParser::PredicateContext>(0);
}

NebulaSQLParser::PredicatedContext::PredicatedContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::PredicatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicated(this);
}
void NebulaSQLParser::PredicatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicated(this);
}
//----------------- ExistsContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExistsContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::ExistsContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::ExistsContext::ExistsContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExists(this);
}
void NebulaSQLParser::ExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExists(this);
}
//----------------- LogicalBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::BooleanExpressionContext *> NebulaSQLParser::LogicalBinaryContext::booleanExpression() {
  return getRuleContexts<NebulaSQLParser::BooleanExpressionContext>();
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalBinaryContext::booleanExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::OR() {
  return getToken(NebulaSQLParser::OR, 0);
}

NebulaSQLParser::LogicalBinaryContext::LogicalBinaryContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LogicalBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalBinary(this);
}
void NebulaSQLParser::LogicalBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalBinary(this);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression() {
   return booleanExpression(0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::BooleanExpressionContext *_localctx = _tracker.createInstance<BooleanExpressionContext>(_ctx, parentState);
  NebulaSQLParser::BooleanExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 66;
  enterRecursionRule(_localctx, 66, NebulaSQLParser::RuleBooleanExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(439);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LogicalNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(428);
      match(NebulaSQLParser::NOT);
      setState(429);
      booleanExpression(5);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ExistsContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(430);
      match(NebulaSQLParser::EXISTS);
      setState(431);
      match(NebulaSQLParser::T__2);
      setState(432);
      query();
      setState(433);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<PredicatedContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(435);
      valueExpression(0);
      setState(437);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
      case 1: {
        setState(436);
        predicate();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(449);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(447);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(441);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(442);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->op = match(NebulaSQLParser::AND);
          setState(443);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(3);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(444);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(445);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->op = match(NebulaSQLParser::OR);
          setState(446);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(451);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- WindowedAggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowedAggregationClauseContext::WindowedAggregationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::aggregationClause() {
  return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::windowClause() {
  return getRuleContext<NebulaSQLParser::WindowClauseContext>(0);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::watermarkClause() {
  return getRuleContext<NebulaSQLParser::WatermarkClauseContext>(0);
}


size_t NebulaSQLParser::WindowedAggregationClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowedAggregationClause;
}

void NebulaSQLParser::WindowedAggregationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowedAggregationClause(this);
}

void NebulaSQLParser::WindowedAggregationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowedAggregationClause(this);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::windowedAggregationClause() {
  WindowedAggregationClauseContext *_localctx = _tracker.createInstance<WindowedAggregationClauseContext>(_ctx, getState());
  enterRule(_localctx, 68, NebulaSQLParser::RuleWindowedAggregationClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(453);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      setState(452);
      aggregationClause();
      break;
    }

    default:
      break;
    }
    setState(456);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(455);
      windowClause();
      break;
    }

    default:
      break;
    }
    setState(459);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(458);
      watermarkClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::AggregationClauseContext::AggregationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUP() {
  return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::AggregationClauseContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::AggregationClauseContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::WITH() {
  return getToken(NebulaSQLParser::WITH, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

std::vector<NebulaSQLParser::GroupingSetContext *> NebulaSQLParser::AggregationClauseContext::groupingSet() {
  return getRuleContexts<NebulaSQLParser::GroupingSetContext>();
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::AggregationClauseContext::groupingSet(size_t i) {
  return getRuleContext<NebulaSQLParser::GroupingSetContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}


size_t NebulaSQLParser::AggregationClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAggregationClause;
}

void NebulaSQLParser::AggregationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregationClause(this);
}

void NebulaSQLParser::AggregationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregationClause(this);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::aggregationClause() {
  AggregationClauseContext *_localctx = _tracker.createInstance<AggregationClauseContext>(_ctx, getState());
  enterRule(_localctx, 70, NebulaSQLParser::RuleAggregationClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(505);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(461);
      match(NebulaSQLParser::GROUP);
      setState(462);
      match(NebulaSQLParser::BY);
      setState(463);
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext = expression();
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->groupingExpressions.push_back(antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext);
      setState(468);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(464);
          match(NebulaSQLParser::T__1);
          setState(465);
          antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<AggregationClauseContext *>(_localctx)->groupingExpressions.push_back(antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext); 
        }
        setState(470);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      }
      setState(488);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
      case 1: {
        setState(471);
        match(NebulaSQLParser::WITH);
        setState(472);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::ROLLUP);
        break;
      }

      case 2: {
        setState(473);
        match(NebulaSQLParser::WITH);
        setState(474);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::CUBE);
        break;
      }

      case 3: {
        setState(475);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
        setState(476);
        match(NebulaSQLParser::SETS);
        setState(477);
        match(NebulaSQLParser::T__2);
        setState(478);
        groupingSet();
        setState(483);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(479);
          match(NebulaSQLParser::T__1);
          setState(480);
          groupingSet();
          setState(485);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(486);
        match(NebulaSQLParser::T__3);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(490);
      match(NebulaSQLParser::GROUP);
      setState(491);
      match(NebulaSQLParser::BY);
      setState(492);
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
      setState(493);
      match(NebulaSQLParser::SETS);
      setState(494);
      match(NebulaSQLParser::T__2);
      setState(495);
      groupingSet();
      setState(500);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(496);
        match(NebulaSQLParser::T__1);
        setState(497);
        groupingSet();
        setState(502);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(503);
      match(NebulaSQLParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingSetContext ------------------------------------------------------------------

NebulaSQLParser::GroupingSetContext::GroupingSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::GroupingSetContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::GroupingSetContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::GroupingSetContext::getRuleIndex() const {
  return NebulaSQLParser::RuleGroupingSet;
}

void NebulaSQLParser::GroupingSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingSet(this);
}

void NebulaSQLParser::GroupingSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingSet(this);
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::groupingSet() {
  GroupingSetContext *_localctx = _tracker.createInstance<GroupingSetContext>(_ctx, getState());
  enterRule(_localctx, 72, NebulaSQLParser::RuleGroupingSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(520);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(507);
      match(NebulaSQLParser::T__2);
      setState(516);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(508);
        expression();
        setState(513);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(509);
          match(NebulaSQLParser::T__1);
          setState(510);
          expression();
          setState(515);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(518);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(519);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WindowClauseContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}

NebulaSQLParser::WindowSpecContext* NebulaSQLParser::WindowClauseContext::windowSpec() {
  return getRuleContext<NebulaSQLParser::WindowSpecContext>(0);
}


size_t NebulaSQLParser::WindowClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowClause;
}

void NebulaSQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void NebulaSQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 74, NebulaSQLParser::RuleWindowClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(522);
    match(NebulaSQLParser::WINDOW);
    setState(523);
    windowSpec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WatermarkClauseContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkClauseContext::WatermarkClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WatermarkClauseContext::WATERMARK() {
  return getToken(NebulaSQLParser::WATERMARK, 0);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::WatermarkClauseContext::watermarkParameters() {
  return getRuleContext<NebulaSQLParser::WatermarkParametersContext>(0);
}


size_t NebulaSQLParser::WatermarkClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWatermarkClause;
}

void NebulaSQLParser::WatermarkClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWatermarkClause(this);
}

void NebulaSQLParser::WatermarkClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWatermarkClause(this);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::watermarkClause() {
  WatermarkClauseContext *_localctx = _tracker.createInstance<WatermarkClauseContext>(_ctx, getState());
  enterRule(_localctx, 76, NebulaSQLParser::RuleWatermarkClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(525);
    match(NebulaSQLParser::WATERMARK);
    setState(526);
    match(NebulaSQLParser::T__2);
    setState(527);
    watermarkParameters();
    setState(528);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WatermarkParametersContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkParametersContext::WatermarkParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::WatermarkParametersContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::WatermarkParametersContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::WatermarkParametersContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::WatermarkParametersContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWatermarkParameters;
}

void NebulaSQLParser::WatermarkParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWatermarkParameters(this);
}

void NebulaSQLParser::WatermarkParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWatermarkParameters(this);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::watermarkParameters() {
  WatermarkParametersContext *_localctx = _tracker.createInstance<WatermarkParametersContext>(_ctx, getState());
  enterRule(_localctx, 78, NebulaSQLParser::RuleWatermarkParameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(530);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermarkIdentifier = identifier();
    setState(531);
    match(NebulaSQLParser::T__1);
    setState(532);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermark = match(NebulaSQLParser::INTEGER_VALUE);
    setState(533);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermarkTimeUnit = timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

NebulaSQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::WindowSpecContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowSpec;
}

void NebulaSQLParser::WindowSpecContext::copyFrom(WindowSpecContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TimeBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext* NebulaSQLParser::TimeBasedWindowContext::timeWindow() {
  return getRuleContext<NebulaSQLParser::TimeWindowContext>(0);
}

NebulaSQLParser::TimeBasedWindowContext::TimeBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TimeBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeBasedWindow(this);
}
void NebulaSQLParser::TimeBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeBasedWindow(this);
}
//----------------- CountBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext* NebulaSQLParser::CountBasedWindowContext::countWindow() {
  return getRuleContext<NebulaSQLParser::CountWindowContext>(0);
}

NebulaSQLParser::CountBasedWindowContext::CountBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::CountBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountBasedWindow(this);
}
void NebulaSQLParser::CountBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountBasedWindow(this);
}
NebulaSQLParser::WindowSpecContext* NebulaSQLParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 80, NebulaSQLParser::RuleWindowSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(537);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TimeBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(535);
      timeWindow();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(536);
      countWindow();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext::TimeWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::TimeWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimeWindow;
}

void NebulaSQLParser::TimeWindowContext::copyFrom(TimeWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TumblingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TumblingWindowContext::TUMBLING() {
  return getToken(NebulaSQLParser::TUMBLING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::TumblingWindowContext::sizeParameter() {
  return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::TumblingWindowContext::timestampParameter() {
  return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::TumblingWindowContext::TumblingWindowContext(TimeWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TumblingWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTumblingWindow(this);
}
void NebulaSQLParser::TumblingWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTumblingWindow(this);
}
//----------------- SlidingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SlidingWindowContext::SLIDING() {
  return getToken(NebulaSQLParser::SLIDING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::SlidingWindowContext::sizeParameter() {
  return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::SlidingWindowContext::advancebyParameter() {
  return getRuleContext<NebulaSQLParser::AdvancebyParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::SlidingWindowContext::timestampParameter() {
  return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::SlidingWindowContext::SlidingWindowContext(TimeWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SlidingWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlidingWindow(this);
}
void NebulaSQLParser::SlidingWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlidingWindow(this);
}
NebulaSQLParser::TimeWindowContext* NebulaSQLParser::timeWindow() {
  TimeWindowContext *_localctx = _tracker.createInstance<TimeWindowContext>(_ctx, getState());
  enterRule(_localctx, 82, NebulaSQLParser::RuleTimeWindow);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(561);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::TUMBLING: {
        _localctx = _tracker.createInstance<NebulaSQLParser::TumblingWindowContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(539);
        match(NebulaSQLParser::TUMBLING);
        setState(540);
        match(NebulaSQLParser::T__2);
        setState(544);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::IDENTIFIER) {
          setState(541);
          timestampParameter();
          setState(542);
          match(NebulaSQLParser::T__1);
        }
        setState(546);
        sizeParameter();
        setState(547);
        match(NebulaSQLParser::T__3);
        break;
      }

      case NebulaSQLParser::SLIDING: {
        _localctx = _tracker.createInstance<NebulaSQLParser::SlidingWindowContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(549);
        match(NebulaSQLParser::SLIDING);
        setState(550);
        match(NebulaSQLParser::T__2);
        setState(554);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::IDENTIFIER) {
          setState(551);
          timestampParameter();
          setState(552);
          match(NebulaSQLParser::T__1);
        }
        setState(556);
        sizeParameter();
        setState(557);
        match(NebulaSQLParser::T__1);
        setState(558);
        advancebyParameter();
        setState(559);
        match(NebulaSQLParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CountWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext::CountWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::CountWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleCountWindow;
}

void NebulaSQLParser::CountWindowContext::copyFrom(CountWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CountBasedTumblingContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::TUMBLING() {
  return getToken(NebulaSQLParser::TUMBLING, 0);
}

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::CountBasedTumblingContext::CountBasedTumblingContext(CountWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::CountBasedTumblingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountBasedTumbling(this);
}
void NebulaSQLParser::CountBasedTumblingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountBasedTumbling(this);
}
NebulaSQLParser::CountWindowContext* NebulaSQLParser::countWindow() {
  CountWindowContext *_localctx = _tracker.createInstance<CountWindowContext>(_ctx, getState());
  enterRule(_localctx, 84, NebulaSQLParser::RuleCountWindow);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedTumblingContext>(_localctx);
    enterOuterAlt(_localctx, 1);
    setState(563);
    match(NebulaSQLParser::TUMBLING);
    setState(564);
    match(NebulaSQLParser::T__2);
    setState(565);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(566);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::SizeParameterContext::SizeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::SIZE() {
  return getToken(NebulaSQLParser::SIZE, 0);
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SizeParameterContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::SizeParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSizeParameter;
}

void NebulaSQLParser::SizeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeParameter(this);
}

void NebulaSQLParser::SizeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeParameter(this);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::sizeParameter() {
  SizeParameterContext *_localctx = _tracker.createInstance<SizeParameterContext>(_ctx, getState());
  enterRule(_localctx, 86, NebulaSQLParser::RuleSizeParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(568);
    match(NebulaSQLParser::SIZE);
    setState(569);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(570);
    timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdvancebyParameterContext ------------------------------------------------------------------

NebulaSQLParser::AdvancebyParameterContext::AdvancebyParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::ADVANCE() {
  return getToken(NebulaSQLParser::ADVANCE, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::AdvancebyParameterContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::AdvancebyParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAdvancebyParameter;
}

void NebulaSQLParser::AdvancebyParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdvancebyParameter(this);
}

void NebulaSQLParser::AdvancebyParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdvancebyParameter(this);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::advancebyParameter() {
  AdvancebyParameterContext *_localctx = _tracker.createInstance<AdvancebyParameterContext>(_ctx, getState());
  enterRule(_localctx, 88, NebulaSQLParser::RuleAdvancebyParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    match(NebulaSQLParser::ADVANCE);
    setState(573);
    match(NebulaSQLParser::BY);
    setState(574);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(575);
    timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeUnitContext ------------------------------------------------------------------

NebulaSQLParser::TimeUnitContext::TimeUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MS() {
  return getToken(NebulaSQLParser::MS, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::SEC() {
  return getToken(NebulaSQLParser::SEC, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MIN() {
  return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::HOUR() {
  return getToken(NebulaSQLParser::HOUR, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::DAY() {
  return getToken(NebulaSQLParser::DAY, 0);
}


size_t NebulaSQLParser::TimeUnitContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimeUnit;
}

void NebulaSQLParser::TimeUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnit(this);
}

void NebulaSQLParser::TimeUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnit(this);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::timeUnit() {
  TimeUnitContext *_localctx = _tracker.createInstance<TimeUnitContext>(_ctx, getState());
  enterRule(_localctx, 90, NebulaSQLParser::RuleTimeUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(577);
    _la = _input->LA(1);
    if (!(((((_la - 83) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 83)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimestampParameterContext ------------------------------------------------------------------

NebulaSQLParser::TimestampParameterContext::TimestampParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::TimestampParameterContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::TimestampParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimestampParameter;
}

void NebulaSQLParser::TimestampParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimestampParameter(this);
}

void NebulaSQLParser::TimestampParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimestampParameter(this);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::timestampParameter() {
  TimestampParameterContext *_localctx = _tracker.createInstance<TimestampParameterContext>(_ctx, getState());
  enterRule(_localctx, 92, NebulaSQLParser::RuleTimestampParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(579);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::AVG() {
  return getToken(NebulaSQLParser::AVG, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MAX() {
  return getToken(NebulaSQLParser::MAX, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MIN() {
  return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::SUM() {
  return getToken(NebulaSQLParser::SUM, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::COUNT() {
  return getToken(NebulaSQLParser::COUNT, 0);
}


size_t NebulaSQLParser::FunctionNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFunctionName;
}

void NebulaSQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void NebulaSQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 94, NebulaSQLParser::RuleFunctionName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(581);
    _la = _input->LA(1);
    if (!(((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & 121) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkClauseContext ------------------------------------------------------------------

NebulaSQLParser::SinkClauseContext::SinkClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::INTO() {
  return getToken(NebulaSQLParser::INTO, 0);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::SinkClauseContext::sinkType() {
  return getRuleContext<NebulaSQLParser::SinkTypeContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}


size_t NebulaSQLParser::SinkClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkClause;
}

void NebulaSQLParser::SinkClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkClause(this);
}

void NebulaSQLParser::SinkClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkClause(this);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::sinkClause() {
  SinkClauseContext *_localctx = _tracker.createInstance<SinkClauseContext>(_ctx, getState());
  enterRule(_localctx, 96, NebulaSQLParser::RuleSinkClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(583);
    match(NebulaSQLParser::INTO);
    setState(584);
    sinkType();
    setState(586);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(585);
      match(NebulaSQLParser::AS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeContext::SinkTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SinkTypeZMQContext* NebulaSQLParser::SinkTypeContext::sinkTypeZMQ() {
  return getRuleContext<NebulaSQLParser::SinkTypeZMQContext>(0);
}

NebulaSQLParser::SinkTypeKafkaContext* NebulaSQLParser::SinkTypeContext::sinkTypeKafka() {
  return getRuleContext<NebulaSQLParser::SinkTypeKafkaContext>(0);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::SinkTypeContext::sinkTypeFile() {
  return getRuleContext<NebulaSQLParser::SinkTypeFileContext>(0);
}

NebulaSQLParser::SinkTypeMQTTContext* NebulaSQLParser::SinkTypeContext::sinkTypeMQTT() {
  return getRuleContext<NebulaSQLParser::SinkTypeMQTTContext>(0);
}

NebulaSQLParser::SinkTypeOPCContext* NebulaSQLParser::SinkTypeContext::sinkTypeOPC() {
  return getRuleContext<NebulaSQLParser::SinkTypeOPCContext>(0);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::SinkTypeContext::sinkTypePrint() {
  return getRuleContext<NebulaSQLParser::SinkTypePrintContext>(0);
}


size_t NebulaSQLParser::SinkTypeContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkType;
}

void NebulaSQLParser::SinkTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkType(this);
}

void NebulaSQLParser::SinkTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkType(this);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::sinkType() {
  SinkTypeContext *_localctx = _tracker.createInstance<SinkTypeContext>(_ctx, getState());
  enterRule(_localctx, 98, NebulaSQLParser::RuleSinkType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(594);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::ZMQ: {
        enterOuterAlt(_localctx, 1);
        setState(588);
        sinkTypeZMQ();
        break;
      }

      case NebulaSQLParser::KAFKA: {
        enterOuterAlt(_localctx, 2);
        setState(589);
        sinkTypeKafka();
        break;
      }

      case NebulaSQLParser::FILE: {
        enterOuterAlt(_localctx, 3);
        setState(590);
        sinkTypeFile();
        break;
      }

      case NebulaSQLParser::MQTT: {
        enterOuterAlt(_localctx, 4);
        setState(591);
        sinkTypeMQTT();
        break;
      }

      case NebulaSQLParser::OPC: {
        enterOuterAlt(_localctx, 5);
        setState(592);
        sinkTypeOPC();
        break;
      }

      case NebulaSQLParser::PRINT: {
        enterOuterAlt(_localctx, 6);
        setState(593);
        sinkTypePrint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeCSVContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeCSVContext::SinkTypeCSVContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::CsvKeywordContext* NebulaSQLParser::SinkTypeCSVContext::csvKeyword() {
  return getRuleContext<NebulaSQLParser::CsvKeywordContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeCSVContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}


size_t NebulaSQLParser::SinkTypeCSVContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeCSV;
}

void NebulaSQLParser::SinkTypeCSVContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeCSV(this);
}

void NebulaSQLParser::SinkTypeCSVContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeCSV(this);
}

NebulaSQLParser::SinkTypeCSVContext* NebulaSQLParser::sinkTypeCSV() {
  SinkTypeCSVContext *_localctx = _tracker.createInstance<SinkTypeCSVContext>(_ctx, getState());
  enterRule(_localctx, 100, NebulaSQLParser::RuleSinkTypeCSV);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(596);
    csvKeyword();
    setState(597);
    match(NebulaSQLParser::T__2);
    setState(598);
    antlrcpp::downCast<SinkTypeCSVContext *>(_localctx)->path = match(NebulaSQLParser::STRING);
    setState(599);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsvKeywordContext ------------------------------------------------------------------

NebulaSQLParser::CsvKeywordContext::CsvKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::CsvKeywordContext::CSV() {
  return getToken(NebulaSQLParser::CSV, 0);
}


size_t NebulaSQLParser::CsvKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleCsvKeyword;
}

void NebulaSQLParser::CsvKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsvKeyword(this);
}

void NebulaSQLParser::CsvKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsvKeyword(this);
}

NebulaSQLParser::CsvKeywordContext* NebulaSQLParser::csvKeyword() {
  CsvKeywordContext *_localctx = _tracker.createInstance<CsvKeywordContext>(_ctx, getState());
  enterRule(_localctx, 102, NebulaSQLParser::RuleCsvKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    match(NebulaSQLParser::CSV);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeZMQContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeZMQContext::SinkTypeZMQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ZmqKeywordContext* NebulaSQLParser::SinkTypeZMQContext::zmqKeyword() {
  return getRuleContext<NebulaSQLParser::ZmqKeywordContext>(0);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::SinkTypeZMQContext::streamName() {
  return getRuleContext<NebulaSQLParser::StreamNameContext>(0);
}

NebulaSQLParser::HostContext* NebulaSQLParser::SinkTypeZMQContext::host() {
  return getRuleContext<NebulaSQLParser::HostContext>(0);
}

NebulaSQLParser::PortContext* NebulaSQLParser::SinkTypeZMQContext::port() {
  return getRuleContext<NebulaSQLParser::PortContext>(0);
}


size_t NebulaSQLParser::SinkTypeZMQContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeZMQ;
}

void NebulaSQLParser::SinkTypeZMQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeZMQ(this);
}

void NebulaSQLParser::SinkTypeZMQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeZMQ(this);
}

NebulaSQLParser::SinkTypeZMQContext* NebulaSQLParser::sinkTypeZMQ() {
  SinkTypeZMQContext *_localctx = _tracker.createInstance<SinkTypeZMQContext>(_ctx, getState());
  enterRule(_localctx, 104, NebulaSQLParser::RuleSinkTypeZMQ);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    zmqKeyword();
    setState(604);
    match(NebulaSQLParser::T__2);
    setState(605);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqStreamName = streamName();
    setState(606);
    match(NebulaSQLParser::T__1);
    setState(607);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqHostLabel = host();
    setState(608);
    match(NebulaSQLParser::T__1);
    setState(609);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqPort = port();
    setState(610);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullNotnullContext ------------------------------------------------------------------

NebulaSQLParser::NullNotnullContext::NullNotnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}


size_t NebulaSQLParser::NullNotnullContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNullNotnull;
}

void NebulaSQLParser::NullNotnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullNotnull(this);
}

void NebulaSQLParser::NullNotnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullNotnull(this);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::nullNotnull() {
  NullNotnullContext *_localctx = _tracker.createInstance<NullNotnullContext>(_ctx, getState());
  enterRule(_localctx, 106, NebulaSQLParser::RuleNullNotnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(613);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::NOT) {
      setState(612);
      match(NebulaSQLParser::NOT);
    }
    setState(615);
    match(NebulaSQLParser::NULLTOKEN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ZmqKeywordContext ------------------------------------------------------------------

NebulaSQLParser::ZmqKeywordContext::ZmqKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ZmqKeywordContext::ZMQ() {
  return getToken(NebulaSQLParser::ZMQ, 0);
}


size_t NebulaSQLParser::ZmqKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleZmqKeyword;
}

void NebulaSQLParser::ZmqKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterZmqKeyword(this);
}

void NebulaSQLParser::ZmqKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitZmqKeyword(this);
}

NebulaSQLParser::ZmqKeywordContext* NebulaSQLParser::zmqKeyword() {
  ZmqKeywordContext *_localctx = _tracker.createInstance<ZmqKeywordContext>(_ctx, getState());
  enterRule(_localctx, 108, NebulaSQLParser::RuleZmqKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(617);
    match(NebulaSQLParser::ZMQ);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamNameContext ------------------------------------------------------------------

NebulaSQLParser::StreamNameContext::StreamNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::StreamNameContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::StreamNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStreamName;
}

void NebulaSQLParser::StreamNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamName(this);
}

void NebulaSQLParser::StreamNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamName(this);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::streamName() {
  StreamNameContext *_localctx = _tracker.createInstance<StreamNameContext>(_ctx, getState());
  enterRule(_localctx, 110, NebulaSQLParser::RuleStreamName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(619);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HostContext ------------------------------------------------------------------

NebulaSQLParser::HostContext::HostContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::HostContext::FOUR_OCTETS() {
  return getToken(NebulaSQLParser::FOUR_OCTETS, 0);
}

tree::TerminalNode* NebulaSQLParser::HostContext::LOCALHOST() {
  return getToken(NebulaSQLParser::LOCALHOST, 0);
}


size_t NebulaSQLParser::HostContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHost;
}

void NebulaSQLParser::HostContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHost(this);
}

void NebulaSQLParser::HostContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHost(this);
}

NebulaSQLParser::HostContext* NebulaSQLParser::host() {
  HostContext *_localctx = _tracker.createInstance<HostContext>(_ctx, getState());
  enterRule(_localctx, 112, NebulaSQLParser::RuleHost);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(621);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::LOCALHOST

    || _la == NebulaSQLParser::FOUR_OCTETS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

NebulaSQLParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::PortContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::PortContext::getRuleIndex() const {
  return NebulaSQLParser::RulePort;
}

void NebulaSQLParser::PortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort(this);
}

void NebulaSQLParser::PortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort(this);
}

NebulaSQLParser::PortContext* NebulaSQLParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 114, NebulaSQLParser::RulePort);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(623);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeKafkaContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeKafkaContext::SinkTypeKafkaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::KafkaKeywordContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaKeyword() {
  return getRuleContext<NebulaSQLParser::KafkaKeywordContext>(0);
}

NebulaSQLParser::KafkaBrokerContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaBroker() {
  return getRuleContext<NebulaSQLParser::KafkaBrokerContext>(0);
}

NebulaSQLParser::KafkaTopicContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaTopic() {
  return getRuleContext<NebulaSQLParser::KafkaTopicContext>(0);
}

NebulaSQLParser::KafkaProducerTimoutContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaProducerTimout() {
  return getRuleContext<NebulaSQLParser::KafkaProducerTimoutContext>(0);
}


size_t NebulaSQLParser::SinkTypeKafkaContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeKafka;
}

void NebulaSQLParser::SinkTypeKafkaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeKafka(this);
}

void NebulaSQLParser::SinkTypeKafkaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeKafka(this);
}

NebulaSQLParser::SinkTypeKafkaContext* NebulaSQLParser::sinkTypeKafka() {
  SinkTypeKafkaContext *_localctx = _tracker.createInstance<SinkTypeKafkaContext>(_ctx, getState());
  enterRule(_localctx, 116, NebulaSQLParser::RuleSinkTypeKafka);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(625);
    kafkaKeyword();
    setState(626);
    match(NebulaSQLParser::T__2);
    setState(627);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->broker = kafkaBroker();
    setState(628);
    match(NebulaSQLParser::T__1);
    setState(629);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->topic = kafkaTopic();
    setState(630);
    match(NebulaSQLParser::T__1);
    setState(631);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->timeout = kafkaProducerTimout();
    setState(632);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaKeywordContext ------------------------------------------------------------------

NebulaSQLParser::KafkaKeywordContext::KafkaKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaKeywordContext::KAFKA() {
  return getToken(NebulaSQLParser::KAFKA, 0);
}


size_t NebulaSQLParser::KafkaKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaKeyword;
}

void NebulaSQLParser::KafkaKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaKeyword(this);
}

void NebulaSQLParser::KafkaKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaKeyword(this);
}

NebulaSQLParser::KafkaKeywordContext* NebulaSQLParser::kafkaKeyword() {
  KafkaKeywordContext *_localctx = _tracker.createInstance<KafkaKeywordContext>(_ctx, getState());
  enterRule(_localctx, 118, NebulaSQLParser::RuleKafkaKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(634);
    match(NebulaSQLParser::KAFKA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaBrokerContext ------------------------------------------------------------------

NebulaSQLParser::KafkaBrokerContext::KafkaBrokerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaBrokerContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::KafkaBrokerContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaBroker;
}

void NebulaSQLParser::KafkaBrokerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaBroker(this);
}

void NebulaSQLParser::KafkaBrokerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaBroker(this);
}

NebulaSQLParser::KafkaBrokerContext* NebulaSQLParser::kafkaBroker() {
  KafkaBrokerContext *_localctx = _tracker.createInstance<KafkaBrokerContext>(_ctx, getState());
  enterRule(_localctx, 120, NebulaSQLParser::RuleKafkaBroker);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(636);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaTopicContext ------------------------------------------------------------------

NebulaSQLParser::KafkaTopicContext::KafkaTopicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaTopicContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::KafkaTopicContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaTopic;
}

void NebulaSQLParser::KafkaTopicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaTopic(this);
}

void NebulaSQLParser::KafkaTopicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaTopic(this);
}

NebulaSQLParser::KafkaTopicContext* NebulaSQLParser::kafkaTopic() {
  KafkaTopicContext *_localctx = _tracker.createInstance<KafkaTopicContext>(_ctx, getState());
  enterRule(_localctx, 122, NebulaSQLParser::RuleKafkaTopic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaProducerTimoutContext ------------------------------------------------------------------

NebulaSQLParser::KafkaProducerTimoutContext::KafkaProducerTimoutContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaProducerTimoutContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::KafkaProducerTimoutContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaProducerTimout;
}

void NebulaSQLParser::KafkaProducerTimoutContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaProducerTimout(this);
}

void NebulaSQLParser::KafkaProducerTimoutContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaProducerTimout(this);
}

NebulaSQLParser::KafkaProducerTimoutContext* NebulaSQLParser::kafkaProducerTimout() {
  KafkaProducerTimoutContext *_localctx = _tracker.createInstance<KafkaProducerTimoutContext>(_ctx, getState());
  enterRule(_localctx, 124, NebulaSQLParser::RuleKafkaProducerTimout);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeFileContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeFileContext::SinkTypeFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::FILE() {
  return getToken(NebulaSQLParser::FILE, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeFileContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::SinkTypeFileContext::fileFormat() {
  return getRuleContext<NebulaSQLParser::FileFormatContext>(0);
}


size_t NebulaSQLParser::SinkTypeFileContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeFile;
}

void NebulaSQLParser::SinkTypeFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeFile(this);
}

void NebulaSQLParser::SinkTypeFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeFile(this);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::sinkTypeFile() {
  SinkTypeFileContext *_localctx = _tracker.createInstance<SinkTypeFileContext>(_ctx, getState());
  enterRule(_localctx, 126, NebulaSQLParser::RuleSinkTypeFile);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(642);
    match(NebulaSQLParser::FILE);
    setState(643);
    match(NebulaSQLParser::T__2);
    setState(644);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->path = match(NebulaSQLParser::STRING);
    setState(645);
    match(NebulaSQLParser::T__1);
    setState(646);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->format = fileFormat();
    setState(647);
    match(NebulaSQLParser::T__1);
    setState(648);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->append = match(NebulaSQLParser::STRING);
    setState(649);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileFormatContext ------------------------------------------------------------------

NebulaSQLParser::FileFormatContext::FileFormatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::CSV_FORMAT() {
  return getToken(NebulaSQLParser::CSV_FORMAT, 0);
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::NES_FORMAT() {
  return getToken(NebulaSQLParser::NES_FORMAT, 0);
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::TEXT_FORMAT() {
  return getToken(NebulaSQLParser::TEXT_FORMAT, 0);
}


size_t NebulaSQLParser::FileFormatContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFileFormat;
}

void NebulaSQLParser::FileFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileFormat(this);
}

void NebulaSQLParser::FileFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileFormat(this);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::fileFormat() {
  FileFormatContext *_localctx = _tracker.createInstance<FileFormatContext>(_ctx, getState());
  enterRule(_localctx, 128, NebulaSQLParser::RuleFileFormat);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(651);
    _la = _input->LA(1);
    if (!(((((_la - 102) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 102)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeMQTTContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeMQTTContext::SinkTypeMQTTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::MQTT() {
  return getToken(NebulaSQLParser::MQTT, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeMQTTContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeMQTTContext::INTEGER_VALUE() {
  return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::INTEGER_VALUE(size_t i) {
  return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SinkTypeMQTTContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}

NebulaSQLParser::QosContext* NebulaSQLParser::SinkTypeMQTTContext::qos() {
  return getRuleContext<NebulaSQLParser::QosContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::BOOLEAN_VALUE() {
  return getToken(NebulaSQLParser::BOOLEAN_VALUE, 0);
}


size_t NebulaSQLParser::SinkTypeMQTTContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeMQTT;
}

void NebulaSQLParser::SinkTypeMQTTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeMQTT(this);
}

void NebulaSQLParser::SinkTypeMQTTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeMQTT(this);
}

NebulaSQLParser::SinkTypeMQTTContext* NebulaSQLParser::sinkTypeMQTT() {
  SinkTypeMQTTContext *_localctx = _tracker.createInstance<SinkTypeMQTTContext>(_ctx, getState());
  enterRule(_localctx, 130, NebulaSQLParser::RuleSinkTypeMQTT);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    match(NebulaSQLParser::MQTT);
    setState(654);
    match(NebulaSQLParser::T__2);
    setState(655);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->mqttHostLabel = match(NebulaSQLParser::STRING);
    setState(656);
    match(NebulaSQLParser::T__1);
    setState(657);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->topic = match(NebulaSQLParser::STRING);
    setState(658);
    match(NebulaSQLParser::T__1);
    setState(659);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->user = match(NebulaSQLParser::STRING);
    setState(660);
    match(NebulaSQLParser::T__1);
    setState(661);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->maxBufferedMSGs = match(NebulaSQLParser::INTEGER_VALUE);
    setState(662);
    match(NebulaSQLParser::T__1);
    setState(663);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->mqttTimeUnitLabel = timeUnit();
    setState(664);
    match(NebulaSQLParser::T__1);
    setState(665);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->messageDelay = match(NebulaSQLParser::INTEGER_VALUE);
    setState(666);
    match(NebulaSQLParser::T__1);
    setState(667);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->qualityOfService = qos();
    setState(668);
    match(NebulaSQLParser::T__1);
    setState(669);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->asynchronousClient = match(NebulaSQLParser::BOOLEAN_VALUE);
    setState(670);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QosContext ------------------------------------------------------------------

NebulaSQLParser::QosContext::QosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QosContext::AT_MOST_ONCE() {
  return getToken(NebulaSQLParser::AT_MOST_ONCE, 0);
}

tree::TerminalNode* NebulaSQLParser::QosContext::AT_LEAST_ONCE() {
  return getToken(NebulaSQLParser::AT_LEAST_ONCE, 0);
}


size_t NebulaSQLParser::QosContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQos;
}

void NebulaSQLParser::QosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQos(this);
}

void NebulaSQLParser::QosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQos(this);
}

NebulaSQLParser::QosContext* NebulaSQLParser::qos() {
  QosContext *_localctx = _tracker.createInstance<QosContext>(_ctx, getState());
  enterRule(_localctx, 132, NebulaSQLParser::RuleQos);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(672);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::AT_MOST_ONCE

    || _la == NebulaSQLParser::AT_LEAST_ONCE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeOPCContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeOPCContext::SinkTypeOPCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeOPCContext::OPC() {
  return getToken(NebulaSQLParser::OPC, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeOPCContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeOPCContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}


size_t NebulaSQLParser::SinkTypeOPCContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeOPC;
}

void NebulaSQLParser::SinkTypeOPCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeOPC(this);
}

void NebulaSQLParser::SinkTypeOPCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeOPC(this);
}

NebulaSQLParser::SinkTypeOPCContext* NebulaSQLParser::sinkTypeOPC() {
  SinkTypeOPCContext *_localctx = _tracker.createInstance<SinkTypeOPCContext>(_ctx, getState());
  enterRule(_localctx, 134, NebulaSQLParser::RuleSinkTypeOPC);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    match(NebulaSQLParser::OPC);
    setState(675);
    match(NebulaSQLParser::T__2);
    setState(676);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->url = match(NebulaSQLParser::STRING);
    setState(677);
    match(NebulaSQLParser::T__1);
    setState(678);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->nodeId = match(NebulaSQLParser::STRING);
    setState(679);
    match(NebulaSQLParser::T__1);
    setState(680);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->user = match(NebulaSQLParser::STRING);
    setState(681);
    match(NebulaSQLParser::T__1);
    setState(682);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->password = match(NebulaSQLParser::STRING);
    setState(683);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypePrintContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypePrintContext::SinkTypePrintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypePrintContext::PRINT() {
  return getToken(NebulaSQLParser::PRINT, 0);
}


size_t NebulaSQLParser::SinkTypePrintContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypePrint;
}

void NebulaSQLParser::SinkTypePrintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypePrint(this);
}

void NebulaSQLParser::SinkTypePrintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypePrint(this);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::sinkTypePrint() {
  SinkTypePrintContext *_localctx = _tracker.createInstance<SinkTypePrintContext>(_ctx, getState());
  enterRule(_localctx, 136, NebulaSQLParser::RuleSinkTypePrint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(685);
    match(NebulaSQLParser::PRINT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

NebulaSQLParser::SortItemContext::SortItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::SortItemContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}


size_t NebulaSQLParser::SortItemContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSortItem;
}

void NebulaSQLParser::SortItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortItem(this);
}

void NebulaSQLParser::SortItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortItem(this);
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::sortItem() {
  SortItemContext *_localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
  enterRule(_localctx, 138, NebulaSQLParser::RuleSortItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(687);
    expression();
    setState(689);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::ASC

    || _la == NebulaSQLParser::DESC) {
      setState(688);
      antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::ASC

      || _la == NebulaSQLParser::DESC)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(693);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::NULLS) {
      setState(691);
      match(NebulaSQLParser::NULLS);
      setState(692);
      antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::FIRST

      || _la == NebulaSQLParser::LAST)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

NebulaSQLParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::PredicateContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicateContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::PredicateContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::PredicateContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IN() {
  return getToken(NebulaSQLParser::IN, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::PredicateContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ANY() {
  return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::SOME() {
  return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ESCAPE() {
  return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IS() {
  return getToken(NebulaSQLParser::IS, 0);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::PredicateContext::nullNotnull() {
  return getRuleContext<NebulaSQLParser::NullNotnullContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::UNKNOWN() {
  return getToken(NebulaSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::DISTINCT() {
  return getToken(NebulaSQLParser::DISTINCT, 0);
}


size_t NebulaSQLParser::PredicateContext::getRuleIndex() const {
  return NebulaSQLParser::RulePredicate;
}

void NebulaSQLParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void NebulaSQLParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 140, NebulaSQLParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(696);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(695);
        match(NebulaSQLParser::NOT);
      }
      setState(698);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::BETWEEN);
      setState(699);
      antlrcpp::downCast<PredicateContext *>(_localctx)->lower = valueExpression(0);
      setState(700);
      match(NebulaSQLParser::AND);
      setState(701);
      antlrcpp::downCast<PredicateContext *>(_localctx)->upper = valueExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(704);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(703);
        match(NebulaSQLParser::NOT);
      }
      setState(706);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::IN);
      setState(707);
      match(NebulaSQLParser::T__2);
      setState(708);
      expression();
      setState(713);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(709);
        match(NebulaSQLParser::T__1);
        setState(710);
        expression();
        setState(715);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(716);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(719);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(718);
        match(NebulaSQLParser::NOT);
      }
      setState(721);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::IN);
      setState(722);
      match(NebulaSQLParser::T__2);
      setState(723);
      query();
      setState(724);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(727);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(726);
        match(NebulaSQLParser::NOT);
      }
      setState(729);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::RLIKE);
      setState(730);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(732);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(731);
        match(NebulaSQLParser::NOT);
      }
      setState(734);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::LIKE);
      setState(735);
      antlrcpp::downCast<PredicateContext *>(_localctx)->quantifier = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 9) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 9)) & 36028797018963973) != 0))) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->quantifier = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(749);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(736);
        match(NebulaSQLParser::T__2);
        setState(737);
        match(NebulaSQLParser::T__3);
        break;
      }

      case 2: {
        setState(738);
        match(NebulaSQLParser::T__2);
        setState(739);
        expression();
        setState(744);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(740);
          match(NebulaSQLParser::T__1);
          setState(741);
          expression();
          setState(746);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(747);
        match(NebulaSQLParser::T__3);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(752);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(751);
        match(NebulaSQLParser::NOT);
      }
      setState(754);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::LIKE);
      setState(755);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      setState(758);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
      case 1: {
        setState(756);
        match(NebulaSQLParser::ESCAPE);
        setState(757);
        antlrcpp::downCast<PredicateContext *>(_localctx)->escapeChar = match(NebulaSQLParser::STRING);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(760);
      match(NebulaSQLParser::IS);
      setState(761);
      nullNotnull();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(762);
      match(NebulaSQLParser::IS);
      setState(764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(763);
        match(NebulaSQLParser::NOT);
      }
      setState(766);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 28) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 28)) & 9895604649985) != 0))) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(767);
      match(NebulaSQLParser::IS);
      setState(769);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(768);
        match(NebulaSQLParser::NOT);
      }
      setState(771);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::DISTINCT);
      setState(772);
      match(NebulaSQLParser::FROM);
      setState(773);
      antlrcpp::downCast<PredicateContext *>(_localctx)->right = valueExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext::ValueExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ValueExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleValueExpression;
}

void NebulaSQLParser::ValueExpressionContext::copyFrom(ValueExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ValueExpressionDefaultContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::ValueExpressionDefaultContext::primaryExpression() {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::ValueExpressionDefaultContext::ValueExpressionDefaultContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ValueExpressionDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueExpressionDefault(this);
}
void NebulaSQLParser::ValueExpressionDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueExpressionDefault(this);
}
//----------------- ComparisonContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::ComparisonContext::comparisonOperator() {
  return getRuleContext<NebulaSQLParser::ComparisonOperatorContext>(0);
}

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::ComparisonContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ComparisonContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

NebulaSQLParser::ComparisonContext::ComparisonContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}
void NebulaSQLParser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}
//----------------- ArithmeticBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::ArithmeticBinaryContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticBinaryContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::ASTERISK() {
  return getToken(NebulaSQLParser::ASTERISK, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::SLASH() {
  return getToken(NebulaSQLParser::SLASH, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PERCENT() {
  return getToken(NebulaSQLParser::PERCENT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PLUS() {
  return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::CONCAT_PIPE() {
  return getToken(NebulaSQLParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::AMPERSAND() {
  return getToken(NebulaSQLParser::AMPERSAND, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::HAT() {
  return getToken(NebulaSQLParser::HAT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PIPE() {
  return getToken(NebulaSQLParser::PIPE, 0);
}

NebulaSQLParser::ArithmeticBinaryContext::ArithmeticBinaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ArithmeticBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticBinary(this);
}
void NebulaSQLParser::ArithmeticBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticBinary(this);
}
//----------------- ArithmeticUnaryContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticUnaryContext::valueExpression() {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::PLUS() {
  return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::TILDE() {
  return getToken(NebulaSQLParser::TILDE, 0);
}

NebulaSQLParser::ArithmeticUnaryContext::ArithmeticUnaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ArithmeticUnaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticUnary(this);
}
void NebulaSQLParser::ArithmeticUnaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticUnary(this);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression() {
   return valueExpression(0);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::ValueExpressionContext *_localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
  NebulaSQLParser::ValueExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 142;
  enterRecursionRule(_localctx, 142, NebulaSQLParser::RuleValueExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(780);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ValueExpressionDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(777);
      primaryExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ArithmeticUnaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(778);
      antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 116) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 116)) & 35) != 0))) {
        antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(779);
      valueExpression(7);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(803);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(801);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(782);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(783);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == NebulaSQLParser::DIV || ((((_la - 118) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 118)) & 7) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(784);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(7);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(785);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(786);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 116) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 116)) & 259) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(787);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(6);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(788);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(789);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::AMPERSAND);
          setState(790);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(5);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(791);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(792);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::HAT);
          setState(793);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(4);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(794);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(795);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::PIPE);
          setState(796);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(3);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ComparisonContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(797);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(798);
          comparisonOperator();
          setState(799);
          antlrcpp::downCast<ComparisonContext *>(_localctx)->right = valueExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(805);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::EQ() {
  return getToken(NebulaSQLParser::EQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQ() {
  return getToken(NebulaSQLParser::NEQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQJ() {
  return getToken(NebulaSQLParser::NEQJ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LT() {
  return getToken(NebulaSQLParser::LT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LTE() {
  return getToken(NebulaSQLParser::LTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GT() {
  return getToken(NebulaSQLParser::GT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GTE() {
  return getToken(NebulaSQLParser::GTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NSEQ() {
  return getToken(NebulaSQLParser::NSEQ, 0);
}


size_t NebulaSQLParser::ComparisonOperatorContext::getRuleIndex() const {
  return NebulaSQLParser::RuleComparisonOperator;
}

void NebulaSQLParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void NebulaSQLParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 144, NebulaSQLParser::RuleComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(806);
    _la = _input->LA(1);
    if (!(((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HintContext ------------------------------------------------------------------

NebulaSQLParser::HintContext::HintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::HintStatementContext *> NebulaSQLParser::HintContext::hintStatement() {
  return getRuleContexts<NebulaSQLParser::HintStatementContext>();
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::HintContext::hintStatement(size_t i) {
  return getRuleContext<NebulaSQLParser::HintStatementContext>(i);
}


size_t NebulaSQLParser::HintContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHint;
}

void NebulaSQLParser::HintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHint(this);
}

void NebulaSQLParser::HintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHint(this);
}

NebulaSQLParser::HintContext* NebulaSQLParser::hint() {
  HintContext *_localctx = _tracker.createInstance<HintContext>(_ctx, getState());
  enterRule(_localctx, 146, NebulaSQLParser::RuleHint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(808);
    match(NebulaSQLParser::T__5);
    setState(809);
    antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext = hintStatement();
    antlrcpp::downCast<HintContext *>(_localctx)->hintStatements.push_back(antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext);
    setState(816);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(811);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
        case 1: {
          setState(810);
          match(NebulaSQLParser::T__1);
          break;
        }

        default:
          break;
        }
        setState(813);
        antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext = hintStatement();
        antlrcpp::downCast<HintContext *>(_localctx)->hintStatements.push_back(antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext); 
      }
      setState(818);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
    }
    setState(819);
    match(NebulaSQLParser::T__6);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HintStatementContext ------------------------------------------------------------------

NebulaSQLParser::HintStatementContext::HintStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::HintStatementContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

std::vector<NebulaSQLParser::PrimaryExpressionContext *> NebulaSQLParser::HintStatementContext::primaryExpression() {
  return getRuleContexts<NebulaSQLParser::PrimaryExpressionContext>();
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::HintStatementContext::primaryExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(i);
}


size_t NebulaSQLParser::HintStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHintStatement;
}

void NebulaSQLParser::HintStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHintStatement(this);
}

void NebulaSQLParser::HintStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHintStatement(this);
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::hintStatement() {
  HintStatementContext *_localctx = _tracker.createInstance<HintStatementContext>(_ctx, getState());
  enterRule(_localctx, 148, NebulaSQLParser::RuleHintStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(834);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(821);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->hintName = identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(822);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->hintName = identifier();
      setState(823);
      match(NebulaSQLParser::T__2);
      setState(824);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext = primaryExpression(0);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->parameters.push_back(antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext);
      setState(829);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(825);
        match(NebulaSQLParser::T__1);
        setState(826);
        antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext = primaryExpression(0);
        antlrcpp::downCast<HintStatementContext *>(_localctx)->parameters.push_back(antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext);
        setState(831);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(832);
      match(NebulaSQLParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::PrimaryExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RulePrimaryExpression;
}

void NebulaSQLParser::PrimaryExpressionContext::copyFrom(PrimaryExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DereferenceContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::DereferenceContext::primaryExpression() {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::DereferenceContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::DereferenceContext::DereferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DereferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDereference(this);
}
void NebulaSQLParser::DereferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDereference(this);
}
//----------------- ConstantDefaultContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext* NebulaSQLParser::ConstantDefaultContext::constant() {
  return getRuleContext<NebulaSQLParser::ConstantContext>(0);
}

NebulaSQLParser::ConstantDefaultContext::ConstantDefaultContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ConstantDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantDefault(this);
}
void NebulaSQLParser::ConstantDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantDefault(this);
}
//----------------- ColumnReferenceContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ColumnReferenceContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ColumnReferenceContext::ColumnReferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ColumnReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnReference(this);
}
void NebulaSQLParser::ColumnReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnReference(this);
}
//----------------- RowConstructorContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::NamedExpressionContext *> NebulaSQLParser::RowConstructorContext::namedExpression() {
  return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::RowConstructorContext::namedExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}

NebulaSQLParser::RowConstructorContext::RowConstructorContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::RowConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowConstructor(this);
}
void NebulaSQLParser::RowConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowConstructor(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ParenthesizedExpressionContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void NebulaSQLParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- StarContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::StarContext::ASTERISK() {
  return getToken(NebulaSQLParser::ASTERISK, 0);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::StarContext::qualifiedName() {
  return getRuleContext<NebulaSQLParser::QualifiedNameContext>(0);
}

NebulaSQLParser::StarContext::StarContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::StarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar(this);
}
void NebulaSQLParser::StarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::FunctionCallContext::functionName() {
  return getRuleContext<NebulaSQLParser::FunctionNameContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::FunctionCallContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionCallContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::FunctionCallContext::FunctionCallContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}
void NebulaSQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}
//----------------- SubqueryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryExpressionContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryExpressionContext::SubqueryExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SubqueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubqueryExpression(this);
}
void NebulaSQLParser::SubqueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubqueryExpression(this);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression() {
   return primaryExpression(0);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
  NebulaSQLParser::PrimaryExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 150;
  enterRecursionRule(_localctx, 150, NebulaSQLParser::RulePrimaryExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(876);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(837);
      match(NebulaSQLParser::ASTERISK);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(838);
      qualifiedName();
      setState(839);
      match(NebulaSQLParser::T__4);
      setState(840);
      match(NebulaSQLParser::ASTERISK);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SubqueryExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(842);
      match(NebulaSQLParser::T__2);
      setState(843);
      query();
      setState(844);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<RowConstructorContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(846);
      match(NebulaSQLParser::T__2);
      setState(847);
      namedExpression();
      setState(850); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(848);
        match(NebulaSQLParser::T__1);
        setState(849);
        namedExpression();
        setState(852); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == NebulaSQLParser::T__1);
      setState(854);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(856);
      functionName();
      setState(857);
      match(NebulaSQLParser::T__2);
      setState(866);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
      case 1: {
        setState(858);
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
        setState(863);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(859);
          match(NebulaSQLParser::T__1);
          setState(860);
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
          setState(865);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(868);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(870);
      match(NebulaSQLParser::T__2);
      setState(871);
      expression();
      setState(872);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<ConstantDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(874);
      constant();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<ColumnReferenceContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(875);
      identifier();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(883);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<DereferenceContext>(_tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->base = previousContext;
        pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
        setState(878);

        if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
        setState(879);
        match(NebulaSQLParser::T__4);
        setState(880);
        antlrcpp::downCast<DereferenceContext *>(_localctx)->fieldName = identifier(); 
      }
      setState(885);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

NebulaSQLParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::IdentifierContext *> NebulaSQLParser::QualifiedNameContext::identifier() {
  return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::QualifiedNameContext::identifier(size_t i) {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}


size_t NebulaSQLParser::QualifiedNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQualifiedName;
}

void NebulaSQLParser::QualifiedNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedName(this);
}

void NebulaSQLParser::QualifiedNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedName(this);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::qualifiedName() {
  QualifiedNameContext *_localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
  enterRule(_localctx, 152, NebulaSQLParser::RuleQualifiedName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(886);
    identifier();
    setState(891);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(887);
        match(NebulaSQLParser::T__4);
        setState(888);
        identifier(); 
      }
      setState(893);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::NumberContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNumber;
}

void NebulaSQLParser::NumberContext::copyFrom(NumberContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DecimalLiteralContext::DecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecimalLiteral(this);
}
void NebulaSQLParser::DecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecimalLiteral(this);
}
//----------------- BigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::BIGINT_LITERAL() {
  return getToken(NebulaSQLParser::BIGINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigIntLiteralContext::BigIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BigIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigIntLiteral(this);
}
void NebulaSQLParser::BigIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigIntLiteral(this);
}
//----------------- TinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::TINYINT_LITERAL() {
  return getToken(NebulaSQLParser::TINYINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::TinyIntLiteralContext::TinyIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TinyIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTinyIntLiteral(this);
}
void NebulaSQLParser::TinyIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTinyIntLiteral(this);
}
//----------------- LegacyDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::EXPONENT_VALUE() {
  return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::LegacyDecimalLiteralContext::LegacyDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LegacyDecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLegacyDecimalLiteral(this);
}
void NebulaSQLParser::LegacyDecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLegacyDecimalLiteral(this);
}
//----------------- BigDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::BIGDECIMAL_LITERAL() {
  return getToken(NebulaSQLParser::BIGDECIMAL_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigDecimalLiteralContext::BigDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BigDecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigDecimalLiteral(this);
}
void NebulaSQLParser::BigDecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigDecimalLiteral(this);
}
//----------------- ExponentLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::EXPONENT_VALUE() {
  return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::ExponentLiteralContext::ExponentLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ExponentLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExponentLiteral(this);
}
void NebulaSQLParser::ExponentLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExponentLiteral(this);
}
//----------------- DoubleLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::DOUBLE_LITERAL() {
  return getToken(NebulaSQLParser::DOUBLE_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DoubleLiteralContext::DoubleLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DoubleLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoubleLiteral(this);
}
void NebulaSQLParser::DoubleLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoubleLiteral(this);
}
//----------------- IntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::IntegerLiteralContext::IntegerLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::IntegerLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerLiteral(this);
}
void NebulaSQLParser::IntegerLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerLiteral(this);
}
//----------------- FloatLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::FLOAT_LITERAL() {
  return getToken(NebulaSQLParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::FloatLiteralContext::FloatLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FloatLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloatLiteral(this);
}
void NebulaSQLParser::FloatLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloatLiteral(this);
}
//----------------- SmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::SMALLINT_LITERAL() {
  return getToken(NebulaSQLParser::SMALLINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::SmallIntLiteralContext::SmallIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SmallIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSmallIntLiteral(this);
}
void NebulaSQLParser::SmallIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSmallIntLiteral(this);
}
NebulaSQLParser::NumberContext* NebulaSQLParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 154, NebulaSQLParser::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(937);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ExponentLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(894);

      if (!(!legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
      setState(896);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(895);
        match(NebulaSQLParser::MINUS);
      }
      setState(898);
      match(NebulaSQLParser::EXPONENT_VALUE);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::DecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(899);

      if (!(!legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
      setState(901);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(900);
        match(NebulaSQLParser::MINUS);
      }
      setState(903);
      match(NebulaSQLParser::DECIMAL_VALUE);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::LegacyDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(904);

      if (!(legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "legacy_exponent_literal_as_decimal_enabled");
      setState(906);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(905);
        match(NebulaSQLParser::MINUS);
      }
      setState(908);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::EXPONENT_VALUE

      || _la == NebulaSQLParser::DECIMAL_VALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::IntegerLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(910);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(909);
        match(NebulaSQLParser::MINUS);
      }
      setState(912);
      match(NebulaSQLParser::INTEGER_VALUE);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BigIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(914);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(913);
        match(NebulaSQLParser::MINUS);
      }
      setState(916);
      match(NebulaSQLParser::BIGINT_LITERAL);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<NebulaSQLParser::SmallIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(918);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(917);
        match(NebulaSQLParser::MINUS);
      }
      setState(920);
      match(NebulaSQLParser::SMALLINT_LITERAL);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TinyIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(922);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(921);
        match(NebulaSQLParser::MINUS);
      }
      setState(924);
      match(NebulaSQLParser::TINYINT_LITERAL);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<NebulaSQLParser::DoubleLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(926);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(925);
        match(NebulaSQLParser::MINUS);
      }
      setState(928);
      match(NebulaSQLParser::DOUBLE_LITERAL);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<NebulaSQLParser::FloatLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(930);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(929);
        match(NebulaSQLParser::MINUS);
      }
      setState(932);
      match(NebulaSQLParser::FLOAT_LITERAL);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BigDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(934);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(933);
        match(NebulaSQLParser::MINUS);
      }
      setState(936);
      match(NebulaSQLParser::BIGDECIMAL_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ConstantContext::getRuleIndex() const {
  return NebulaSQLParser::RuleConstant;
}

void NebulaSQLParser::ConstantContext::copyFrom(ConstantContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NullLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::NullLiteralContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

NebulaSQLParser::NullLiteralContext::NullLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullLiteral(this);
}
void NebulaSQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullLiteral(this);
}
//----------------- StringLiteralContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> NebulaSQLParser::StringLiteralContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::StringLiteralContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::StringLiteralContext::StringLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}
void NebulaSQLParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}
//----------------- TypeConstructorContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::TypeConstructorContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TypeConstructorContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}

NebulaSQLParser::TypeConstructorContext::TypeConstructorContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TypeConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeConstructor(this);
}
void NebulaSQLParser::TypeConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeConstructor(this);
}
//----------------- NumericLiteralContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext* NebulaSQLParser::NumericLiteralContext::number() {
  return getRuleContext<NebulaSQLParser::NumberContext>(0);
}

NebulaSQLParser::NumericLiteralContext::NumericLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}
void NebulaSQLParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}
//----------------- BooleanLiteralContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::BooleanLiteralContext::booleanValue() {
  return getRuleContext<NebulaSQLParser::BooleanValueContext>(0);
}

NebulaSQLParser::BooleanLiteralContext::BooleanLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}
void NebulaSQLParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}
NebulaSQLParser::ConstantContext* NebulaSQLParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 156, NebulaSQLParser::RuleConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(950);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::NullLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(939);
      match(NebulaSQLParser::NULLTOKEN);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TypeConstructorContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(940);
      identifier();
      setState(941);
      match(NebulaSQLParser::STRING);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::NumericLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(943);
      number();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BooleanLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(944);
      booleanValue();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::StringLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(946); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(945);
                match(NebulaSQLParser::STRING);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(948); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext::BooleanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}


size_t NebulaSQLParser::BooleanValueContext::getRuleIndex() const {
  return NebulaSQLParser::RuleBooleanValue;
}

void NebulaSQLParser::BooleanValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanValue(this);
}

void NebulaSQLParser::BooleanValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanValue(this);
}

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::booleanValue() {
  BooleanValueContext *_localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
  enterRule(_localctx, 158, NebulaSQLParser::RuleBooleanValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::FALSE

    || _la == NebulaSQLParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::StrictNonReservedContext::StrictNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::FULL() {
  return getToken(NebulaSQLParser::FULL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::INNER() {
  return getToken(NebulaSQLParser::INNER, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::JOIN() {
  return getToken(NebulaSQLParser::JOIN, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::LEFT() {
  return getToken(NebulaSQLParser::LEFT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::NATURAL() {
  return getToken(NebulaSQLParser::NATURAL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::ON() {
  return getToken(NebulaSQLParser::ON, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::RIGHT() {
  return getToken(NebulaSQLParser::RIGHT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::UNION() {
  return getToken(NebulaSQLParser::UNION, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::USING() {
  return getToken(NebulaSQLParser::USING, 0);
}


size_t NebulaSQLParser::StrictNonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStrictNonReserved;
}

void NebulaSQLParser::StrictNonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrictNonReserved(this);
}

void NebulaSQLParser::StrictNonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrictNonReserved(this);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::strictNonReserved() {
  StrictNonReservedContext *_localctx = _tracker.createInstance<StrictNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 160, NebulaSQLParser::RuleStrictNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(954);
    _la = _input->LA(1);
    if (!(((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 2474039710785) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnsiNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::AnsiNonReservedContext::AnsiNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::AT() {
  return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DELETE() {
  return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DROP() {
  return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::INSERT() {
  return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::MERGE() {
  return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::QUERY() {
  return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TYPE() {
  return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}


size_t NebulaSQLParser::AnsiNonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAnsiNonReserved;
}

void NebulaSQLParser::AnsiNonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnsiNonReserved(this);
}

void NebulaSQLParser::AnsiNonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnsiNonReserved(this);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::ansiNonReserved() {
  AnsiNonReservedContext *_localctx = _tracker.createInstance<AnsiNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 162, NebulaSQLParser::RuleAnsiNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(956);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5615592343523696640) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 579) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonReservedContext ------------------------------------------------------------------

NebulaSQLParser::NonReservedContext::NonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AT() {
  return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DELETE() {
  return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DROP() {
  return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INSERT() {
  return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::MERGE() {
  return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::QUERY() {
  return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TYPE() {
  return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ANY() {
  return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DISTINCT() {
  return getToken(NebulaSQLParser::DISTINCT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ESCAPE() {
  return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUP() {
  return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::HAVING() {
  return getToken(NebulaSQLParser::HAVING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IN() {
  return getToken(NebulaSQLParser::IN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INTO() {
  return getToken(NebulaSQLParser::INTO, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IS() {
  return getToken(NebulaSQLParser::IS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::OR() {
  return getToken(NebulaSQLParser::OR, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ORDER() {
  return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SELECT() {
  return getToken(NebulaSQLParser::SELECT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SOME() {
  return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TABLE() {
  return getToken(NebulaSQLParser::TABLE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WHERE() {
  return getToken(NebulaSQLParser::WHERE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WITH() {
  return getToken(NebulaSQLParser::WITH, 0);
}


size_t NebulaSQLParser::NonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNonReserved;
}

void NebulaSQLParser::NonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonReserved(this);
}

void NebulaSQLParser::NonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonReserved(this);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::nonReserved() {
  NonReservedContext *_localctx = _tracker.createInstance<NonReservedContext>(_ctx, getState());
  enterRule(_localctx, 164, NebulaSQLParser::RuleNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(958);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -892438752910246400) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 29749) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool NebulaSQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return queryTermSempred(antlrcpp::downCast<QueryTermContext *>(context), predicateIndex);
    case 24: return identifierSempred(antlrcpp::downCast<IdentifierContext *>(context), predicateIndex);
    case 25: return strictIdentifierSempred(antlrcpp::downCast<StrictIdentifierContext *>(context), predicateIndex);
    case 33: return booleanExpressionSempred(antlrcpp::downCast<BooleanExpressionContext *>(context), predicateIndex);
    case 71: return valueExpressionSempred(antlrcpp::downCast<ValueExpressionContext *>(context), predicateIndex);
    case 75: return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext *>(context), predicateIndex);
    case 77: return numberSempred(antlrcpp::downCast<NumberContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::queryTermSempred(QueryTermContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::identifierSempred(IdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return !SQL_standard_keyword_behavior;

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::strictIdentifierSempred(StrictIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return SQL_standard_keyword_behavior;
    case 3: return !SQL_standard_keyword_behavior;

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::booleanExpressionSempred(BooleanExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::valueExpressionSempred(ValueExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 6);
    case 7: return precpred(_ctx, 5);
    case 8: return precpred(_ctx, 4);
    case 9: return precpred(_ctx, 3);
    case 10: return precpred(_ctx, 2);
    case 11: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::primaryExpressionSempred(PrimaryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::numberSempred(NumberContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return !legacy_exponent_literal_as_decimal_enabled;
    case 14: return !legacy_exponent_literal_as_decimal_enabled;
    case 15: return legacy_exponent_literal_as_decimal_enabled;

  default:
    break;
  }
  return true;
}

void NebulaSQLParser::initialize() {
  ::antlr4::internal::call_once(nebulasqlParserOnceFlag, nebulasqlParserInitialize);
}
