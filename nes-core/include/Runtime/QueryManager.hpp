/*
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
#ifndef NES_INCLUDE_RUNTIME_QUERYMANAGER_HPP_
#define NES_INCLUDE_RUNTIME_QUERYMANAGER_HPP_

#include <Phases/ConvertLogicalToPhysicalSource.hpp>
#include <Plans/Query/QuerySubPlanId.hpp>
#include <Runtime/BufferManager.hpp>
#include <Runtime/Execution/ExecutablePipeline.hpp>
#include <Runtime/Execution/ExecutableQueryPlan.hpp>
#include <Runtime/Execution/ExecutableQueryPlanStatus.hpp>
#include <Runtime/QueryStatistics.hpp>
#include <Runtime/Reconfigurable.hpp>
#include <Runtime/ReconfigurationMessage.hpp>
#include <Runtime/RuntimeForwardRefs.hpp>
#include <Runtime/Task.hpp>
#include <Sources/DataSource.hpp>
#include <State/StateManager.hpp>
#include <Util/AtomicCounter.hpp>
#include <Util/ThreadBarrier.hpp>
#include <Util/VirtualEnableSharedFromThis.hpp>
#include <Util/libcuckoo/cuckoohash_map.hh>
#include <Windowing/WindowHandler/AbstractWindowHandler.hpp>
#include <chrono>
#include <condition_variable>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <unordered_map>
#include <unordered_set>

#ifdef ENABLE_PAPI_PROFILER
#include <Runtime/Profiler/PAPIProfiler.hpp>
#endif

#include <folly/MPMCQueue.h>
#include <folly/concurrency/UnboundedQueue.h>

namespace NES {
namespace Runtime {

class ThreadPool;
using ThreadPoolPtr = std::shared_ptr<ThreadPool>;// TODO consider moving this atomic in c++20

/**
* @brief the query manager is the central class to process queries.
* It is source-driven. Each incoming buffer will add a task to the queue.
* The query manager maintains three structures:
* 1.) a data_source map to map one data source to N queries
* 2.) a window map to map one window to N queries TODO:maybe should be removed later
* 3.) a data_sink to map one data sink to N queries
* @Limitations:
*    - statistics do not cover intermediate buffers
*/
class QueryManager : public NES::detail::virtual_enable_shared_from_this<QueryManager, false>, public Reconfigurable {
  public:
    using inherited0 = NES::detail::virtual_enable_shared_from_this<QueryManager, false>;

    using inherited1 = Reconfigurable;
    enum QueryManagerStatus : uint8_t { Created, Running, Stopped, Destroyed, Failed };

    enum QueryMangerMode : uint8_t { Dynamic, Static, NumaAware, Invalid };
    QueryManager() = delete;
    QueryManager(const QueryManager&) = delete;
    QueryManager& operator=(const QueryManager&) = delete;

    /**
    * @brief
    * @param bufferManager
    */
    explicit QueryManager(std::vector<BufferManagerPtr> bufferManagers,
                          uint64_t nodeEngineId,
                          uint16_t numThreads,
                          HardwareManagerPtr hardwareManager,
                          std::vector<uint64_t> workerToCoreMapping = {},
                          uint64_t numberOfQueues = 1,
                          uint64_t numberOfThreadsPerQueue = 1,
                          QueryMangerMode = Dynamic);

    ~QueryManager() NES_NOEXCEPT(false) override;

    /**
    * @brief register a query by extracting sources, windows and sink and add them to
    * respective map
    * @param QueryExecutionPlan to be deployed
    */
    bool registerQuery(const Execution::ExecutableQueryPlanPtr& qep);

    /**
     * @brief deregister a query by extracting sources, windows and sink and remove them
     * from respective map
     * @param QueryExecutionPlan to be deployed
     * @return bool indicating if register was successful
    */
    bool deregisterQuery(const Execution::ExecutableQueryPlanPtr& qep);

    /**
     * @brief process task from task queue
     * @param bool indicating if the thread pool is still running
     * @param worker context
     * @return an execution result
     */
    ExecutionResult processNextTask(bool running, WorkerContext& workerContext);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each buffer generated by the window trigger
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the pipeline stage that will be executed next
     * @param id of the queue where to put the task (only necessary if multiple queues are used)
     */
    void addWorkForNextPipeline(TupleBuffer& buffer, Execution::SuccessorExecutablePipeline executable, uint32_t queueId = 0);

    /**
     * This method posts a reconfig callback task
     * @param task task to call
     */
    void postReconfigurationCallback(ReconfigurationMessage& task) override;

    /**
     * This methods triggers the reconfiguration
     * @param context workercontext
     */
    void reconfigure(ReconfigurationMessage&, WorkerContext& context) override;

    /**
     * @brief retrieve the execution status of a given local query sub plan id.
     * @param id : the query sub plan id
     * @return status of the query sub plan
     */
    Execution::ExecutableQueryPlanStatus getQepStatus(QuerySubPlanId id);

    /**
    * @brief get general statistics of QueryManager and Buffer Manager
    */
    std::string getQueryManagerStatistics();

    /**
     * @brief Provides the QEP object for an id
     * @param id the plan to lookup
     * @return the QEP or null, if not found
     */
    Execution::ExecutableQueryPlanPtr getQueryExecutionPlan(QuerySubPlanId id) const;

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool startQuery(const Execution::ExecutableQueryPlanPtr& qep, StateManagerPtr stateManager);

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @param graceful stop the query gracefully or not
     * @return bool indicating success
     */
    [[nodiscard]] bool stopQuery(const Execution::ExecutableQueryPlanPtr& qep, bool graceful = false);

    /**
    * @brief method to fail a query
    * @param qep of the query to fail
    * @return bool indicating success
    */
    bool failQuery(const Execution::ExecutableQueryPlanPtr& qep);

    /**
     * @brief notify all waiting threads in getWork() to wake up and finish up
     */
    void poisonWorkers();

    /**
     * @brief reset query manager to intial state
     */
    void destroy();

    /**
     * @brief method to return the query statistics
     * @param qep of the particular query
     * @return
     */
    QueryStatisticsPtr getQueryStatistics(QuerySubPlanId qepId);

    /**
     * Get the id of the current node
     * @return node id
     */
    uint64_t getNodeId() const;

    /**
     * @brief this methods adds a reconfiguration task on the worker queue
     * @return true if the reconfiguration task was added correctly on the worker queue
     * N.B.: this does not not mean that the reconfiguration took place but it means that it
     * was scheduled to be executed!
     * @param queryId: the local QEP to reconfigure
     * @param queryExecutionPlanId: the local sub QEP to reconfigure
     * @param reconfigurationDescriptor: what to do
     * @param blocking: whether to block until the reconfiguration is done. Mind this parameter because it blocks!
     */
    bool addReconfigurationMessage(QueryId queryId,
                                   QuerySubPlanId queryExecutionPlanId,
                                   const ReconfigurationMessage& reconfigurationMessage,
                                   bool blocking = false);

    /**
     * method to get the first buffer manger
     * @return first buffer manager
     */
    BufferManagerPtr getBufferManager() { return bufferManagers[0]; }

  private:
    /**
     * @brief this methods adds a reconfiguration task on the worker queue
     * @return true if the reconfiguration task was added correctly on the worker queue
     * N.B.: this does not not mean that the reconfiguration took place but it means that it
     * was scheduled to be executed!
     * @param queryId: the local QEP to reconfigure
     * @param queryExecutionPlanId: the local szb QEP to reconfigure
     * @param buffer: a tuple buffer storing the reconfiguration message
     * @param blocking: whether to block until the reconfiguration is done. Mind this parameter because it blocks!
     */
    bool
    addReconfigurationMessage(QueryId queryId, QuerySubPlanId queryExecutionPlanId, TupleBuffer&& buffer, bool blocking = false);

  public:
    /**
     * @brief
     * @param pipeline
     * @param message
     */
    void notifyTaskFailure(Execution::SuccessorExecutablePipeline pipeline, const std::string& message);

    /**
     * @brief
     * @param source
     * @param errorMessage
     */
    void notifyOperatorFailure(DataSourcePtr source, const std::string errorMessage);

    /**
     * @brief
     * @param qep
     * @param newStatus
     */
    void notifyQueryStatusChange(const Execution::ExecutableQueryPlanPtr& qep, Execution::ExecutableQueryPlanStatus newStatus);

    /**
    * @brief maps querySubId to query id
    * @return query id
    */
    uint64_t getQueryId(uint64_t querySubPlanId) const;

    /**
     * @brief introduces end of stream to all QEPs connected to this source
     * @param source the source
     * @param graceful hard or soft termination
     * @return true if it went through
     */
    bool addEndOfStream(DataSourcePtr source, bool graceful = true);

    /**
     * @return true if thread pool is running
     */
    bool isThreadPoolRunning() const;

    /**
     * @brief get number of tasks in the queue
     * @return task count
     */
    uint64_t getNumberOfTasksInWorkerQueue() const;

    /**
     * Return the current occupation of the task queue
     * @return number of tasks in the queue
     */
    uint64_t getCurrentTaskSum();

    /**
     * Returns the current number of worker threads
     * @return thread cnt
     */
    uint64_t getNumberOfWorkerThreads();

    /**
     * @brief
     * @param source
     */
    void notifySourceCompletion(DataSourcePtr source);

    /**
     * @brief
     * @param pipeline
     */
    void notifyPipelineCompletion(QuerySubPlanId subPlanId, Execution::ExecutablePipelinePtr pipeline);

    /**
     * @brief
     * @param pipeline
     */
    void notifySinkCompletion(QuerySubPlanId subPlanId, DataSinkPtr pipeline, bool isGraceful);

  private:
    /**
     * This method initializes the query manager mode
     */
    void initQueryManagerMode();

    friend class ThreadPool;
    friend class NodeEngine;
    /**
    * @brief method to start the thread pool
    * @param nodeEngineId the id of the owning node engine
    * @param numberOfBuffersPerWorker
    * @return bool indicating success
    */
    bool startThreadPool(uint64_t numberOfBuffersPerWorker);

    /**
     * @brief finalize task execution by:
     * 1.) update statistics (number of processed tuples and tasks)
     * 2.) release input buffer (give back to the buffer manager)
     * @param reference to processed task
     * @oaram reference to worker context
     */
    void completedWork(Task& task, WorkerContext& workerContext);

    ExecutionResult terminateLoop(WorkerContext&);

    bool addSoftEndOfStream(DataSourcePtr source);

    bool addHardEndOfStream(DataSourcePtr source);

    /**
     * @brief Returns the next free task id
     * @return next task id
     */
    uint64_t getNextTaskId();

  private:
    uint64_t nodeEngineId;
    std::atomic_uint64_t taskIdCounter = 0;
    std::vector<BufferManagerPtr> bufferManagers;
    ThreadPoolPtr threadPool{nullptr};

    uint16_t numThreads;
    QueryMangerMode queryMangerMode;
    uint16_t numberOfQueues;
    uint16_t numberOfThreadsPerQueue;
    HardwareManagerPtr hardwareManager;

    std::unordered_map<QuerySubPlanId, uint64_t> queryToTaskQueueIdMap;
    uint64_t currentTaskQueueId = 0;

    std::unordered_map<QuerySubPlanId, Execution::ExecutableQueryPlanPtr> runningQEPs;

    std::unordered_map<OperatorId, Execution::ExecutableQueryPlanPtr> sourceToQEPMapping; // assume source sharing disabled

    //TODO:check if it would be better to put it in the thread context
    mutable std::mutex statisticsMutex;
    cuckoohash_map<QuerySubPlanId, QueryStatisticsPtr> queryToStatisticsMap;

    mutable std::mutex reconfigurationMutex;

    Execution::ExecutablePipelineStagePtr reconfigurationExecutable;

    std::vector<uint64_t> workerToCoreMapping;
    mutable std::recursive_mutex queryMutex;

    std::vector<folly::MPMCQueue<Task>> taskQueues;
    std::atomic<QueryManagerStatus> queryManagerStatus{Created};
    std::vector<AtomicCounter<uint64_t>> tempCounterTasksCompleted;
#ifdef ENABLE_PAPI_PROFILER
    std::vector<Profiler::PapiCpuProfilerPtr> cpuProfilers;
#endif
};

using QueryManagerPtr = std::shared_ptr<QueryManager>;

}// namespace Runtime
}// namespace NES
#endif// NES_INCLUDE_RUNTIME_QUERYMANAGER_HPP_
