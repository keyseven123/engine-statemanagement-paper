# name: milestone/IOT.test
# description: IoT Sensor Data Analysis Queries
# groups: [milestone, benchmark, large]

# Source definition for IoT sensors dataset
SourceCSV iot_sensors INT32 sensor_id INT32 location_id UINT64 timestamp FLOAT64 temperature FLOAT64 humidity FLOAT64 pressure INT32 light_level FLOAT64 noise_level INT32 air_quality INT32 co2_level FLOAT64 power_consumption FLOAT64 battery_level INT32 signal_strength INT32 error_count INT32 maintenance_flag FLOAT64 calibration_offset FLOAT64 avg_daily_temp FLOAT64 max_daily_temp FLOAT64 min_daily_temp INT32 status_code TESTDATA/iot/iot_sensors_10m.csv

# Query 1 - Only 3 columns accessed out of 20, with selective filter
#SELECT
#location_id,
#       AVG(temperature)    AS avg_temp,
#       STDDEV(temperature) AS stddev_temp,
#       COUNT(*)            AS reading_count
#FROM   iot_sensors
#WHERE  temperature > FLOAT64(25)
#  AND  humidity    < FLOAT64(40)
#  AND  air_quality > INT32(150)
#GROUP BY location_id INTO CHECKSUM;
#----
#14236360, 35170842947

# Query 2 - Correlation analysis via COVAR_POP / STDDEV
#SELECT COVAR_POP(temperature, humidity)  / STDDEV(temperature) / STDDEV(humidity)    AS temp_humidity_corr,
#       COVAR_POP(temperature, pressure)  / STDDEV(temperature) / STDDEV(pressure)    AS temp_pressure_corr,
#       COVAR_POP(air_quality, co2_level) / STDDEV(air_quality) / STDDEV(co2_level) AS air_co2_corr,
#       VAR_POP(temperature)                                                  AS temp_variance,
#       VAR_POP(humidity)                                                     AS humidity_variance
#FROM   iot_sensors
#WHERE  timestamp > UINT64(1704067200)
#INTO   CHECKSUM;
#----
#14236360, 35170842947

# Query 3 - Complex analytical query with window functions
#SELECT sensor_id,
#       temperature,
#       humidity,
#       PERCENTILE_CONT(FLOAT64(0.95)) WITHIN GROUP (ORDER BY temperature)
#         OVER (PARTITION BY location_id)                  AS p95_temp,
#       AVG(temperature) OVER (
#         PARTITION BY location_id
#         ORDER BY timestamp
#         ROWS BETWEEN INT32(1000) PRECEDING AND CURRENT ROW
#       )                                                  AS moving_avg_temp,
#       RANK() OVER (PARTITION BY location_id ORDER BY power_consumption DESC) AS power_rank
#FROM   iot_sensors
#WHERE  battery_level < FLOAT64(20)
#INTO   CHECKSUM;
#----
#3556803, 8785569627

# Query 4 - Query targeting sparse columns
SELECT sensor_id,
       timestamp,
       error_count,
       maintenance_flag
FROM   iot_sensors
WHERE  error_count > INT32(0)
   OR  maintenance_flag = INT32(1)
INTO   CHECKSUM;
----
4271223, 10289477496

# Query 5 - Find sensors with worst environmental conditions
#SELECT
#  sensor_id,
#  location_id,
#  AVG(air_quality)      AS avg_air_quality,
#  AVG(noise_level)      AS avg_noise,
#  SUM(
#    CASE WHEN temperature > FLOAT64(35)
#         THEN INT32(1)
#         ELSE INT32(0)
#    END
#  )                     AS extreme_temp_days,
#  (
#    AVG(air_quality) * FLOAT64(0.4)
#    + AVG(noise_level) * FLOAT64(0.3)
#    + AVG(co2_level) / INT32(10) * FLOAT64(0.3)
#  )                     AS environmental_score
#FROM iot_sensors
#GROUP BY sensor_id, location_id
#ORDER BY environmental_score DESC
#LIMIT INT32(100) INTO CHECKSUM;
#----
#42700000, 15336467257

# Query 6 - Time-based aggregation with range predicates
#SELECT DATE_TRUNC('hour', timestamp) AS hour,
#       COUNT(*)                   AS reading_count,
#       AVG(temperature)           AS avg_temp,
#       MAX(temperature)           AS max_temp,
#       MIN(temperature)           AS min_temp,
#       SUM(power_consumption)     AS total_power
#FROM   iot_sensors
#WHERE  temperature BETWEEN FLOAT64(20) AND FLOAT64(30)
#  AND  pressure    BETWEEN FLOAT64(1000) AND FLOAT64(1020)
#GROUP BY DATE_TRUNC('hour', timestamp) INTO CHECKSUM;
#----
#1914020, 3897819033

# Query 7 - Cardinality analysis
#SELECT
#  COUNT_DISTINCT(sensor_id) AS unique_sensors,
#  COUNT_DISTINCT(location_id) AS unique_locations,
#  SUM(
#    CASE WHEN temperature > FLOAT64(30)
#         THEN INT32(1)
#         ELSE INT32(0)
#    END
#  ) AS hot_sensors,
#  SUM(
#    CASE WHEN error_count > INT32(0)
#         THEN INT32(1)
#         ELSE INT32(0)
#    END
#  ) AS faulty_sensors
#FROM iot_sensors
#WHERE timestamp > UINT64(1704067200)
#INTO CHECKSUM;
#----
#11484119, 23389063574