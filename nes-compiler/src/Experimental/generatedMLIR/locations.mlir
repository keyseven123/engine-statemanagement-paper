#loc4 = loc("EntryPoint"("Q1":0:0))
module  {
  llvm.func @printFromMLIR(i8, ...) -> i32 loc(#loc0)
  llvm.mlir.global external @IB() : !llvm.array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>> loc(#loc1)
  llvm.mlir.global external @OB() : !llvm.array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>> loc(#loc2)
  llvm.func @getNumTuples(...) -> i64 loc(#loc0)
  llvm.mlir.global external @IBPtr() : !llvm.ptr<i8> loc(#loc3)
  llvm.func @printValueFromMLIR(...) loc(#loc0)
  func @execute(%arg0: i32 loc("EntryPoint"("Q1":0:0))) -> i32 attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i32 loc(#loc5)
    %c0 = arith.constant 0 : index loc(#loc6)
    %c3 = arith.constant 3 : index loc(#loc7)
    %c1 = arith.constant 1 : index loc(#loc8)
    %c0_i32 = arith.constant 0 : i32 loc(#loc9)
    // Main For Loop
    %2 = scf.for %arg1 = %c0 to %c3 step %c1 iter_args(%arg2 = %c0_i32) -> (i32) {
      %3 = llvm.mlir.addressof @IBPtr : !llvm.ptr<ptr<i8>> loc(#loc12)
      %4 = llvm.call @getNumTuples(%3) : (!llvm.ptr<ptr<i8>>) -> i64 loc(#loc13)
      llvm.call @printValueFromMLIR(%4) : (i64) -> () loc(#loc14)
      %5 = llvm.mlir.addressof @IB : !llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>> loc(#loc15)
      %6 = llvm.mlir.addressof @OB : !llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>> loc(#loc15)
      %7 = llvm.mlir.constant(0 : index) : i32 loc(#loc16)
      %8 = llvm.getelementptr %5[%0, %arg2, %7] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i8> loc(#loc17)
      %9 = llvm.getelementptr %6[%0, %arg2, %7] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i8> loc(#loc18)
      %10 = llvm.load %8 : !llvm.ptr<i8> loc(#loc19)
      llvm.store %10, %9 : !llvm.ptr<i8> loc(#loc20)
      %11 = llvm.mlir.constant(1 : index) : i8 loc(#loc21)
      %12 = llvm.call @printFromMLIR(%11, %8) : (i8, !llvm.ptr<i8>) -> i32 loc(#loc22)
      %13 = llvm.mlir.constant(1 : index) : i32 loc(#loc16)
      %14 = llvm.getelementptr %5[%0, %arg2, %13] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i32> loc(#loc17)
      %15 = llvm.getelementptr %6[%0, %arg2, %13] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i32> loc(#loc18)
      %16 = llvm.load %14 : !llvm.ptr<i32> loc(#loc19)
      llvm.store %16, %15 : !llvm.ptr<i32> loc(#loc20)
      %17 = llvm.mlir.constant(3 : index) : i8 loc(#loc21)
      %18 = llvm.call @printFromMLIR(%17, %14) : (i8, !llvm.ptr<i32>) -> i32 loc(#loc22)
      %19 = llvm.mlir.constant(2 : index) : i32 loc(#loc16)
      %20 = llvm.getelementptr %5[%0, %arg2, %19] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i1> loc(#loc17)
      %21 = llvm.getelementptr %6[%0, %arg2, %19] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i1> loc(#loc18)
      %22 = llvm.load %20 : !llvm.ptr<i1> loc(#loc19)
      llvm.store %22, %21 : !llvm.ptr<i1> loc(#loc20)
      %23 = llvm.mlir.constant(7 : index) : i8 loc(#loc21)
      %24 = llvm.call @printFromMLIR(%23, %20) : (i8, !llvm.ptr<i1>) -> i32 loc(#loc22)
      %25 = llvm.mlir.constant(3 : index) : i32 loc(#loc16)
      %26 = llvm.getelementptr %5[%0, %arg2, %25] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<f32> loc(#loc17)
      %27 = llvm.getelementptr %6[%0, %arg2, %25] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<f32> loc(#loc18)
      %28 = llvm.load %26 : !llvm.ptr<f32> loc(#loc19)
      llvm.store %28, %27 : !llvm.ptr<f32> loc(#loc20)
      %29 = llvm.mlir.constant(5 : index) : i8 loc(#loc21)
      %30 = llvm.call @printFromMLIR(%29, %26) : (i8, !llvm.ptr<f32>) -> i32 loc(#loc22)
      %31 = llvm.mlir.constant(4 : index) : i32 loc(#loc16)
      %32 = llvm.getelementptr %5[%0, %arg2, %31] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i8> loc(#loc17)
      %33 = llvm.getelementptr %6[%0, %arg2, %31] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<i8> loc(#loc18)
      %34 = llvm.load %32 : !llvm.ptr<i8> loc(#loc19)
      llvm.store %34, %33 : !llvm.ptr<i8> loc(#loc20)
      %35 = llvm.mlir.constant(8 : index) : i8 loc(#loc21)
      %36 = llvm.call @printFromMLIR(%35, %32) : (i8, !llvm.ptr<i8>) -> i32 loc(#loc22)
      %37 = llvm.mlir.constant(5 : index) : i32 loc(#loc16)
      %38 = llvm.getelementptr %5[%0, %arg2, %37] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<f64> loc(#loc17)
      %39 = llvm.getelementptr %6[%0, %arg2, %37] : (!llvm.ptr<array<6 x struct<packed (i8, i32, i1, f32, i8, f64)>>>, i32, i32, i32) -> !llvm.ptr<f64> loc(#loc18)
      %40 = llvm.load %38 : !llvm.ptr<f64> loc(#loc19)
      llvm.store %40, %39 : !llvm.ptr<f64> loc(#loc20)
      %41 = llvm.mlir.constant(6 : index) : i8 loc(#loc21)
      %42 = llvm.call @printFromMLIR(%41, %38) : (i8, !llvm.ptr<f64>) -> i32 loc(#loc22)
      %c42_i32 = arith.constant 42 : i32 loc(#loc23)
      %43 = arith.cmpi slt, %arg2, %c42_i32 : i32 loc(#loc24)
      %44 = scf.if %43 -> (i32) {
        %c1_i32 = arith.constant 1 : i32 loc(#loc26)
        %45 = llvm.add %c1_i32, %arg2  : i32 loc(#loc27)
        scf.yield %45 : i32 loc(#loc28)
      } else {
        %c0_i32_0 = arith.constant 0 : i32 loc(#loc26)
        %45 = llvm.add %c0_i32_0, %arg2  : i32 loc(#loc27)
        scf.yield %45 : i32 loc(#loc28)
      } loc(#loc25)
      scf.yield %44 : i32 loc(#loc29)
    } loc(#loc11)
    llvm.return %2 : i32 loc(#loc30)
  } loc(#loc4)
} loc(#loc0)
#loc0 = loc("module"("Q":0:0))
#loc1 = loc("TupleBuffer"("Q1":0:0))
#loc2 = loc("OutputBuffer"("Q1":0:0))
#loc3 = loc("TB Pointer"("Q1":0:0))
#loc5 = loc("constant32Zero"("Q1":0:0))
#loc6 = loc("lowerBound"("Q1":0:0))
#loc7 = loc("upperBound"("Q1":0:0))
#loc8 = loc("stepSize"("Q1":0:0))
#loc9 = loc("iterationVariable"("Q1":0:0))
#loc10 = loc("Main For Loop"("Q1":0:0))
#loc11 = loc("forLoop"("Q1":0:0))
#loc12 = loc("loadPtr"("Q1":0:0))
#loc13 = loc("memberCall"("Q1":0:0))
#loc14 = loc("printFunc"("Q1":0:0))
#loc15 = loc("loadedArray"("Q1":0:0))
#loc16 = loc("fieldIdx"("Q1":0:0))
#loc17 = loc("ibGEP"("Q1":0:0))
#loc18 = loc("obGEP"("Q1":0:0))
#loc19 = loc("loadedValue"("Q1":0:0))
#loc20 = loc("outputStore"("Q1":0:0))
#loc21 = loc("type"("Q1":0:0))
#loc22 = loc("printFromMLIR"("Q1":0:0))
#loc23 = loc("comparisonvalue"("Q1":0:0))
#loc24 = loc("comparison"("Q1":0:0))
#loc25 = loc("ifOperation"("Q1":0:0))
#loc26 = loc("elseReturnValue"("Q1":0:0))
#loc27 = loc("binOpResult"("Q1":0:0))
#loc28 = loc("yieldOperation"("Q1":0:0))
#loc29 = loc("ifYield"("Q1":0:0))
#loc30 = loc("return"("Q1":0:0))
