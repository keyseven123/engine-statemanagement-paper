# CEP Feature for NebulaStream 

The current Nebula Stream system has no CEP functionality, thus lacking a powerful tool to detect interesting behaviour in massvie ammounts of continous data.
Furthermore, the active research project NEEDMI is interested in the support of CEP functionality. 

# The Problem
- P1: **CEP operators**, on a high-level, CEP is an umbrella term unifying a wide range of systems, such as pub-sub, streaming, and active databases, with a common goal, i.e., detect patterns. 
 For this reason, there is no common operator set to refer to.  

- P2: **A declarative language**, a core feature of CEP systems is its Pattern Specification Language (PSL). In contrast to SQL the number of dialects and syntax difference is diverse, i.e., every system uses its own PSL which is also caused by the diversity of operators. 
 For this reason, there is no commonly used PSL that can simply be incorporated into NebulaStream.  

- P3: The operator semantics are different from stream processing operators, i.e., incorporating temporal constraints that are not incorporated in set operations such as joins. 

# Goals
- G1: The goal is to provide an expressive set of common CEP operators to support a broad range of CEP queries in NebulaStream. To this end, we refer to the operator mapping that supports and translates them to stream processing operators (P1, see [Paper]git push(https://openproceedings.org/2024/conf/edbt/paper-114.pdf) for more details ).  
- G2: To reduce the entrance barrier for non-programming domain experts and overcome P2, we aim to provide a PSL and thus a declarative way to specific CEP patterns.  

# Non-Goals
- NG1: The grammar is not final, as it is a research prototype it might require updates. 
- NG2: The translator is not final, i.e., it requires updates depending on the operators and implemented features available in NES . 
- NG3: The operator mapping introduces some limitation which are yet not required by the research project and not part of the support operator set. In particular, the iteration operator is limited and does not support Kleene Closure patterns; the NOT operator requires a window UDF, and the mapping does not support all available CEP selection policies, i.e., it support skip-till-any-match which is a superset of other policies. Currently, we do not aim to overcome this limitations.  

# Our Proposed Solution
A comprehensive step towards reaching this goal is the integration of a PSL in combination with the operator mapping, i.e., in the translation phase from AST to operator tree. 
Thus, we enable a broad range of CEP pattern to run on NES reaching G1 and G2 (Issue (#517)).
The old NES version provides a PSL based on an ANTLR grammar and the proposed mapping from  CEP operators to stream processing operators, i.e., mainly join types.
The current version of NES2.0 already incorporates ANTRL dependencies and bases its NESSQL on an ANTLR grammar, too. Thus, the system meets all requirements for the migration of the PSL.

In the following, we give some additional insight to the [general operator mapping](https://openproceedings.org/2024/conf/edbt/paper-114.pdf):
The mapping (as well as the PSL) is based on Simple Event Algebra (SEA). SEA identifies a core set of CEP operators that balance complexity and expressiveness. Building on this operator set, we ensure our PSL remains robust yet accessible.
Below, we introduce the supported operator set, the PSL and the mapping, for documentation and proof of concept, we refer to the old repo and the mapping Paper. 
## CEP operators
In the following, we introduce the SEA operators' semantics and syntax: 

### Selection: 
- An unary operator that reduces the number of tuples by applying filter conditions to attributes of the stream (i.e., an event type). 
- Mapping: Filter

### Projection: 
- An unary operator that transforms the schema of the stream S to the selected set of attributes. 
- Mapping: Projection

### Conjunction:
- A conjunction expects two events (time-stamped tuples), i.e., $$e_1 \in S_1$$ and $$e_2 \in S_2$$ to occur together within a window $W$.
- Mapping: Cartesian Product, Optimization: (1) Equi-Join when join predicate with equality exists, (2) Theta-Join when another join predicate exists. 
- Keyword: AND, B AND C

### Sequence:
- A sequence expects an event $e_1 \in S_1$ and an event $e_2 \in S_2$ to occur in temporal order, i.e., $ts_{e_1} < ts_{e_2}$, within a window $W$. 
- Mapping:Theta Join, Optimization: (1) Equi-Join when join predicate with equality exists,
- Keyword: SEQ, B SEQ C

### Disjunction:
- A disjunction requires at least one of the events $e_n$ of the specified event types to occur within a window $W$. 
- Mapping: Union
- Keyword: OR, cannot standalone and requires a nested pattern, A SEQ (B OR C) 

### Iteration:
- The iteration allows multiple event occurrences m (m > 0) of a stream in a sequence. 
- Mapping: a multi-way Theta Join, i.e., m-way 
- Limitation of Mapping (and SEA): In contrast to Kleene Closure, the SEA iteration operator is bounded to m occurrences. This can be addressed (1) with an approximation using COUNT aggregations or a lightweight automata presented as a single operator such as windowed UDF. (NG 3)
- Keyword: S[m]

### Negation: 
- A negation requires the absence of events e_n of the specified stream to fulfill the pattern. In contrast to a negated predicate, a negation requires the absence of the specified event type without necessarily referring to an attribute value of the event itself.
- Mapping: UDF (NG 3)

### Window: 
- The SEA window operator is a time-based predicate that defines the maximal time interval $$W = |ts_{e_2} - ts_{e_1}|$$ in which all event pairs $(e_{1},e_{2})$ of the pattern need to occur to form a match M. 
- Mapping: Sliding Windows with slide by tuple or Interval Join (duplicate free)
 

## NES PSL 
In the section, we briefly introduce NES PSL. First, we present the general structure of a pattern and an example pattern. 
Second, we describe keywords that differ from SQL in more detail.  
### General Structure

**PATTERN** NAME := <\pattern structure\>

**FROM**    <\streams\>

[**WHERE**  <\predicates\>]

**WITHIN** <\window specifications\>

[**SELECT** <\output specification\>]

**INTO**   <\list of sinks\>

### Example Pattern 
**PATTERN** test := ( A SEQ B SEQ C SEQ D )

**FROM** inputStream AS A , inputStream1 AS B , inputStream2 AS C , inputStream3 AS D

**WHERE** C.value == D.value && A.value > 45 && B.location_type == "park" && ... 

**WITHIN** 3 MINUTES

**SELECT** A.id, A.value

**INTO** MQTT(path,topic)

### Key Words 
- The **PATTERN** clause composes logical streams with the respective CEP operators, i.e., A SEQ B specifies the temporal dependencies that an event a of stream A (i.e., a time-stamped tuple) has to occur before an event b of stream B. 
- The **FROM** clause is equivalent to SQL, it is an addition of (NES) PSL, making renaming of involved streams simpler and SQL-compatible.
- THE **WHERE** and **SELECT** clauses are optional and equivalent to SQL. Selections are defined in the WHERE clause. Projection are defined in the SELECT clause.  
- The **INTO** clause takes a list of sinks.  
- The **WITHIN** clause contains the window specification. 

### Implementation Details: 
![PSL.png](..%2Fresources%2FPSL.png)

In order to incorporate the declarative PSL into NebulaStream, we use the parsing tool ANTLR as available from the dependencies of NES.
NES receives a user-provided query, e.g., via its UI and Rest Interface. Using an identifier, e.g., the keyword **PATTERN**, the string is identified as a pattern (and not a query) and transferred to the PSL Parser.
The PSL Parser is based on an ANTLR grammar that contains the general structure of the NebulsStream PSL, thus, provides syntactic validation of the query string.
Based on that grammar, ANTLR auto-generates the Lexer and the Parser classes in the respective programming language, i.e., for NebulaStream in C++.
The query string is handed over to the lexer that derives a stream of tokens from it. The stream of tokens is passed to the query parser that transforms the tokens into the Abstract Syntax Tree (AST).
The resulting AST is handed over to the **QueryPlanBuilder**, i.e., a translation module that traverses the AST and constructs the logical query plan.
To this end, the QueryPlanBuilder uses additionally auto-generated Listeners classes with enter and exit methods for each rule in the PSL grammar to obtain the operators and sources specified in the pattern.

# Proof of Concept
- [Parser Old Repository](https://github.com/nebulastream/nebulastream/tree/master/nes-coordinator/src/Parsers/NebulaPSL)
- [Tests Parser Old Repo](https://github.com/nebulastream/nebulastream/blob/master/nes-coordinator/tests/UnitTests/Services/PatternParsingServiceTest.cpp)
- [Bridging the Gap: Complex Event Processing on Stream Processing Systems](https://openproceedings.org/2024/conf/edbt/paper-114.pdf)

# Alternatives
- A1: Alternative parsing tools, but stick to one for the system seems reasonable.
- A2: Using an existing CEP PSL, which requires adaptions to fit the needs for the mapping and query syntax, e.g., allow for window parameters, specify sinks.

# (Optional) Sources and Further Reading
- [ANTLR4](https://www.antlr.org/)

