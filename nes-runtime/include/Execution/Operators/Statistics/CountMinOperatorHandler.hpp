/*
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#ifndef NES_NES_RUNTIME_SRC_EXECUTION_OPERATORS_STATISTICS_COUNTMINOPERATORHANDLER_HPP_
#define NES_NES_RUNTIME_SRC_EXECUTION_OPERATORS_STATISTICS_COUNTMINOPERATORHANDLER_HPP_

#include <Execution/Operators/Streaming/SliceAssigner.hpp>
#include <Identifiers.hpp>
#include <Runtime/Execution/OperatorHandler.hpp>
#include <Statistics/CountMin.hpp>
#include <Statistics/Interval.hpp>
#include <unordered_map>
#include <vector>

namespace NES {

class Schema;
using SchemaPtr = std::shared_ptr<Schema>;

namespace Runtime {

class BufferManager;
using BufferManagerPtr = std::shared_ptr<BufferManager>;

namespace MemoryLayouts {
class DynamicTupleBuffer;
}

namespace Execution::Operators {
class MultiOriginWatermarkProcessor;
using MultiOriginWatermarkProcessorPtr = std::unique_ptr<MultiOriginWatermarkProcessor>;
}// namespace Execution::Operators
}// namespace Runtime

namespace Experimental::Statistics {

/**
 * @brief the class that defines the state of the CountMinBuildOperator
 */
class CountMinOperatorHandler : public Runtime::Execution::OperatorHandler {
  public:

    /**
     * @param windowSize the windowSize over which the CountMin sketches are generated
     * @param slideFactor the slideFactor with which the sketches are generated
     * @param logicalSourceName the logicalSourceName from which the data originates
     * @param workerId the workerID from which the data originates
     * @param fieldName the name of the field over which we construct the sketch
     * @param depth the depth of the sketch
     * @param width the width of the sketch
     * @param schema the schema in which we store information about CountMin sketches
     * @param physicalSources a vector of physicalSources over which we create the sketches. Also needed for our MultiOriginWatermarkProcessors
     * @param allOriginIds a vector of the orginIds which is needed to initilize our MultiOriginWatermarkProcessors
     */
    CountMinOperatorHandler(uint64_t windowSize,
                            uint64_t slideFactor,
                            const std::string& logicalSourceName,
                            WorkerId workerId,
                            const std::string& fieldName,
                            uint64_t depth,
                            uint64_t width,
                            SchemaPtr schema,
                            std::vector<uint64_t> h3Seeds,
                            std::vector<std::pair<OriginId, std::string>>& allOriginIdsPhysicalSourceNames);

    /**
     * @brief the default destructor of the CountMinOperatorHandler
     */
    virtual ~CountMinOperatorHandler() = default;

    /**
     * @brief sets the bufferManager
     * @param bufferManager the bufferManager that we set
     */
    void setBufferManager(const Runtime::BufferManagerPtr& bufferManager);

    /**
     * @return returns a void pointer to the H3 seeds
     */
    void* getH3Seeds() const;

    void start(Runtime::Execution::PipelineExecutionContextPtr pipelineExecutionContext, uint32_t localStateVariableId) override;

    void stop(Runtime::QueryTerminationType terminationType,
              Runtime::Execution::PipelineExecutionContextPtr pipelineExecutionContext) override;

    /**
     * @brief either gets a countMin sketch described by the window interval that is determined by the ts or creates a new TupleBuffer that contains a
     * CountMin sketch and inserts it into the vector of all CountMin sketches being generated by the operator
     * @param physicalSourceName
     * @param ts the timestamp to determine the slice/window over which the sketch will be generated
     */
    Runtime::TupleBuffer getTupleBuffer(const std::string& physicalSourceName, uint64_t ts);

    /**
     * @param localWatermarkTs the watermark of a RecordBuffer
     * @param sequenceNumber the sequenceNumber retrieved from the execution context
     * @param originId the originId retrieved from the execution context
     * @return a vector of TupleBuffers that are finished processing and can be dispatched to the next operator in the pipeline
     */
    std::vector<Runtime::TupleBuffer> getFinishedCountMinSketches(uint64_t localWatermarkTs,
                                                                  uint64_t sequenceNumber,
                                                                  OriginId originId0);

  private:
    Runtime::Execution::Operators::SliceAssigner sliceAssigner;
    std::vector<Runtime::TupleBuffer> allCountMin;
    std::string logicalSourceName;
    WorkerId workerId;
    std::string fieldName;
    uint64_t depth;
    uint64_t width;
    const std::vector<uint64_t> h3Seeds;
    SchemaPtr schema;
    std::map<OriginId, std::string> allPhysicalSources;
    std::map<std::string, Runtime::Execution::Operators::MultiOriginWatermarkProcessorPtr> allWatermarkProcessors;
    Runtime::BufferManagerPtr bufferManager;

    /**
     * @brief This function initializes the fields of the buffer with starting values (important for observed tuples), which is
     * especially important for the text fields, as these need their respective childBuffer keys (uint32_t)
     * @param buffer the buffer holding the CountMinSketch
     * @param interval the interval over which the sketch is constructed
     * @param physicalSourceName the physicalSourceName over which the sketch is constructed for which we write the meta data
     */
    Runtime::TupleBuffer writeMetaData(NES::Runtime::TupleBuffer buffer,
                                              const Interval& interval,
                                              const std::string& physicalSourceName);
};
}// namespace Experimental::Statistics
}// namespace NES

#endif//NES_NES_RUNTIME_SRC_EXECUTION_OPERATORS_STATISTICS_COUNTMINOPERATORHANDLER_HPP_
