/*
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#ifndef NES_RUNTIME_INCLUDE_RUNTIME_QUERYMANAGER_HPP_
#define NES_RUNTIME_INCLUDE_RUNTIME_QUERYMANAGER_HPP_

#include <chrono>
#include <condition_variable>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <unordered_map>
#include <unordered_set>
#include <Identifiers/Identifiers.hpp>
#include <Listeners/AbstractQueryStatusListener.hpp>
#include <Listeners/QueryLog.hpp>
#include <Runtime/BufferManager.hpp>
#include <Runtime/Execution/ExecutablePipeline.hpp>
#include <Runtime/Execution/ExecutableQueryPlan.hpp>
#include <Runtime/Execution/QueryStatus.hpp>
#include <Runtime/QueryStatistics.hpp>
#include <Runtime/Reconfigurable.hpp>
#include <Runtime/ReconfigurationMessage.hpp>
#include <Runtime/RuntimeForwardRefs.hpp>
#include <Runtime/Task.hpp>
#include <Sources/DataSource.hpp>
#include <Util/AtomicCounter.hpp>
#include <Util/ThreadBarrier.hpp>
#include <Util/VirtualEnableSharedFromThis.hpp>
#include <Util/libcuckoo/cuckoohash_map.hh>

#ifdef ENABLE_PAPI_PROFILER
#    include <Runtime/Profiler/PAPIProfiler.hpp>
#endif

namespace NES::Runtime
{
using ThreadPoolPtr = std::shared_ptr<class ThreadPool>; /// TODO consider moving this atomic in c++20
using AsyncTaskExecutorPtr = std::shared_ptr<class AsyncTaskExecutor>;

class QueryManager : public NES::detail::virtual_enable_shared_from_this<QueryManager, false>, public Reconfigurable
{
public:
    using inherited0 = NES::detail::virtual_enable_shared_from_this<QueryManager, false>;

    using inherited1 = Reconfigurable;
    enum class QueryManagerStatus : uint8_t
    {
        Created,
        Running,
        Stopped,
        Destroyed,
        Failed
    };

    QueryManager() = delete;
    QueryManager(const QueryManager&) = delete;
    QueryManager& operator=(const QueryManager&) = delete;

    explicit QueryManager(
        std::shared_ptr<AbstractQueryStatusListener> queryStatusListener,
        std::vector<BufferManagerPtr> bufferManagers,
        WorkerId nodeEngineId,
        uint16_t numThreads,
        uint64_t numberOfBuffersPerEpoch,
        std::vector<uint64_t> workerToCoreMapping = {});

    ~QueryManager() NES_NOEXCEPT(false) override;

    /// Register a query by extracting sources, windows and sink and add them to respective map
    bool registerQuery(const Execution::ExecutableQueryPlanPtr& qep);

    /// Unregister a query by extracting sources, windows and sink and remove them from respective map
    bool unregisterQuery(const Execution::ExecutableQueryPlanPtr& qep);

    /// Process task from task queue
    ExecutionResult processNextTask(bool ThreadPoolRunning, WorkerContext& workerContext);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each buffer generated by the window trigger
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the pipeline stage that will be executed next
     * @param id of the queue where to put the task (only necessary if multiple queues are used, default is 0)
     */
    void addWorkForNextPipeline(TupleBuffer& buffer, Execution::SuccessorExecutablePipeline executable, uint32_t queueId = 0);

    void postReconfigurationCallback(ReconfigurationMessage& task) override;

    void reconfigure(ReconfigurationMessage&, WorkerContext& context) override;

    [[nodiscard]] Execution::QueryStatus getQueryStatus(QueryId id) const;

    [[nodiscard]] bool canTriggerEndOfStream(DataSourcePtr source, Runtime::QueryTerminationType);

    [[nodiscard]] bool startQuery(const Execution::ExecutableQueryPlanPtr& qep);
    [[nodiscard]] bool stopQuery(
        const Execution::ExecutableQueryPlanPtr& qep,
        Runtime::QueryTerminationType terminationType = Runtime::QueryTerminationType::HardStop);
    bool failQuery(const Execution::ExecutableQueryPlanPtr& qep);

    /// notify all waiting threads in getWork() to wake up and finish up
    void poisonWorkers();

    /// reset query manager. After this call, it wont be possible to use the query manager.
    void destroy();

    /**
     * @brief this methods adds a reconfiguration task on the worker queue
     * @return true if the reconfiguration task was added correctly on the worker queue
     * N.B.: this does not not mean that the reconfiguration took place but it means that it
     * was scheduled to be executed!
     * @param queryId: queryId
     * @param reconfigurationDescriptor: what to do
     * @param blocking: whether to block until the reconfiguration is done. Mind this parameter because it blocks!
     */
    bool addReconfigurationMessage(QueryId queryId, const ReconfigurationMessage& reconfigurationMessage, bool blocking = false);

    /// Gives the first buffer manager
    [[nodiscard]] BufferManagerPtr getBufferManager() { return *bufferManagers.begin(); }

private:
    /**
     * @brief this methods adds a reconfiguration task on the worker queue
     * @return true if the reconfiguration task was added correctly on the worker queue
     * N.B.: this does not not mean that the reconfiguration took place but it means that it
     * was scheduled to be executed!
     * @param queryId: the local QEP to reconfigure
     * @param buffer: a tuple buffer storing the reconfiguration message
     * @param blocking: whether to block until the reconfiguration is done. Mind this parameter because it blocks!
     */
    bool addReconfigurationMessage(QueryId queryId, TupleBuffer&& buffer, bool blocking = false);

public:
    /// Informs the query manager that a task has failed
    void notifyTaskFailure(Execution::SuccessorExecutablePipeline pipeline, const std::string& faultReason);

    /// Informs the query manager that a source has failed
    void notifySourceFailure(DataSourcePtr source, const Exception& errorMessage);

    /// Informs the query manager about a status change in a query plan
    void notifyQueryStatusChange(const Execution::ExecutableQueryPlanPtr& qep, Execution::QueryStatus newStatus);

    /// Introduces end of stream to all QEPs connected to this source
    bool addEndOfStream(DataSourcePtr source, Runtime::QueryTerminationType graceful = Runtime::QueryTerminationType::Graceful);

    [[nodiscard]] uint64_t getNumberOfWorkerThreads();

    void notifySourceCompletion(DataSourcePtr source, QueryTerminationType terminationType);

    void notifyPipelineCompletion(QueryId queryId, Execution::ExecutablePipelinePtr pipeline, QueryTerminationType terminationType);

    void notifySinkCompletion(QueryId queryId, DataSinkPtr sink, QueryTerminationType terminationType);

private:
    friend class ThreadPool;
    friend class NodeEngine;

    bool startThreadPool(uint64_t numberOfBuffersPerWorker);

    folly::MPMCQueue<Task> taskQueue;

protected:
    /// Finalize task execution by: 1.) update statistics (number of processed tuples and tasks) 2.) release input buffer (give back to the buffer manager)
    void completedWork(Task& task, WorkerContext& workerContext);

    void updateStatistics(const Task& task, QueryId queryId, PipelineId pipelineId, WorkerContext& workerContext);

    /// Executes cleaning up logic on the task queue
    ExecutionResult terminateLoop(WorkerContext&);

    bool addSoftEndOfStream(DataSourcePtr source);
    bool addHardEndOfStream(DataSourcePtr source);
    bool addFailureEndOfStream(DataSourcePtr source);

    uint64_t getNextTaskId();

protected:
    WorkerId nodeEngineId;
    std::atomic_uint64_t taskIdCounter = 0;
    std::vector<BufferManagerPtr> bufferManagers;

    uint16_t numThreads;

    /// worker threads running compute tasks
    ThreadPoolPtr threadPool{nullptr};

    /// worker thread for async maintenance task, e.g., fail queryIdAndCatalogEntryMapping
    AsyncTaskExecutorPtr asyncTaskExecutor;

    std::unordered_map<QueryId, Execution::ExecutableQueryPlanPtr> runningQEPs;

    /// TODO:check if it would be better to put it in the thread context
    mutable std::mutex statisticsMutex;
    cuckoohash_map<QueryId, QueryStatisticsPtr> queryToStatisticsMap;

    mutable std::mutex reconfigurationMutex;

    std::vector<uint64_t> workerToCoreMapping;
    mutable std::recursive_mutex queryMutex;

    std::atomic<QueryManagerStatus> queryManagerStatus{QueryManagerStatus::Created};

    std::vector<AtomicCounter<uint64_t>> tempCounterTasksCompleted;

    std::shared_ptr<AbstractQueryStatusListener> queryStatusListener;

    std::unordered_map<OperatorId, std::vector<Execution::ExecutableQueryPlanPtr>> sourceToQEPMapping;

    uint64_t numberOfBuffersPerEpoch;

#ifdef ENABLE_PAPI_PROFILER
    std::vector<Profiler::PapiCpuProfilerPtr> cpuProfilers;
#endif
};
using QueryManagerPtr = std::shared_ptr<QueryManager>;

} /// namespace NES::Runtime
#endif /// NES_RUNTIME_INCLUDE_RUNTIME_QUERYMANAGER_HPP_
