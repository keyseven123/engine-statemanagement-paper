
// Generated from /home/rudi/dima/nebulastream-public/nes-nebuli/parser/NebulaSQL.g4 by ANTLR 4.13.2


#include "NebulaSQLListener.h"

#include "NebulaSQLParser.h"


#include <Util/DisableWarningsPragma.hpp>
DISABLE_WARNING_PUSH
DISABLE_WARNING(-Wlogical - op - parentheses)
DISABLE_WARNING(-Wunused - parameter)


using namespace antlrcpp;

using namespace antlr4;

namespace
{

struct NebulaSQLParserStaticData final
{
    NebulaSQLParserStaticData(
        std::vector<std::string> ruleNames, std::vector<std::string> literalNames, std::vector<std::string> symbolicNames)
        : ruleNames(std::move(ruleNames))
        , literalNames(std::move(literalNames))
        , symbolicNames(std::move(symbolicNames))
        , vocabulary(this->literalNames, this->symbolicNames)
    {
    }

    NebulaSQLParserStaticData(const NebulaSQLParserStaticData&) = delete;
    NebulaSQLParserStaticData(NebulaSQLParserStaticData&&) = delete;
    NebulaSQLParserStaticData& operator=(const NebulaSQLParserStaticData&) = delete;
    NebulaSQLParserStaticData& operator=(NebulaSQLParserStaticData&&) = delete;

    std::vector<antlr4::dfa::DFA> decisionToDFA;
    antlr4::atn::PredictionContextCache sharedContextCache;
    const std::vector<std::string> ruleNames;
    const std::vector<std::string> literalNames;
    const std::vector<std::string> symbolicNames;
    const antlr4::dfa::Vocabulary vocabulary;
    antlr4::atn::SerializedATNView serializedATN;
    std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag nebulasqlParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
    std::unique_ptr<NebulaSQLParserStaticData>
        nebulasqlParserStaticData = nullptr;

void nebulasqlParserInitialize()
{
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    if (nebulasqlParserStaticData != nullptr)
    {
        return;
    }
#else
    assert(nebulasqlParserStaticData == nullptr);
#endif
    auto staticData = std::make_unique<NebulaSQLParserStaticData>(
        std::vector<std::string>{
            "singleStatement",
            "statement",
            "query",
            "queryOrganization",
            "queryTerm",
            "queryPrimary",
            "querySpecification",
            "fromClause",
            "relation",
            "joinRelation",
            "joinType",
            "joinCriteria",
            "relationPrimary",
            "functionTable",
            "fromStatement",
            "fromStatementBody",
            "selectClause",
            "whereClause",
            "havingClause",
            "inlineTable",
            "tableAlias",
            "multipartIdentifierList",
            "multipartIdentifier",
            "namedExpression",
            "identifier",
            "strictIdentifier",
            "quotedIdentifier",
            "identifierList",
            "identifierSeq",
            "errorCapturingIdentifier",
            "errorCapturingIdentifierExtra",
            "namedExpressionSeq",
            "expression",
            "booleanExpression",
            "windowedAggregationClause",
            "aggregationClause",
            "groupingSet",
            "windowClause",
            "watermarkClause",
            "watermarkParameters",
            "windowSpec",
            "timeWindow",
            "countWindow",
            "conditionWindow",
            "conditionParameter",
            "thresholdMinSizeParameter",
            "sizeParameter",
            "advancebyParameter",
            "timeUnit",
            "timestampParameter",
            "functionName",
            "sinkClause",
            "sinkType",
            "nullNotnull",
            "streamName",
            "sinkTypeFile",
            "sinkTypePrint",
            "fileFormat",
            "sortItem",
            "predicate",
            "valueExpression",
            "comparisonOperator",
            "hint",
            "hintStatement",
            "primaryExpression",
            "qualifiedName",
            "number",
            "constant",
            "booleanValue",
            "strictNonReserved",
            "ansiNonReserved",
            "nonReserved"},
        std::vector<std::string>{
            "",
            "';'",
            "','",
            "'('",
            "')'",
            "'.'",
            "'/*+'",
            "'*/'",
            "",
            "",
            "",
            "'ANY'",
            "",
            "",
            "'AT'",
            "",
            "",
            "'COMMENT'",
            "'CUBE'",
            "'DELETE'",
            "",
            "'DISTINCT'",
            "'DIV'",
            "'DROP'",
            "'ELSE'",
            "'END'",
            "'ESCAPE'",
            "'EXISTS'",
            "'FALSE'",
            "'FIRST'",
            "'FOR'",
            "",
            "'FULL'",
            "",
            "'GROUPING'",
            "",
            "'IF'",
            "",
            "",
            "",
            "",
            "",
            "",
            "'LAST'",
            "'LEFT'",
            "'LIKE'",
            "",
            "'LIST'",
            "",
            "'NATURAL'",
            "",
            "'NULL'",
            "'NULLS'",
            "'OF'",
            "",
            "",
            "",
            "'QUERY'",
            "'RECOVER'",
            "'RIGHT'",
            "",
            "'ROLLUP'",
            "",
            "'SETS'",
            "'SOME'",
            "'START'",
            "'TABLE'",
            "'TO'",
            "'TRUE'",
            "'TYPE'",
            "",
            "'UNKNOWN'",
            "'USE'",
            "'USING'",
            "'VALUES'",
            "'WHEN'",
            "",
            "",
            "'WITH'",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "'File'",
            "'Print'",
            "",
            "'CSV_FORMAT'",
            "'AT_MOST_ONCE'",
            "'AT_LEAST_ONCE'",
            "",
            "",
            "'<=>'",
            "'<>'",
            "'!='",
            "'<'",
            "",
            "'>'",
            "",
            "'+'",
            "'-'",
            "'*'",
            "'/'",
            "'%'",
            "'~'",
            "'&'",
            "'|'",
            "'||'",
            "'^'"},
        std::vector<std::string>{
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "BACKQUOTED_IDENTIFIER",
            "ALL",
            "AND",
            "ANY",
            "AS",
            "ASC",
            "AT",
            "BETWEEN",
            "BY",
            "COMMENT",
            "CUBE",
            "DELETE",
            "DESC",
            "DISTINCT",
            "DIV",
            "DROP",
            "ELSE",
            "END",
            "ESCAPE",
            "EXISTS",
            "FALSE",
            "FIRST",
            "FOR",
            "FROM",
            "FULL",
            "GROUP",
            "GROUPING",
            "HAVING",
            "IF",
            "IN",
            "INNER",
            "INSERT",
            "INTO",
            "IS",
            "JOIN",
            "LAST",
            "LEFT",
            "LIKE",
            "LIMIT",
            "LIST",
            "MERGE",
            "NATURAL",
            "NOT",
            "NULLTOKEN",
            "NULLS",
            "OF",
            "ON",
            "OR",
            "ORDER",
            "QUERY",
            "RECOVER",
            "RIGHT",
            "RLIKE",
            "ROLLUP",
            "SELECT",
            "SETS",
            "SOME",
            "START",
            "TABLE",
            "TO",
            "TRUE",
            "TYPE",
            "UNION",
            "UNKNOWN",
            "USE",
            "USING",
            "VALUES",
            "WHEN",
            "WHERE",
            "WINDOW",
            "WITH",
            "TUMBLING",
            "SLIDING",
            "THRESHOLD",
            "SIZE",
            "ADVANCE",
            "MS",
            "SEC",
            "MIN",
            "HOUR",
            "DAY",
            "MAX",
            "AVG",
            "SUM",
            "COUNT",
            "MEDIAN",
            "WATERMARK",
            "OFFSET",
            "FILE",
            "PRINT",
            "LOCALHOST",
            "CSV_FORMAT",
            "AT_MOST_ONCE",
            "AT_LEAST_ONCE",
            "BOOLEAN_VALUE",
            "EQ",
            "NSEQ",
            "NEQ",
            "NEQJ",
            "LT",
            "LTE",
            "GT",
            "GTE",
            "PLUS",
            "MINUS",
            "ASTERISK",
            "SLASH",
            "PERCENT",
            "TILDE",
            "AMPERSAND",
            "PIPE",
            "CONCAT_PIPE",
            "HAT",
            "STRING",
            "BIGINT_LITERAL",
            "SMALLINT_LITERAL",
            "TINYINT_LITERAL",
            "INTEGER_VALUE",
            "EXPONENT_VALUE",
            "DECIMAL_VALUE",
            "FLOAT_LITERAL",
            "DOUBLE_LITERAL",
            "BIGDECIMAL_LITERAL",
            "IDENTIFIER",
            "SIMPLE_COMMENT",
            "BRACKETED_COMMENT",
            "WS",
            "FOUR_OCTETS",
            "OCTET",
            "UNRECOGNIZED"});
    static const int32_t serializedATNSegment[]
        = {4,   1,   137, 871, 2,   0,   7,   0,   2,   1,   7,   1,   2,   2,   7,   2,   2,   3,   7,   3,   2,   4,   7,   4,   2,   5,
           7,   5,   2,   6,   7,   6,   2,   7,   7,   7,   2,   8,   7,   8,   2,   9,   7,   9,   2,   10,  7,   10,  2,   11,  7,   11,
           2,   12,  7,   12,  2,   13,  7,   13,  2,   14,  7,   14,  2,   15,  7,   15,  2,   16,  7,   16,  2,   17,  7,   17,  2,   18,
           7,   18,  2,   19,  7,   19,  2,   20,  7,   20,  2,   21,  7,   21,  2,   22,  7,   22,  2,   23,  7,   23,  2,   24,  7,   24,
           2,   25,  7,   25,  2,   26,  7,   26,  2,   27,  7,   27,  2,   28,  7,   28,  2,   29,  7,   29,  2,   30,  7,   30,  2,   31,
           7,   31,  2,   32,  7,   32,  2,   33,  7,   33,  2,   34,  7,   34,  2,   35,  7,   35,  2,   36,  7,   36,  2,   37,  7,   37,
           2,   38,  7,   38,  2,   39,  7,   39,  2,   40,  7,   40,  2,   41,  7,   41,  2,   42,  7,   42,  2,   43,  7,   43,  2,   44,
           7,   44,  2,   45,  7,   45,  2,   46,  7,   46,  2,   47,  7,   47,  2,   48,  7,   48,  2,   49,  7,   49,  2,   50,  7,   50,
           2,   51,  7,   51,  2,   52,  7,   52,  2,   53,  7,   53,  2,   54,  7,   54,  2,   55,  7,   55,  2,   56,  7,   56,  2,   57,
           7,   57,  2,   58,  7,   58,  2,   59,  7,   59,  2,   60,  7,   60,  2,   61,  7,   61,  2,   62,  7,   62,  2,   63,  7,   63,
           2,   64,  7,   64,  2,   65,  7,   65,  2,   66,  7,   66,  2,   67,  7,   67,  2,   68,  7,   68,  2,   69,  7,   69,  2,   70,
           7,   70,  2,   71,  7,   71,  1,   0,   1,   0,   5,   0,   147, 8,   0,   10,  0,   12,  0,   150, 9,   0,   1,   0,   1,   0,
           1,   1,   1,   1,   1,   2,   1,   2,   1,   2,   1,   3,   1,   3,   1,   3,   1,   3,   1,   3,   5,   3,   164, 8,   3,   10,
           3,   12,  3,   167, 9,   3,   3,   3,   169, 8,   3,   1,   3,   1,   3,   1,   3,   3,   3,   174, 8,   3,   3,   3,   176, 8,
           3,   1,   3,   1,   3,   3,   3,   180, 8,   3,   1,   4,   1,   4,   1,   4,   1,   4,   1,   4,   1,   4,   5,   4,   188, 8,
           4,   10,  4,   12,  4,   191, 9,   4,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,
           3,   5,   202, 8,   5,   1,   6,   1,   6,   1,   6,   3,   6,   207, 8,   6,   1,   6,   3,   6,   210, 8,   6,   1,   6,   3,
           6,   213, 8,   6,   1,   6,   3,   6,   216, 8,   6,   1,   7,   1,   7,   1,   7,   1,   7,   5,   7,   222, 8,   7,   10,  7,
           12,  7,   225, 9,   7,   1,   8,   1,   8,   5,   8,   229, 8,   8,   10,  8,   12,  8,   232, 9,   8,   1,   9,   1,   9,   1,
           9,   1,   9,   3,   9,   238, 8,   9,   1,   9,   1,   9,   1,   9,   1,   9,   1,   9,   3,   9,   245, 8,   9,   1,   10,  3,
           10,  248, 8,   10,  1,   11,  1,   11,  1,   11,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,
           1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  3,   12,  268, 8,   12,  1,   13,  1,   13,  1,   13,  1,
           13,  1,   13,  5,   13,  275, 8,   13,  10,  13,  12,  13,  278, 9,   13,  3,   13,  280, 8,   13,  1,   13,  1,   13,  1,   13,
           1,   14,  1,   14,  4,   14,  287, 8,   14,  11,  14,  12,  14,  288, 1,   15,  1,   15,  3,   15,  293, 8,   15,  1,   15,  3,
           15,  296, 8,   15,  1,   16,  1,   16,  5,   16,  300, 8,   16,  10,  16,  12,  16,  303, 9,   16,  1,   16,  1,   16,  1,   17,
           1,   17,  1,   17,  1,   18,  1,   18,  1,   18,  1,   19,  1,   19,  1,   19,  1,   19,  5,   19,  317, 8,   19,  10,  19,  12,
           19,  320, 9,   19,  1,   19,  1,   19,  1,   20,  3,   20,  325, 8,   20,  1,   20,  1,   20,  3,   20,  329, 8,   20,  3,   20,
           331, 8,   20,  1,   21,  1,   21,  1,   21,  5,   21,  336, 8,   21,  10,  21,  12,  21,  339, 9,   21,  1,   22,  1,   22,  1,
           22,  5,   22,  344, 8,   22,  10,  22,  12,  22,  347, 9,   22,  1,   23,  1,   23,  3,   23,  351, 8,   23,  1,   23,  1,   23,
           3,   23,  355, 8,   23,  3,   23,  357, 8,   23,  1,   24,  1,   24,  1,   24,  3,   24,  362, 8,   24,  1,   25,  1,   25,  1,
           25,  1,   25,  1,   25,  1,   25,  3,   25,  370, 8,   25,  1,   26,  1,   26,  1,   27,  1,   27,  1,   27,  1,   27,  1,   28,
           1,   28,  1,   28,  5,   28,  381, 8,   28,  10,  28,  12,  28,  384, 9,   28,  1,   29,  1,   29,  1,   29,  1,   30,  1,   30,
           4,   30,  391, 8,   30,  11,  30,  12,  30,  392, 1,   30,  3,   30,  396, 8,   30,  1,   31,  1,   31,  1,   31,  5,   31,  401,
           8,   31,  10,  31,  12,  31,  404, 9,   31,  1,   32,  1,   32,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,
           33,  1,   33,  1,   33,  1,   33,  3,   33,  418, 8,   33,  3,   33,  420, 8,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,
           33,  1,   33,  5,   33,  428, 8,   33,  10,  33,  12,  33,  431, 9,   33,  1,   34,  3,   34,  434, 8,   34,  1,   34,  1,   34,
           3,   34,  438, 8,   34,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  5,   35,  445, 8,   35,  10,  35,  12,  35,  448, 9,
           35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  5,   35,  460, 8,   35,
           10,  35,  12,  35,  463, 9,   35,  1,   35,  1,   35,  3,   35,  467, 8,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,
           1,   35,  1,   35,  1,   35,  5,   35,  477, 8,   35,  10,  35,  12,  35,  480, 9,   35,  1,   35,  1,   35,  3,   35,  484, 8,
           35,  1,   36,  1,   36,  1,   36,  1,   36,  5,   36,  490, 8,   36,  10,  36,  12,  36,  493, 9,   36,  3,   36,  495, 8,   36,
           1,   36,  1,   36,  3,   36,  499, 8,   36,  1,   37,  1,   37,  1,   37,  1,   38,  1,   38,  1,   38,  1,   38,  1,   38,  1,
           39,  1,   39,  1,   39,  1,   39,  1,   39,  1,   40,  1,   40,  1,   40,  3,   40,  517, 8,   40,  1,   41,  1,   41,  1,   41,
           1,   41,  1,   41,  3,   41,  524, 8,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  3,
           41,  534, 8,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  3,   41,  541, 8,   41,  1,   42,  1,   42,  1,   42,  1,
           42,  1,   42,  1,   43,  1,   43,  1,   43,  1,   43,  1,   43,  3,   43,  553, 8,   43,  1,   43,  1,   43,  1,   44,  1,   44,
           1,   45,  1,   45,  1,   46,  1,   46,  1,   46,  1,   46,  1,   47,  1,   47,  1,   47,  1,   47,  1,   47,  1,   48,  1,   48,
           1,   49,  1,   49,  1,   50,  1,   50,  1,   51,  1,   51,  1,   51,  3,   51,  579, 8,   51,  1,   52,  1,   52,  3,   52,  583,
           8,   52,  1,   53,  3,   53,  586, 8,   53,  1,   53,  1,   53,  1,   54,  1,   54,  1,   55,  1,   55,  1,   56,  1,   56,  1,
           57,  1,   57,  1,   58,  1,   58,  3,   58,  600, 8,   58,  1,   58,  1,   58,  3,   58,  604, 8,   58,  1,   59,  3,   59,  607,
           8,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  3,   59,  615, 8,   59,  1,   59,  1,   59,  1,   59,  1,
           59,  1,   59,  5,   59,  622, 8,   59,  10,  59,  12,  59,  625, 9,   59,  1,   59,  1,   59,  1,   59,  3,   59,  630, 8,   59,
           1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  3,   59,  638, 8,   59,  1,   59,  1,   59,  1,   59,  3,   59,  643,
           8,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  1,   59,  5,   59,  653, 8,   59,  10,  59,  12,
           59,  656, 9,   59,  1,   59,  1,   59,  3,   59,  660, 8,   59,  1,   59,  3,   59,  663, 8,   59,  1,   59,  1,   59,  1,   59,
           1,   59,  3,   59,  669, 8,   59,  1,   59,  1,   59,  1,   59,  1,   59,  3,   59,  675, 8,   59,  1,   59,  1,   59,  1,   59,
           3,   59,  680, 8,   59,  1,   59,  1,   59,  1,   59,  3,   59,  685, 8,   59,  1,   60,  1,   60,  1,   60,  1,   60,  3,   60,
           691, 8,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,
           60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  5,   60,  712, 8,   60,  10,  60,  12,  60,  715, 9,
           60,  1,   61,  1,   61,  1,   62,  1,   62,  1,   62,  3,   62,  722, 8,   62,  1,   62,  5,   62,  725, 8,   62,  10,  62,  12,
           62,  728, 9,   62,  1,   62,  1,   62,  1,   63,  1,   63,  1,   63,  1,   63,  1,   63,  1,   63,  5,   63,  738, 8,   63,  10,
           63,  12,  63,  741, 9,   63,  1,   63,  1,   63,  3,   63,  745, 8,   63,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,
           64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  4,   64,  761, 8,   64,  11,  64,  12,  64,
           762, 1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  5,   64,  772, 8,   64,  10,  64,  12,  64,  775, 9,
           64,  3,   64,  777, 8,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  1,   64,  3,   64,  787, 8,
           64,  1,   64,  1,   64,  1,   64,  5,   64,  792, 8,   64,  10,  64,  12,  64,  795, 9,   64,  1,   65,  1,   65,  1,   65,  5,
           65,  800, 8,   65,  10,  65,  12,  65,  803, 9,   65,  1,   66,  1,   66,  3,   66,  807, 8,   66,  1,   66,  1,   66,  1,   66,
           3,   66,  812, 8,   66,  1,   66,  1,   66,  1,   66,  3,   66,  817, 8,   66,  1,   66,  1,   66,  3,   66,  821, 8,   66,  1,
           66,  1,   66,  3,   66,  825, 8,   66,  1,   66,  1,   66,  3,   66,  829, 8,   66,  1,   66,  1,   66,  3,   66,  833, 8,   66,
           1,   66,  1,   66,  3,   66,  837, 8,   66,  1,   66,  1,   66,  3,   66,  841, 8,   66,  1,   66,  1,   66,  3,   66,  845, 8,
           66,  1,   66,  3,   66,  848, 8,   66,  1,   67,  1,   67,  1,   67,  1,   67,  1,   67,  1,   67,  1,   67,  4,   67,  857, 8,
           67,  11,  67,  12,  67,  858, 3,   67,  861, 8,   67,  1,   68,  1,   68,  1,   69,  1,   69,  1,   70,  1,   70,  1,   71,  1,
           71,  1,   71,  0,   4,   8,   66,  120, 128, 72,  0,   2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,  30,
           32,  34,  36,  38,  40,  42,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,  80,  82,
           84,  86,  88,  90,  92,  94,  96,  98,  100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
           136, 138, 140, 142, 0,   15,  1,   0,   84,  88,  2,   0,   86,  86,  89,  93,  2,   0,   13,  13,  20,  20,  2,   0,   29,  29,
           43,  43,  3,   0,   9,   9,   11,  11,  64,  64,  3,   0,   28,  28,  68,  68,  71,  71,  2,   0,   111, 112, 116, 116, 2,   0,
           22,  22,  113, 115, 2,   0,   111, 112, 119, 119, 1,   0,   103, 110, 1,   0,   126, 127, 2,   0,   28,  28,  68,  68,  9,   0,
           32,  32,  38,  38,  42,  42,  44,  44,  49,  49,  54,  54,  59,  59,  70,  70,  73,  73,  17,  0,   13,  16,  18,  20,  22,  23,
           27,  27,  29,  29,  34,  34,  39,  39,  43,  43,  45,  46,  48,  48,  52,  52,  57,  57,  60,  61,  63,  63,  68,  69,  74,  74,
           77,  77,  17,  0,   9,   16,  18,  23,  26,  29,  31,  31,  33,  35,  37,  37,  39,  41,  43,  43,  45,  46,  48,  48,  50,  52,
           55,  57,  60,  64,  66,  66,  68,  69,  74,  74,  76,  78,  940, 0,   144, 1,   0,   0,   0,   2,   153, 1,   0,   0,   0,   4,
           155, 1,   0,   0,   0,   6,   168, 1,   0,   0,   0,   8,   181, 1,   0,   0,   0,   10,  201, 1,   0,   0,   0,   12,  203, 1,
           0,   0,   0,   14,  217, 1,   0,   0,   0,   16,  226, 1,   0,   0,   0,   18,  244, 1,   0,   0,   0,   20,  247, 1,   0,   0,
           0,   22,  249, 1,   0,   0,   0,   24,  267, 1,   0,   0,   0,   26,  269, 1,   0,   0,   0,   28,  284, 1,   0,   0,   0,   30,
           290, 1,   0,   0,   0,   32,  297, 1,   0,   0,   0,   34,  306, 1,   0,   0,   0,   36,  309, 1,   0,   0,   0,   38,  312, 1,
           0,   0,   0,   40,  330, 1,   0,   0,   0,   42,  332, 1,   0,   0,   0,   44,  340, 1,   0,   0,   0,   46,  348, 1,   0,   0,
           0,   48,  361, 1,   0,   0,   0,   50,  369, 1,   0,   0,   0,   52,  371, 1,   0,   0,   0,   54,  373, 1,   0,   0,   0,   56,
           377, 1,   0,   0,   0,   58,  385, 1,   0,   0,   0,   60,  395, 1,   0,   0,   0,   62,  397, 1,   0,   0,   0,   64,  405, 1,
           0,   0,   0,   66,  419, 1,   0,   0,   0,   68,  433, 1,   0,   0,   0,   70,  483, 1,   0,   0,   0,   72,  498, 1,   0,   0,
           0,   74,  500, 1,   0,   0,   0,   76,  503, 1,   0,   0,   0,   78,  508, 1,   0,   0,   0,   80,  516, 1,   0,   0,   0,   82,
           540, 1,   0,   0,   0,   84,  542, 1,   0,   0,   0,   86,  547, 1,   0,   0,   0,   88,  556, 1,   0,   0,   0,   90,  558, 1,
           0,   0,   0,   92,  560, 1,   0,   0,   0,   94,  564, 1,   0,   0,   0,   96,  569, 1,   0,   0,   0,   98,  571, 1,   0,   0,
           0,   100, 573, 1,   0,   0,   0,   102, 575, 1,   0,   0,   0,   104, 582, 1,   0,   0,   0,   106, 585, 1,   0,   0,   0,   108,
           589, 1,   0,   0,   0,   110, 591, 1,   0,   0,   0,   112, 593, 1,   0,   0,   0,   114, 595, 1,   0,   0,   0,   116, 597, 1,
           0,   0,   0,   118, 684, 1,   0,   0,   0,   120, 690, 1,   0,   0,   0,   122, 716, 1,   0,   0,   0,   124, 718, 1,   0,   0,
           0,   126, 744, 1,   0,   0,   0,   128, 786, 1,   0,   0,   0,   130, 796, 1,   0,   0,   0,   132, 847, 1,   0,   0,   0,   134,
           860, 1,   0,   0,   0,   136, 862, 1,   0,   0,   0,   138, 864, 1,   0,   0,   0,   140, 866, 1,   0,   0,   0,   142, 868, 1,
           0,   0,   0,   144, 148, 3,   2,   1,   0,   145, 147, 5,   1,   0,   0,   146, 145, 1,   0,   0,   0,   147, 150, 1,   0,   0,
           0,   148, 146, 1,   0,   0,   0,   148, 149, 1,   0,   0,   0,   149, 151, 1,   0,   0,   0,   150, 148, 1,   0,   0,   0,   151,
           152, 5,   0,   0,   1,   152, 1,   1,   0,   0,   0,   153, 154, 3,   4,   2,   0,   154, 3,   1,   0,   0,   0,   155, 156, 3,
           8,   4,   0,   156, 157, 3,   6,   3,   0,   157, 5,   1,   0,   0,   0,   158, 159, 5,   56,  0,   0,   159, 160, 5,   16,  0,
           0,   160, 165, 3,   116, 58,  0,   161, 162, 5,   2,   0,   0,   162, 164, 3,   116, 58,  0,   163, 161, 1,   0,   0,   0,   164,
           167, 1,   0,   0,   0,   165, 163, 1,   0,   0,   0,   165, 166, 1,   0,   0,   0,   166, 169, 1,   0,   0,   0,   167, 165, 1,
           0,   0,   0,   168, 158, 1,   0,   0,   0,   168, 169, 1,   0,   0,   0,   169, 175, 1,   0,   0,   0,   170, 173, 5,   46,  0,
           0,   171, 174, 5,   9,   0,   0,   172, 174, 5,   125, 0,   0,   173, 171, 1,   0,   0,   0,   173, 172, 1,   0,   0,   0,   174,
           176, 1,   0,   0,   0,   175, 170, 1,   0,   0,   0,   175, 176, 1,   0,   0,   0,   176, 179, 1,   0,   0,   0,   177, 178, 5,
           95,  0,   0,   178, 180, 5,   125, 0,   0,   179, 177, 1,   0,   0,   0,   179, 180, 1,   0,   0,   0,   180, 7,   1,   0,   0,
           0,   181, 182, 6,   4,   -1,  0,   182, 183, 3,   10,  5,   0,   183, 189, 1,   0,   0,   0,   184, 185, 10,  1,   0,   0,   185,
           186, 5,   70,  0,   0,   186, 188, 3,   8,   4,   2,   187, 184, 1,   0,   0,   0,   188, 191, 1,   0,   0,   0,   189, 187, 1,
           0,   0,   0,   189, 190, 1,   0,   0,   0,   190, 9,   1,   0,   0,   0,   191, 189, 1,   0,   0,   0,   192, 202, 3,   12,  6,
           0,   193, 202, 3,   28,  14,  0,   194, 195, 5,   66,  0,   0,   195, 202, 3,   44,  22,  0,   196, 202, 3,   38,  19,  0,   197,
           198, 5,   3,   0,   0,   198, 199, 3,   4,   2,   0,   199, 200, 5,   4,   0,   0,   200, 202, 1,   0,   0,   0,   201, 192, 1,
           0,   0,   0,   201, 193, 1,   0,   0,   0,   201, 194, 1,   0,   0,   0,   201, 196, 1,   0,   0,   0,   201, 197, 1,   0,   0,
           0,   202, 11,  1,   0,   0,   0,   203, 204, 3,   32,  16,  0,   204, 206, 3,   14,  7,   0,   205, 207, 3,   34,  17,  0,   206,
           205, 1,   0,   0,   0,   206, 207, 1,   0,   0,   0,   207, 209, 1,   0,   0,   0,   208, 210, 3,   68,  34,  0,   209, 208, 1,
           0,   0,   0,   209, 210, 1,   0,   0,   0,   210, 212, 1,   0,   0,   0,   211, 213, 3,   36,  18,  0,   212, 211, 1,   0,   0,
           0,   212, 213, 1,   0,   0,   0,   213, 215, 1,   0,   0,   0,   214, 216, 3,   102, 51,  0,   215, 214, 1,   0,   0,   0,   215,
           216, 1,   0,   0,   0,   216, 13,  1,   0,   0,   0,   217, 218, 5,   31,  0,   0,   218, 223, 3,   16,  8,   0,   219, 220, 5,
           2,   0,   0,   220, 222, 3,   16,  8,   0,   221, 219, 1,   0,   0,   0,   222, 225, 1,   0,   0,   0,   223, 221, 1,   0,   0,
           0,   223, 224, 1,   0,   0,   0,   224, 15,  1,   0,   0,   0,   225, 223, 1,   0,   0,   0,   226, 230, 3,   24,  12,  0,   227,
           229, 3,   18,  9,   0,   228, 227, 1,   0,   0,   0,   229, 232, 1,   0,   0,   0,   230, 228, 1,   0,   0,   0,   230, 231, 1,
           0,   0,   0,   231, 17,  1,   0,   0,   0,   232, 230, 1,   0,   0,   0,   233, 234, 3,   20,  10,  0,   234, 235, 5,   42,  0,
           0,   235, 237, 3,   24,  12,  0,   236, 238, 3,   22,  11,  0,   237, 236, 1,   0,   0,   0,   237, 238, 1,   0,   0,   0,   238,
           245, 1,   0,   0,   0,   239, 240, 5,   49,  0,   0,   240, 241, 3,   20,  10,  0,   241, 242, 5,   42,  0,   0,   242, 243, 3,
           24,  12,  0,   243, 245, 1,   0,   0,   0,   244, 233, 1,   0,   0,   0,   244, 239, 1,   0,   0,   0,   245, 19,  1,   0,   0,
           0,   246, 248, 5,   38,  0,   0,   247, 246, 1,   0,   0,   0,   247, 248, 1,   0,   0,   0,   248, 21,  1,   0,   0,   0,   249,
           250, 5,   54,  0,   0,   250, 251, 3,   66,  33,  0,   251, 23,  1,   0,   0,   0,   252, 253, 3,   44,  22,  0,   253, 254, 3,
           40,  20,  0,   254, 268, 1,   0,   0,   0,   255, 256, 5,   3,   0,   0,   256, 257, 3,   4,   2,   0,   257, 258, 5,   4,   0,
           0,   258, 259, 3,   40,  20,  0,   259, 268, 1,   0,   0,   0,   260, 261, 5,   3,   0,   0,   261, 262, 3,   16,  8,   0,   262,
           263, 5,   4,   0,   0,   263, 264, 3,   40,  20,  0,   264, 268, 1,   0,   0,   0,   265, 268, 3,   38,  19,  0,   266, 268, 3,
           26,  13,  0,   267, 252, 1,   0,   0,   0,   267, 255, 1,   0,   0,   0,   267, 260, 1,   0,   0,   0,   267, 265, 1,   0,   0,
           0,   267, 266, 1,   0,   0,   0,   268, 25,  1,   0,   0,   0,   269, 270, 3,   58,  29,  0,   270, 279, 5,   3,   0,   0,   271,
           276, 3,   64,  32,  0,   272, 273, 5,   2,   0,   0,   273, 275, 3,   64,  32,  0,   274, 272, 1,   0,   0,   0,   275, 278, 1,
           0,   0,   0,   276, 274, 1,   0,   0,   0,   276, 277, 1,   0,   0,   0,   277, 280, 1,   0,   0,   0,   278, 276, 1,   0,   0,
           0,   279, 271, 1,   0,   0,   0,   279, 280, 1,   0,   0,   0,   280, 281, 1,   0,   0,   0,   281, 282, 5,   4,   0,   0,   282,
           283, 3,   40,  20,  0,   283, 27,  1,   0,   0,   0,   284, 286, 3,   14,  7,   0,   285, 287, 3,   30,  15,  0,   286, 285, 1,
           0,   0,   0,   287, 288, 1,   0,   0,   0,   288, 286, 1,   0,   0,   0,   288, 289, 1,   0,   0,   0,   289, 29,  1,   0,   0,
           0,   290, 292, 3,   32,  16,  0,   291, 293, 3,   34,  17,  0,   292, 291, 1,   0,   0,   0,   292, 293, 1,   0,   0,   0,   293,
           295, 1,   0,   0,   0,   294, 296, 3,   70,  35,  0,   295, 294, 1,   0,   0,   0,   295, 296, 1,   0,   0,   0,   296, 31,  1,
           0,   0,   0,   297, 301, 5,   62,  0,   0,   298, 300, 3,   124, 62,  0,   299, 298, 1,   0,   0,   0,   300, 303, 1,   0,   0,
           0,   301, 299, 1,   0,   0,   0,   301, 302, 1,   0,   0,   0,   302, 304, 1,   0,   0,   0,   303, 301, 1,   0,   0,   0,   304,
           305, 3,   62,  31,  0,   305, 33,  1,   0,   0,   0,   306, 307, 5,   76,  0,   0,   307, 308, 3,   66,  33,  0,   308, 35,  1,
           0,   0,   0,   309, 310, 5,   35,  0,   0,   310, 311, 3,   66,  33,  0,   311, 37,  1,   0,   0,   0,   312, 313, 5,   74,  0,
           0,   313, 318, 3,   64,  32,  0,   314, 315, 5,   2,   0,   0,   315, 317, 3,   64,  32,  0,   316, 314, 1,   0,   0,   0,   317,
           320, 1,   0,   0,   0,   318, 316, 1,   0,   0,   0,   318, 319, 1,   0,   0,   0,   319, 321, 1,   0,   0,   0,   320, 318, 1,
           0,   0,   0,   321, 322, 3,   40,  20,  0,   322, 39,  1,   0,   0,   0,   323, 325, 5,   12,  0,   0,   324, 323, 1,   0,   0,
           0,   324, 325, 1,   0,   0,   0,   325, 326, 1,   0,   0,   0,   326, 328, 3,   50,  25,  0,   327, 329, 3,   54,  27,  0,   328,
           327, 1,   0,   0,   0,   328, 329, 1,   0,   0,   0,   329, 331, 1,   0,   0,   0,   330, 324, 1,   0,   0,   0,   330, 331, 1,
           0,   0,   0,   331, 41,  1,   0,   0,   0,   332, 337, 3,   44,  22,  0,   333, 334, 5,   2,   0,   0,   334, 336, 3,   44,  22,
           0,   335, 333, 1,   0,   0,   0,   336, 339, 1,   0,   0,   0,   337, 335, 1,   0,   0,   0,   337, 338, 1,   0,   0,   0,   338,
           43,  1,   0,   0,   0,   339, 337, 1,   0,   0,   0,   340, 345, 3,   58,  29,  0,   341, 342, 5,   5,   0,   0,   342, 344, 3,
           58,  29,  0,   343, 341, 1,   0,   0,   0,   344, 347, 1,   0,   0,   0,   345, 343, 1,   0,   0,   0,   345, 346, 1,   0,   0,
           0,   346, 45,  1,   0,   0,   0,   347, 345, 1,   0,   0,   0,   348, 356, 3,   64,  32,  0,   349, 351, 5,   12,  0,   0,   350,
           349, 1,   0,   0,   0,   350, 351, 1,   0,   0,   0,   351, 354, 1,   0,   0,   0,   352, 355, 3,   58,  29,  0,   353, 355, 3,
           54,  27,  0,   354, 352, 1,   0,   0,   0,   354, 353, 1,   0,   0,   0,   355, 357, 1,   0,   0,   0,   356, 350, 1,   0,   0,
           0,   356, 357, 1,   0,   0,   0,   357, 47,  1,   0,   0,   0,   358, 362, 3,   50,  25,  0,   359, 360, 4,   24,  1,   0,   360,
           362, 3,   138, 69,  0,   361, 358, 1,   0,   0,   0,   361, 359, 1,   0,   0,   0,   362, 49,  1,   0,   0,   0,   363, 370, 5,
           131, 0,   0,   364, 370, 3,   52,  26,  0,   365, 366, 4,   25,  2,   0,   366, 370, 3,   140, 70,  0,   367, 368, 4,   25,  3,
           0,   368, 370, 3,   142, 71,  0,   369, 363, 1,   0,   0,   0,   369, 364, 1,   0,   0,   0,   369, 365, 1,   0,   0,   0,   369,
           367, 1,   0,   0,   0,   370, 51,  1,   0,   0,   0,   371, 372, 5,   8,   0,   0,   372, 53,  1,   0,   0,   0,   373, 374, 5,
           3,   0,   0,   374, 375, 3,   56,  28,  0,   375, 376, 5,   4,   0,   0,   376, 55,  1,   0,   0,   0,   377, 382, 3,   58,  29,
           0,   378, 379, 5,   2,   0,   0,   379, 381, 3,   58,  29,  0,   380, 378, 1,   0,   0,   0,   381, 384, 1,   0,   0,   0,   382,
           380, 1,   0,   0,   0,   382, 383, 1,   0,   0,   0,   383, 57,  1,   0,   0,   0,   384, 382, 1,   0,   0,   0,   385, 386, 3,
           48,  24,  0,   386, 387, 3,   60,  30,  0,   387, 59,  1,   0,   0,   0,   388, 389, 5,   112, 0,   0,   389, 391, 3,   48,  24,
           0,   390, 388, 1,   0,   0,   0,   391, 392, 1,   0,   0,   0,   392, 390, 1,   0,   0,   0,   392, 393, 1,   0,   0,   0,   393,
           396, 1,   0,   0,   0,   394, 396, 1,   0,   0,   0,   395, 390, 1,   0,   0,   0,   395, 394, 1,   0,   0,   0,   396, 61,  1,
           0,   0,   0,   397, 402, 3,   46,  23,  0,   398, 399, 5,   2,   0,   0,   399, 401, 3,   46,  23,  0,   400, 398, 1,   0,   0,
           0,   401, 404, 1,   0,   0,   0,   402, 400, 1,   0,   0,   0,   402, 403, 1,   0,   0,   0,   403, 63,  1,   0,   0,   0,   404,
           402, 1,   0,   0,   0,   405, 406, 3,   66,  33,  0,   406, 65,  1,   0,   0,   0,   407, 408, 6,   33,  -1,  0,   408, 409, 5,
           50,  0,   0,   409, 420, 3,   66,  33,  5,   410, 411, 5,   27,  0,   0,   411, 412, 5,   3,   0,   0,   412, 413, 3,   4,   2,
           0,   413, 414, 5,   4,   0,   0,   414, 420, 1,   0,   0,   0,   415, 417, 3,   120, 60,  0,   416, 418, 3,   118, 59,  0,   417,
           416, 1,   0,   0,   0,   417, 418, 1,   0,   0,   0,   418, 420, 1,   0,   0,   0,   419, 407, 1,   0,   0,   0,   419, 410, 1,
           0,   0,   0,   419, 415, 1,   0,   0,   0,   420, 429, 1,   0,   0,   0,   421, 422, 10,  2,   0,   0,   422, 423, 5,   10,  0,
           0,   423, 428, 3,   66,  33,  3,   424, 425, 10,  1,   0,   0,   425, 426, 5,   55,  0,   0,   426, 428, 3,   66,  33,  2,   427,
           421, 1,   0,   0,   0,   427, 424, 1,   0,   0,   0,   428, 431, 1,   0,   0,   0,   429, 427, 1,   0,   0,   0,   429, 430, 1,
           0,   0,   0,   430, 67,  1,   0,   0,   0,   431, 429, 1,   0,   0,   0,   432, 434, 3,   70,  35,  0,   433, 432, 1,   0,   0,
           0,   433, 434, 1,   0,   0,   0,   434, 435, 1,   0,   0,   0,   435, 437, 3,   74,  37,  0,   436, 438, 3,   76,  38,  0,   437,
           436, 1,   0,   0,   0,   437, 438, 1,   0,   0,   0,   438, 69,  1,   0,   0,   0,   439, 440, 5,   33,  0,   0,   440, 441, 5,
           16,  0,   0,   441, 446, 3,   64,  32,  0,   442, 443, 5,   2,   0,   0,   443, 445, 3,   64,  32,  0,   444, 442, 1,   0,   0,
           0,   445, 448, 1,   0,   0,   0,   446, 444, 1,   0,   0,   0,   446, 447, 1,   0,   0,   0,   447, 466, 1,   0,   0,   0,   448,
           446, 1,   0,   0,   0,   449, 450, 5,   78,  0,   0,   450, 467, 5,   61,  0,   0,   451, 452, 5,   78,  0,   0,   452, 467, 5,
           18,  0,   0,   453, 454, 5,   34,  0,   0,   454, 455, 5,   63,  0,   0,   455, 456, 5,   3,   0,   0,   456, 461, 3,   72,  36,
           0,   457, 458, 5,   2,   0,   0,   458, 460, 3,   72,  36,  0,   459, 457, 1,   0,   0,   0,   460, 463, 1,   0,   0,   0,   461,
           459, 1,   0,   0,   0,   461, 462, 1,   0,   0,   0,   462, 464, 1,   0,   0,   0,   463, 461, 1,   0,   0,   0,   464, 465, 5,
           4,   0,   0,   465, 467, 1,   0,   0,   0,   466, 449, 1,   0,   0,   0,   466, 451, 1,   0,   0,   0,   466, 453, 1,   0,   0,
           0,   466, 467, 1,   0,   0,   0,   467, 484, 1,   0,   0,   0,   468, 469, 5,   33,  0,   0,   469, 470, 5,   16,  0,   0,   470,
           471, 5,   34,  0,   0,   471, 472, 5,   63,  0,   0,   472, 473, 5,   3,   0,   0,   473, 478, 3,   72,  36,  0,   474, 475, 5,
           2,   0,   0,   475, 477, 3,   72,  36,  0,   476, 474, 1,   0,   0,   0,   477, 480, 1,   0,   0,   0,   478, 476, 1,   0,   0,
           0,   478, 479, 1,   0,   0,   0,   479, 481, 1,   0,   0,   0,   480, 478, 1,   0,   0,   0,   481, 482, 5,   4,   0,   0,   482,
           484, 1,   0,   0,   0,   483, 439, 1,   0,   0,   0,   483, 468, 1,   0,   0,   0,   484, 71,  1,   0,   0,   0,   485, 494, 5,
           3,   0,   0,   486, 491, 3,   64,  32,  0,   487, 488, 5,   2,   0,   0,   488, 490, 3,   64,  32,  0,   489, 487, 1,   0,   0,
           0,   490, 493, 1,   0,   0,   0,   491, 489, 1,   0,   0,   0,   491, 492, 1,   0,   0,   0,   492, 495, 1,   0,   0,   0,   493,
           491, 1,   0,   0,   0,   494, 486, 1,   0,   0,   0,   494, 495, 1,   0,   0,   0,   495, 496, 1,   0,   0,   0,   496, 499, 5,
           4,   0,   0,   497, 499, 3,   64,  32,  0,   498, 485, 1,   0,   0,   0,   498, 497, 1,   0,   0,   0,   499, 73,  1,   0,   0,
           0,   500, 501, 5,   77,  0,   0,   501, 502, 3,   80,  40,  0,   502, 75,  1,   0,   0,   0,   503, 504, 5,   94,  0,   0,   504,
           505, 5,   3,   0,   0,   505, 506, 3,   78,  39,  0,   506, 507, 5,   4,   0,   0,   507, 77,  1,   0,   0,   0,   508, 509, 3,
           48,  24,  0,   509, 510, 5,   2,   0,   0,   510, 511, 5,   125, 0,   0,   511, 512, 3,   96,  48,  0,   512, 79,  1,   0,   0,
           0,   513, 517, 3,   82,  41,  0,   514, 517, 3,   84,  42,  0,   515, 517, 3,   86,  43,  0,   516, 513, 1,   0,   0,   0,   516,
           514, 1,   0,   0,   0,   516, 515, 1,   0,   0,   0,   517, 81,  1,   0,   0,   0,   518, 519, 5,   79,  0,   0,   519, 523, 5,
           3,   0,   0,   520, 521, 3,   98,  49,  0,   521, 522, 5,   2,   0,   0,   522, 524, 1,   0,   0,   0,   523, 520, 1,   0,   0,
           0,   523, 524, 1,   0,   0,   0,   524, 525, 1,   0,   0,   0,   525, 526, 3,   92,  46,  0,   526, 527, 5,   4,   0,   0,   527,
           541, 1,   0,   0,   0,   528, 529, 5,   80,  0,   0,   529, 533, 5,   3,   0,   0,   530, 531, 3,   98,  49,  0,   531, 532, 5,
           2,   0,   0,   532, 534, 1,   0,   0,   0,   533, 530, 1,   0,   0,   0,   533, 534, 1,   0,   0,   0,   534, 535, 1,   0,   0,
           0,   535, 536, 3,   92,  46,  0,   536, 537, 5,   2,   0,   0,   537, 538, 3,   94,  47,  0,   538, 539, 5,   4,   0,   0,   539,
           541, 1,   0,   0,   0,   540, 518, 1,   0,   0,   0,   540, 528, 1,   0,   0,   0,   541, 83,  1,   0,   0,   0,   542, 543, 5,
           79,  0,   0,   543, 544, 5,   3,   0,   0,   544, 545, 5,   125, 0,   0,   545, 546, 5,   4,   0,   0,   546, 85,  1,   0,   0,
           0,   547, 548, 5,   81,  0,   0,   548, 549, 5,   3,   0,   0,   549, 552, 3,   88,  44,  0,   550, 551, 5,   2,   0,   0,   551,
           553, 3,   90,  45,  0,   552, 550, 1,   0,   0,   0,   552, 553, 1,   0,   0,   0,   553, 554, 1,   0,   0,   0,   554, 555, 5,
           4,   0,   0,   555, 87,  1,   0,   0,   0,   556, 557, 3,   64,  32,  0,   557, 89,  1,   0,   0,   0,   558, 559, 5,   125, 0,
           0,   559, 91,  1,   0,   0,   0,   560, 561, 5,   82,  0,   0,   561, 562, 5,   125, 0,   0,   562, 563, 3,   96,  48,  0,   563,
           93,  1,   0,   0,   0,   564, 565, 5,   83,  0,   0,   565, 566, 5,   16,  0,   0,   566, 567, 5,   125, 0,   0,   567, 568, 3,
           96,  48,  0,   568, 95,  1,   0,   0,   0,   569, 570, 7,   0,   0,   0,   570, 97,  1,   0,   0,   0,   571, 572, 5,   131, 0,
           0,   572, 99,  1,   0,   0,   0,   573, 574, 7,   1,   0,   0,   574, 101, 1,   0,   0,   0,   575, 576, 5,   40,  0,   0,   576,
           578, 3,   104, 52,  0,   577, 579, 5,   12,  0,   0,   578, 577, 1,   0,   0,   0,   578, 579, 1,   0,   0,   0,   579, 103, 1,
           0,   0,   0,   580, 583, 3,   110, 55,  0,   581, 583, 3,   112, 56,  0,   582, 580, 1,   0,   0,   0,   582, 581, 1,   0,   0,
           0,   583, 105, 1,   0,   0,   0,   584, 586, 5,   50,  0,   0,   585, 584, 1,   0,   0,   0,   585, 586, 1,   0,   0,   0,   586,
           587, 1,   0,   0,   0,   587, 588, 5,   51,  0,   0,   588, 107, 1,   0,   0,   0,   589, 590, 5,   131, 0,   0,   590, 109, 1,
           0,   0,   0,   591, 592, 5,   96,  0,   0,   592, 111, 1,   0,   0,   0,   593, 594, 5,   97,  0,   0,   594, 113, 1,   0,   0,
           0,   595, 596, 5,   99,  0,   0,   596, 115, 1,   0,   0,   0,   597, 599, 3,   64,  32,  0,   598, 600, 7,   2,   0,   0,   599,
           598, 1,   0,   0,   0,   599, 600, 1,   0,   0,   0,   600, 603, 1,   0,   0,   0,   601, 602, 5,   52,  0,   0,   602, 604, 7,
           3,   0,   0,   603, 601, 1,   0,   0,   0,   603, 604, 1,   0,   0,   0,   604, 117, 1,   0,   0,   0,   605, 607, 5,   50,  0,
           0,   606, 605, 1,   0,   0,   0,   606, 607, 1,   0,   0,   0,   607, 608, 1,   0,   0,   0,   608, 609, 5,   15,  0,   0,   609,
           610, 3,   120, 60,  0,   610, 611, 5,   10,  0,   0,   611, 612, 3,   120, 60,  0,   612, 685, 1,   0,   0,   0,   613, 615, 5,
           50,  0,   0,   614, 613, 1,   0,   0,   0,   614, 615, 1,   0,   0,   0,   615, 616, 1,   0,   0,   0,   616, 617, 5,   37,  0,
           0,   617, 618, 5,   3,   0,   0,   618, 623, 3,   64,  32,  0,   619, 620, 5,   2,   0,   0,   620, 622, 3,   64,  32,  0,   621,
           619, 1,   0,   0,   0,   622, 625, 1,   0,   0,   0,   623, 621, 1,   0,   0,   0,   623, 624, 1,   0,   0,   0,   624, 626, 1,
           0,   0,   0,   625, 623, 1,   0,   0,   0,   626, 627, 5,   4,   0,   0,   627, 685, 1,   0,   0,   0,   628, 630, 5,   50,  0,
           0,   629, 628, 1,   0,   0,   0,   629, 630, 1,   0,   0,   0,   630, 631, 1,   0,   0,   0,   631, 632, 5,   37,  0,   0,   632,
           633, 5,   3,   0,   0,   633, 634, 3,   4,   2,   0,   634, 635, 5,   4,   0,   0,   635, 685, 1,   0,   0,   0,   636, 638, 5,
           50,  0,   0,   637, 636, 1,   0,   0,   0,   637, 638, 1,   0,   0,   0,   638, 639, 1,   0,   0,   0,   639, 640, 5,   60,  0,
           0,   640, 685, 3,   120, 60,  0,   641, 643, 5,   50,  0,   0,   642, 641, 1,   0,   0,   0,   642, 643, 1,   0,   0,   0,   643,
           644, 1,   0,   0,   0,   644, 645, 5,   45,  0,   0,   645, 659, 7,   4,   0,   0,   646, 647, 5,   3,   0,   0,   647, 660, 5,
           4,   0,   0,   648, 649, 5,   3,   0,   0,   649, 654, 3,   64,  32,  0,   650, 651, 5,   2,   0,   0,   651, 653, 3,   64,  32,
           0,   652, 650, 1,   0,   0,   0,   653, 656, 1,   0,   0,   0,   654, 652, 1,   0,   0,   0,   654, 655, 1,   0,   0,   0,   655,
           657, 1,   0,   0,   0,   656, 654, 1,   0,   0,   0,   657, 658, 5,   4,   0,   0,   658, 660, 1,   0,   0,   0,   659, 646, 1,
           0,   0,   0,   659, 648, 1,   0,   0,   0,   660, 685, 1,   0,   0,   0,   661, 663, 5,   50,  0,   0,   662, 661, 1,   0,   0,
           0,   662, 663, 1,   0,   0,   0,   663, 664, 1,   0,   0,   0,   664, 665, 5,   45,  0,   0,   665, 668, 3,   120, 60,  0,   666,
           667, 5,   26,  0,   0,   667, 669, 5,   121, 0,   0,   668, 666, 1,   0,   0,   0,   668, 669, 1,   0,   0,   0,   669, 685, 1,
           0,   0,   0,   670, 671, 5,   41,  0,   0,   671, 685, 3,   106, 53,  0,   672, 674, 5,   41,  0,   0,   673, 675, 5,   50,  0,
           0,   674, 673, 1,   0,   0,   0,   674, 675, 1,   0,   0,   0,   675, 676, 1,   0,   0,   0,   676, 685, 7,   5,   0,   0,   677,
           679, 5,   41,  0,   0,   678, 680, 5,   50,  0,   0,   679, 678, 1,   0,   0,   0,   679, 680, 1,   0,   0,   0,   680, 681, 1,
           0,   0,   0,   681, 682, 5,   21,  0,   0,   682, 683, 5,   31,  0,   0,   683, 685, 3,   120, 60,  0,   684, 606, 1,   0,   0,
           0,   684, 614, 1,   0,   0,   0,   684, 629, 1,   0,   0,   0,   684, 637, 1,   0,   0,   0,   684, 642, 1,   0,   0,   0,   684,
           662, 1,   0,   0,   0,   684, 670, 1,   0,   0,   0,   684, 672, 1,   0,   0,   0,   684, 677, 1,   0,   0,   0,   685, 119, 1,
           0,   0,   0,   686, 687, 6,   60,  -1,  0,   687, 691, 3,   128, 64,  0,   688, 689, 7,   6,   0,   0,   689, 691, 3,   120, 60,
           7,   690, 686, 1,   0,   0,   0,   690, 688, 1,   0,   0,   0,   691, 713, 1,   0,   0,   0,   692, 693, 10,  6,   0,   0,   693,
           694, 7,   7,   0,   0,   694, 712, 3,   120, 60,  7,   695, 696, 10,  5,   0,   0,   696, 697, 7,   8,   0,   0,   697, 712, 3,
           120, 60,  6,   698, 699, 10,  4,   0,   0,   699, 700, 5,   117, 0,   0,   700, 712, 3,   120, 60,  5,   701, 702, 10,  3,   0,
           0,   702, 703, 5,   120, 0,   0,   703, 712, 3,   120, 60,  4,   704, 705, 10,  2,   0,   0,   705, 706, 5,   118, 0,   0,   706,
           712, 3,   120, 60,  3,   707, 708, 10,  1,   0,   0,   708, 709, 3,   122, 61,  0,   709, 710, 3,   120, 60,  2,   710, 712, 1,
           0,   0,   0,   711, 692, 1,   0,   0,   0,   711, 695, 1,   0,   0,   0,   711, 698, 1,   0,   0,   0,   711, 701, 1,   0,   0,
           0,   711, 704, 1,   0,   0,   0,   711, 707, 1,   0,   0,   0,   712, 715, 1,   0,   0,   0,   713, 711, 1,   0,   0,   0,   713,
           714, 1,   0,   0,   0,   714, 121, 1,   0,   0,   0,   715, 713, 1,   0,   0,   0,   716, 717, 7,   9,   0,   0,   717, 123, 1,
           0,   0,   0,   718, 719, 5,   6,   0,   0,   719, 726, 3,   126, 63,  0,   720, 722, 5,   2,   0,   0,   721, 720, 1,   0,   0,
           0,   721, 722, 1,   0,   0,   0,   722, 723, 1,   0,   0,   0,   723, 725, 3,   126, 63,  0,   724, 721, 1,   0,   0,   0,   725,
           728, 1,   0,   0,   0,   726, 724, 1,   0,   0,   0,   726, 727, 1,   0,   0,   0,   727, 729, 1,   0,   0,   0,   728, 726, 1,
           0,   0,   0,   729, 730, 5,   7,   0,   0,   730, 125, 1,   0,   0,   0,   731, 745, 3,   48,  24,  0,   732, 733, 3,   48,  24,
           0,   733, 734, 5,   3,   0,   0,   734, 739, 3,   128, 64,  0,   735, 736, 5,   2,   0,   0,   736, 738, 3,   128, 64,  0,   737,
           735, 1,   0,   0,   0,   738, 741, 1,   0,   0,   0,   739, 737, 1,   0,   0,   0,   739, 740, 1,   0,   0,   0,   740, 742, 1,
           0,   0,   0,   741, 739, 1,   0,   0,   0,   742, 743, 5,   4,   0,   0,   743, 745, 1,   0,   0,   0,   744, 731, 1,   0,   0,
           0,   744, 732, 1,   0,   0,   0,   745, 127, 1,   0,   0,   0,   746, 747, 6,   64,  -1,  0,   747, 787, 5,   113, 0,   0,   748,
           749, 3,   130, 65,  0,   749, 750, 5,   5,   0,   0,   750, 751, 5,   113, 0,   0,   751, 787, 1,   0,   0,   0,   752, 753, 5,
           3,   0,   0,   753, 754, 3,   4,   2,   0,   754, 755, 5,   4,   0,   0,   755, 787, 1,   0,   0,   0,   756, 757, 5,   3,   0,
           0,   757, 760, 3,   46,  23,  0,   758, 759, 5,   2,   0,   0,   759, 761, 3,   46,  23,  0,   760, 758, 1,   0,   0,   0,   761,
           762, 1,   0,   0,   0,   762, 760, 1,   0,   0,   0,   762, 763, 1,   0,   0,   0,   763, 764, 1,   0,   0,   0,   764, 765, 5,
           4,   0,   0,   765, 787, 1,   0,   0,   0,   766, 767, 3,   100, 50,  0,   767, 776, 5,   3,   0,   0,   768, 773, 3,   64,  32,
           0,   769, 770, 5,   2,   0,   0,   770, 772, 3,   64,  32,  0,   771, 769, 1,   0,   0,   0,   772, 775, 1,   0,   0,   0,   773,
           771, 1,   0,   0,   0,   773, 774, 1,   0,   0,   0,   774, 777, 1,   0,   0,   0,   775, 773, 1,   0,   0,   0,   776, 768, 1,
           0,   0,   0,   776, 777, 1,   0,   0,   0,   777, 778, 1,   0,   0,   0,   778, 779, 5,   4,   0,   0,   779, 787, 1,   0,   0,
           0,   780, 781, 5,   3,   0,   0,   781, 782, 3,   64,  32,  0,   782, 783, 5,   4,   0,   0,   783, 787, 1,   0,   0,   0,   784,
           787, 3,   134, 67,  0,   785, 787, 3,   48,  24,  0,   786, 746, 1,   0,   0,   0,   786, 748, 1,   0,   0,   0,   786, 752, 1,
           0,   0,   0,   786, 756, 1,   0,   0,   0,   786, 766, 1,   0,   0,   0,   786, 780, 1,   0,   0,   0,   786, 784, 1,   0,   0,
           0,   786, 785, 1,   0,   0,   0,   787, 793, 1,   0,   0,   0,   788, 789, 10,  7,   0,   0,   789, 790, 5,   5,   0,   0,   790,
           792, 3,   48,  24,  0,   791, 788, 1,   0,   0,   0,   792, 795, 1,   0,   0,   0,   793, 791, 1,   0,   0,   0,   793, 794, 1,
           0,   0,   0,   794, 129, 1,   0,   0,   0,   795, 793, 1,   0,   0,   0,   796, 801, 3,   48,  24,  0,   797, 798, 5,   5,   0,
           0,   798, 800, 3,   48,  24,  0,   799, 797, 1,   0,   0,   0,   800, 803, 1,   0,   0,   0,   801, 799, 1,   0,   0,   0,   801,
           802, 1,   0,   0,   0,   802, 131, 1,   0,   0,   0,   803, 801, 1,   0,   0,   0,   804, 806, 4,   66,  13,  0,   805, 807, 5,
           112, 0,   0,   806, 805, 1,   0,   0,   0,   806, 807, 1,   0,   0,   0,   807, 808, 1,   0,   0,   0,   808, 848, 5,   126, 0,
           0,   809, 811, 4,   66,  14,  0,   810, 812, 5,   112, 0,   0,   811, 810, 1,   0,   0,   0,   811, 812, 1,   0,   0,   0,   812,
           813, 1,   0,   0,   0,   813, 848, 5,   127, 0,   0,   814, 816, 4,   66,  15,  0,   815, 817, 5,   112, 0,   0,   816, 815, 1,
           0,   0,   0,   816, 817, 1,   0,   0,   0,   817, 818, 1,   0,   0,   0,   818, 848, 7,   10,  0,   0,   819, 821, 5,   112, 0,
           0,   820, 819, 1,   0,   0,   0,   820, 821, 1,   0,   0,   0,   821, 822, 1,   0,   0,   0,   822, 848, 5,   125, 0,   0,   823,
           825, 5,   112, 0,   0,   824, 823, 1,   0,   0,   0,   824, 825, 1,   0,   0,   0,   825, 826, 1,   0,   0,   0,   826, 848, 5,
           122, 0,   0,   827, 829, 5,   112, 0,   0,   828, 827, 1,   0,   0,   0,   828, 829, 1,   0,   0,   0,   829, 830, 1,   0,   0,
           0,   830, 848, 5,   123, 0,   0,   831, 833, 5,   112, 0,   0,   832, 831, 1,   0,   0,   0,   832, 833, 1,   0,   0,   0,   833,
           834, 1,   0,   0,   0,   834, 848, 5,   124, 0,   0,   835, 837, 5,   112, 0,   0,   836, 835, 1,   0,   0,   0,   836, 837, 1,
           0,   0,   0,   837, 838, 1,   0,   0,   0,   838, 848, 5,   129, 0,   0,   839, 841, 5,   112, 0,   0,   840, 839, 1,   0,   0,
           0,   840, 841, 1,   0,   0,   0,   841, 842, 1,   0,   0,   0,   842, 848, 5,   128, 0,   0,   843, 845, 5,   112, 0,   0,   844,
           843, 1,   0,   0,   0,   844, 845, 1,   0,   0,   0,   845, 846, 1,   0,   0,   0,   846, 848, 5,   130, 0,   0,   847, 804, 1,
           0,   0,   0,   847, 809, 1,   0,   0,   0,   847, 814, 1,   0,   0,   0,   847, 820, 1,   0,   0,   0,   847, 824, 1,   0,   0,
           0,   847, 828, 1,   0,   0,   0,   847, 832, 1,   0,   0,   0,   847, 836, 1,   0,   0,   0,   847, 840, 1,   0,   0,   0,   847,
           844, 1,   0,   0,   0,   848, 133, 1,   0,   0,   0,   849, 861, 5,   51,  0,   0,   850, 851, 3,   48,  24,  0,   851, 852, 5,
           121, 0,   0,   852, 861, 1,   0,   0,   0,   853, 861, 3,   132, 66,  0,   854, 861, 3,   136, 68,  0,   855, 857, 5,   121, 0,
           0,   856, 855, 1,   0,   0,   0,   857, 858, 1,   0,   0,   0,   858, 856, 1,   0,   0,   0,   858, 859, 1,   0,   0,   0,   859,
           861, 1,   0,   0,   0,   860, 849, 1,   0,   0,   0,   860, 850, 1,   0,   0,   0,   860, 853, 1,   0,   0,   0,   860, 854, 1,
           0,   0,   0,   860, 856, 1,   0,   0,   0,   861, 135, 1,   0,   0,   0,   862, 863, 7,   11,  0,   0,   863, 137, 1,   0,   0,
           0,   864, 865, 7,   12,  0,   0,   865, 139, 1,   0,   0,   0,   866, 867, 7,   13,  0,   0,   867, 141, 1,   0,   0,   0,   868,
           869, 7,   14,  0,   0,   869, 143, 1,   0,   0,   0,   102, 148, 165, 168, 173, 175, 179, 189, 201, 206, 209, 212, 215, 223, 230,
           237, 244, 247, 267, 276, 279, 288, 292, 295, 301, 318, 324, 328, 330, 337, 345, 350, 354, 356, 361, 369, 382, 392, 395, 402, 417,
           419, 427, 429, 433, 437, 446, 461, 466, 478, 483, 491, 494, 498, 516, 523, 533, 540, 552, 578, 582, 585, 599, 603, 606, 614, 623,
           629, 637, 642, 654, 659, 662, 668, 674, 679, 684, 690, 711, 713, 721, 726, 739, 744, 762, 773, 776, 786, 793, 801, 806, 811, 816,
           820, 824, 828, 832, 836, 840, 844, 847, 858, 860};
    staticData->serializedATN
        = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

    antlr4::atn::ATNDeserializer deserializer;
    staticData->atn = deserializer.deserialize(staticData->serializedATN);

    const size_t count = staticData->atn->getNumberOfDecisions();
    staticData->decisionToDFA.reserve(count);
    for (size_t i = 0; i < count; i++)
    {
        staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
    }
    nebulasqlParserStaticData = std::move(staticData);
}

}

NebulaSQLParser::NebulaSQLParser(TokenStream* input) : NebulaSQLParser(input, antlr4::atn::ParserATNSimulatorOptions())
{
}

NebulaSQLParser::NebulaSQLParser(TokenStream* input, const antlr4::atn::ParserATNSimulatorOptions& options) : Parser(input)
{
    NebulaSQLParser::initialize();
    _interpreter = new atn::ParserATNSimulator(
        this,
        *nebulasqlParserStaticData->atn,
        nebulasqlParserStaticData->decisionToDFA,
        nebulasqlParserStaticData->sharedContextCache,
        options);
}

NebulaSQLParser::~NebulaSQLParser()
{
    delete _interpreter;
}

const atn::ATN& NebulaSQLParser::getATN() const
{
    return *nebulasqlParserStaticData->atn;
}

std::string NebulaSQLParser::getGrammarFileName() const
{
    return "NebulaSQL.g4";
}

const std::vector<std::string>& NebulaSQLParser::getRuleNames() const
{
    return nebulasqlParserStaticData->ruleNames;
}

const dfa::Vocabulary& NebulaSQLParser::getVocabulary() const
{
    return nebulasqlParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NebulaSQLParser::getSerializedATN() const
{
    return nebulasqlParserStaticData->serializedATN;
}


//----------------- SingleStatementContext ------------------------------------------------------------------

NebulaSQLParser::SingleStatementContext::SingleStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::StatementContext* NebulaSQLParser::SingleStatementContext::statement()
{
    return getRuleContext<NebulaSQLParser::StatementContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SingleStatementContext::EOF()
{
    return getToken(NebulaSQLParser::EOF, 0);
}


size_t NebulaSQLParser::SingleStatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSingleStatement;
}

void NebulaSQLParser::SingleStatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSingleStatement(this);
}

void NebulaSQLParser::SingleStatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSingleStatement(this);
}

NebulaSQLParser::SingleStatementContext* NebulaSQLParser::singleStatement()
{
    SingleStatementContext* _localctx = _tracker.createInstance<SingleStatementContext>(_ctx, getState());
    enterRule(_localctx, 0, NebulaSQLParser::RuleSingleStatement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(144);
        statement();
        setState(148);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__0)
        {
            setState(145);
            match(NebulaSQLParser::T__0);
            setState(150);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(151);
        match(NebulaSQLParser::EOF);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NebulaSQLParser::StatementContext::StatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::QueryContext* NebulaSQLParser::StatementContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}


size_t NebulaSQLParser::StatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStatement;
}

void NebulaSQLParser::StatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStatement(this);
}

void NebulaSQLParser::StatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStatement(this);
}

NebulaSQLParser::StatementContext* NebulaSQLParser::statement()
{
    StatementContext* _localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
    enterRule(_localctx, 2, NebulaSQLParser::RuleStatement);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(153);
        query();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext::QueryContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::QueryContext::queryTerm()
{
    return getRuleContext<NebulaSQLParser::QueryTermContext>(0);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::QueryContext::queryOrganization()
{
    return getRuleContext<NebulaSQLParser::QueryOrganizationContext>(0);
}


size_t NebulaSQLParser::QueryContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQuery;
}

void NebulaSQLParser::QueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuery(this);
}

void NebulaSQLParser::QueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuery(this);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::query()
{
    QueryContext* _localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
    enterRule(_localctx, 4, NebulaSQLParser::RuleQuery);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(155);
        queryTerm(0);
        setState(156);
        queryOrganization();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QueryOrganizationContext ------------------------------------------------------------------

NebulaSQLParser::QueryOrganizationContext::QueryOrganizationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ORDER()
{
    return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::LIMIT()
{
    return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::OFFSET()
{
    return getToken(NebulaSQLParser::OFFSET, 0);
}

std::vector<NebulaSQLParser::SortItemContext*> NebulaSQLParser::QueryOrganizationContext::sortItem()
{
    return getRuleContexts<NebulaSQLParser::SortItemContext>();
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::QueryOrganizationContext::sortItem(size_t i)
{
    return getRuleContext<NebulaSQLParser::SortItemContext>(i);
}

std::vector<tree::TerminalNode*> NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE()
{
    return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE(size_t i)
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ALL()
{
    return getToken(NebulaSQLParser::ALL, 0);
}


size_t NebulaSQLParser::QueryOrganizationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQueryOrganization;
}

void NebulaSQLParser::QueryOrganizationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQueryOrganization(this);
}

void NebulaSQLParser::QueryOrganizationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQueryOrganization(this);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::queryOrganization()
{
    QueryOrganizationContext* _localctx = _tracker.createInstance<QueryOrganizationContext>(_ctx, getState());
    enterRule(_localctx, 6, NebulaSQLParser::RuleQueryOrganization);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(168);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::ORDER)
        {
            setState(158);
            match(NebulaSQLParser::ORDER);
            setState(159);
            match(NebulaSQLParser::BY);
            setState(160);
            antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext = sortItem();
            antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->order.push_back(
                antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext);
            setState(165);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == NebulaSQLParser::T__1)
            {
                setState(161);
                match(NebulaSQLParser::T__1);
                setState(162);
                antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext = sortItem();
                antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->order.push_back(
                    antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext);
                setState(167);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
        }
        setState(175);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::LIMIT)
        {
            setState(170);
            match(NebulaSQLParser::LIMIT);
            setState(173);
            _errHandler->sync(this);
            switch (_input->LA(1))
            {
                case NebulaSQLParser::ALL: {
                    setState(171);
                    match(NebulaSQLParser::ALL);
                    break;
                }

                case NebulaSQLParser::INTEGER_VALUE: {
                    setState(172);
                    antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->limit = match(NebulaSQLParser::INTEGER_VALUE);
                    break;
                }

                default:
                    throw NoViableAltException(this);
            }
        }
        setState(179);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::OFFSET)
        {
            setState(177);
            match(NebulaSQLParser::OFFSET);
            setState(178);
            antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->offset = match(NebulaSQLParser::INTEGER_VALUE);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QueryTermContext ------------------------------------------------------------------

NebulaSQLParser::QueryTermContext::QueryTermContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::QueryTermContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQueryTerm;
}

void NebulaSQLParser::QueryTermContext::copyFrom(QueryTermContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::PrimaryQueryContext::queryPrimary()
{
    return getRuleContext<NebulaSQLParser::QueryPrimaryContext>(0);
}

NebulaSQLParser::PrimaryQueryContext::PrimaryQueryContext(QueryTermContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::PrimaryQueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterPrimaryQuery(this);
}
void NebulaSQLParser::PrimaryQueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitPrimaryQuery(this);
}
//----------------- SetOperationContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::QueryTermContext*> NebulaSQLParser::SetOperationContext::queryTerm()
{
    return getRuleContexts<NebulaSQLParser::QueryTermContext>();
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::SetOperationContext::queryTerm(size_t i)
{
    return getRuleContext<NebulaSQLParser::QueryTermContext>(i);
}

tree::TerminalNode* NebulaSQLParser::SetOperationContext::UNION()
{
    return getToken(NebulaSQLParser::UNION, 0);
}

NebulaSQLParser::SetOperationContext::SetOperationContext(QueryTermContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SetOperationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSetOperation(this);
}
void NebulaSQLParser::SetOperationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSetOperation(this);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm()
{
    return queryTerm(0);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::QueryTermContext* _localctx = _tracker.createInstance<QueryTermContext>(_ctx, parentState);
    NebulaSQLParser::QueryTermContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 8;
    enterRecursionRule(_localctx, 8, NebulaSQLParser::RuleQueryTerm, precedence);


#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        _localctx = _tracker.createInstance<PrimaryQueryContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(182);
        queryPrimary();
        _ctx->stop = _input->LT(-1);
        setState(189);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                auto newContext
                    = _tracker.createInstance<SetOperationContext>(_tracker.createInstance<QueryTermContext>(parentContext, parentState));
                _localctx = newContext;
                newContext->left = previousContext;
                pushNewRecursionContext(newContext, startState, RuleQueryTerm);
                setState(184);

                if (!(precpred(_ctx, 1)))
                    throw FailedPredicateException(this, "precpred(_ctx, 1)");
                setState(185);
                antlrcpp::downCast<SetOperationContext*>(_localctx)->setoperator = match(NebulaSQLParser::UNION);
                setState(186);
                antlrcpp::downCast<SetOperationContext*>(_localctx)->right = queryTerm(2);
            }
            setState(191);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::QueryPrimaryContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQueryPrimary;
}

void NebulaSQLParser::QueryPrimaryContext::copyFrom(QueryPrimaryContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryContext::SubqueryContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SubqueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubquery(this);
}
void NebulaSQLParser::SubqueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubquery(this);
}
//----------------- QueryPrimaryDefaultContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::QueryPrimaryDefaultContext::querySpecification()
{
    return getRuleContext<NebulaSQLParser::QuerySpecificationContext>(0);
}

NebulaSQLParser::QueryPrimaryDefaultContext::QueryPrimaryDefaultContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::QueryPrimaryDefaultContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQueryPrimaryDefault(this);
}
void NebulaSQLParser::QueryPrimaryDefaultContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQueryPrimaryDefault(this);
}
//----------------- InlineTableDefault1Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault1Context::inlineTable()
{
    return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault1Context::InlineTableDefault1Context(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::InlineTableDefault1Context::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterInlineTableDefault1(this);
}
void NebulaSQLParser::InlineTableDefault1Context::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitInlineTableDefault1(this);
}
//----------------- FromStmtContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext* NebulaSQLParser::FromStmtContext::fromStatement()
{
    return getRuleContext<NebulaSQLParser::FromStatementContext>(0);
}

NebulaSQLParser::FromStmtContext::FromStmtContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::FromStmtContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromStmt(this);
}
void NebulaSQLParser::FromStmtContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromStmt(this);
}
//----------------- TableContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TableContext::TABLE()
{
    return getToken(NebulaSQLParser::TABLE, 0);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableContext::multipartIdentifier()
{
    return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableContext::TableContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TableContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTable(this);
}
void NebulaSQLParser::TableContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTable(this);
}
NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::queryPrimary()
{
    QueryPrimaryContext* _localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 10, NebulaSQLParser::RuleQueryPrimary);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(201);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::SELECT: {
                _localctx = _tracker.createInstance<NebulaSQLParser::QueryPrimaryDefaultContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(192);
                querySpecification();
                break;
            }

            case NebulaSQLParser::FROM: {
                _localctx = _tracker.createInstance<NebulaSQLParser::FromStmtContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(193);
                fromStatement();
                break;
            }

            case NebulaSQLParser::TABLE: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TableContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(194);
                match(NebulaSQLParser::TABLE);
                setState(195);
                multipartIdentifier();
                break;
            }

            case NebulaSQLParser::VALUES: {
                _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault1Context>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(196);
                inlineTable();
                break;
            }

            case NebulaSQLParser::T__2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::SubqueryContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(197);
                match(NebulaSQLParser::T__2);
                setState(198);
                query();
                setState(199);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::QuerySpecificationContext::selectClause()
{
    return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::QuerySpecificationContext::fromClause()
{
    return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::QuerySpecificationContext::whereClause()
{
    return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::QuerySpecificationContext::windowedAggregationClause()
{
    return getRuleContext<NebulaSQLParser::WindowedAggregationClauseContext>(0);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::QuerySpecificationContext::havingClause()
{
    return getRuleContext<NebulaSQLParser::HavingClauseContext>(0);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::QuerySpecificationContext::sinkClause()
{
    return getRuleContext<NebulaSQLParser::SinkClauseContext>(0);
}


size_t NebulaSQLParser::QuerySpecificationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQuerySpecification;
}

void NebulaSQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuerySpecification(this);
}

void NebulaSQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuerySpecification(this);
}

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::querySpecification()
{
    QuerySpecificationContext* _localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 12, NebulaSQLParser::RuleQuerySpecification);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(203);
        selectClause();
        setState(204);
        fromClause();
        setState(206);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx))
        {
            case 1: {
                setState(205);
                whereClause();
                break;
            }

            default:
                break;
        }
        setState(209);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx))
        {
            case 1: {
                setState(208);
                windowedAggregationClause();
                break;
            }

            default:
                break;
        }
        setState(212);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx))
        {
            case 1: {
                setState(211);
                havingClause();
                break;
            }

            default:
                break;
        }
        setState(215);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx))
        {
            case 1: {
                setState(214);
                sinkClause();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

NebulaSQLParser::FromClauseContext::FromClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::FromClauseContext::FROM()
{
    return getToken(NebulaSQLParser::FROM, 0);
}

std::vector<NebulaSQLParser::RelationContext*> NebulaSQLParser::FromClauseContext::relation()
{
    return getRuleContexts<NebulaSQLParser::RelationContext>();
}

NebulaSQLParser::RelationContext* NebulaSQLParser::FromClauseContext::relation(size_t i)
{
    return getRuleContext<NebulaSQLParser::RelationContext>(i);
}


size_t NebulaSQLParser::FromClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFromClause;
}

void NebulaSQLParser::FromClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromClause(this);
}

void NebulaSQLParser::FromClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromClause(this);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::fromClause()
{
    FromClauseContext* _localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
    enterRule(_localctx, 14, NebulaSQLParser::RuleFromClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(217);
        match(NebulaSQLParser::FROM);
        setState(218);
        relation();
        setState(223);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(219);
                match(NebulaSQLParser::T__1);
                setState(220);
                relation();
            }
            setState(225);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext::RelationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::RelationContext::relationPrimary()
{
    return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

std::vector<NebulaSQLParser::JoinRelationContext*> NebulaSQLParser::RelationContext::joinRelation()
{
    return getRuleContexts<NebulaSQLParser::JoinRelationContext>();
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::RelationContext::joinRelation(size_t i)
{
    return getRuleContext<NebulaSQLParser::JoinRelationContext>(i);
}


size_t NebulaSQLParser::RelationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleRelation;
}

void NebulaSQLParser::RelationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterRelation(this);
}

void NebulaSQLParser::RelationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitRelation(this);
}

NebulaSQLParser::RelationContext* NebulaSQLParser::relation()
{
    RelationContext* _localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
    enterRule(_localctx, 16, NebulaSQLParser::RuleRelation);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(226);
        relationPrimary();
        setState(230);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(227);
                joinRelation();
            }
            setState(232);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- JoinRelationContext ------------------------------------------------------------------

NebulaSQLParser::JoinRelationContext::JoinRelationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::JOIN()
{
    return getToken(NebulaSQLParser::JOIN, 0);
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::JoinRelationContext::relationPrimary()
{
    return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::JoinRelationContext::joinType()
{
    return getRuleContext<NebulaSQLParser::JoinTypeContext>(0);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::JoinRelationContext::joinCriteria()
{
    return getRuleContext<NebulaSQLParser::JoinCriteriaContext>(0);
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::NATURAL()
{
    return getToken(NebulaSQLParser::NATURAL, 0);
}


size_t NebulaSQLParser::JoinRelationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleJoinRelation;
}

void NebulaSQLParser::JoinRelationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterJoinRelation(this);
}

void NebulaSQLParser::JoinRelationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitJoinRelation(this);
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::joinRelation()
{
    JoinRelationContext* _localctx = _tracker.createInstance<JoinRelationContext>(_ctx, getState());
    enterRule(_localctx, 18, NebulaSQLParser::RuleJoinRelation);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(244);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::INNER:
            case NebulaSQLParser::JOIN: {
                enterOuterAlt(_localctx, 1);
                setState(233);
                joinType();
                setState(234);
                match(NebulaSQLParser::JOIN);
                setState(235);
                antlrcpp::downCast<JoinRelationContext*>(_localctx)->right = relationPrimary();
                setState(237);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx))
                {
                    case 1: {
                        setState(236);
                        joinCriteria();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case NebulaSQLParser::NATURAL: {
                enterOuterAlt(_localctx, 2);
                setState(239);
                match(NebulaSQLParser::NATURAL);
                setState(240);
                joinType();
                setState(241);
                match(NebulaSQLParser::JOIN);
                setState(242);
                antlrcpp::downCast<JoinRelationContext*>(_localctx)->right = relationPrimary();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- JoinTypeContext ------------------------------------------------------------------

NebulaSQLParser::JoinTypeContext::JoinTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::JoinTypeContext::INNER()
{
    return getToken(NebulaSQLParser::INNER, 0);
}


size_t NebulaSQLParser::JoinTypeContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleJoinType;
}

void NebulaSQLParser::JoinTypeContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterJoinType(this);
}

void NebulaSQLParser::JoinTypeContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitJoinType(this);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::joinType()
{
    JoinTypeContext* _localctx = _tracker.createInstance<JoinTypeContext>(_ctx, getState());
    enterRule(_localctx, 20, NebulaSQLParser::RuleJoinType);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(247);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::INNER)
        {
            setState(246);
            match(NebulaSQLParser::INNER);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- JoinCriteriaContext ------------------------------------------------------------------

NebulaSQLParser::JoinCriteriaContext::JoinCriteriaContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::JoinCriteriaContext::ON()
{
    return getToken(NebulaSQLParser::ON, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::JoinCriteriaContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::JoinCriteriaContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleJoinCriteria;
}

void NebulaSQLParser::JoinCriteriaContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterJoinCriteria(this);
}

void NebulaSQLParser::JoinCriteriaContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitJoinCriteria(this);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::joinCriteria()
{
    JoinCriteriaContext* _localctx = _tracker.createInstance<JoinCriteriaContext>(_ctx, getState());
    enterRule(_localctx, 22, NebulaSQLParser::RuleJoinCriteria);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(249);
        match(NebulaSQLParser::ON);
        setState(250);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- RelationPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::RelationPrimaryContext::RelationPrimaryContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::RelationPrimaryContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleRelationPrimary;
}

void NebulaSQLParser::RelationPrimaryContext::copyFrom(RelationPrimaryContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TableValuedFunctionContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::TableValuedFunctionContext::functionTable()
{
    return getRuleContext<NebulaSQLParser::FunctionTableContext>(0);
}

NebulaSQLParser::TableValuedFunctionContext::TableValuedFunctionContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TableValuedFunctionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTableValuedFunction(this);
}
void NebulaSQLParser::TableValuedFunctionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTableValuedFunction(this);
}
//----------------- InlineTableDefault2Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault2Context::inlineTable()
{
    return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault2Context::InlineTableDefault2Context(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::InlineTableDefault2Context::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterInlineTableDefault2(this);
}
void NebulaSQLParser::InlineTableDefault2Context::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitInlineTableDefault2(this);
}
//----------------- AliasedRelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext* NebulaSQLParser::AliasedRelationContext::relation()
{
    return getRuleContext<NebulaSQLParser::RelationContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedRelationContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedRelationContext::AliasedRelationContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::AliasedRelationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAliasedRelation(this);
}
void NebulaSQLParser::AliasedRelationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAliasedRelation(this);
}
//----------------- AliasedQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::AliasedQueryContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedQueryContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedQueryContext::AliasedQueryContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::AliasedQueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAliasedQuery(this);
}
void NebulaSQLParser::AliasedQueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAliasedQuery(this);
}
//----------------- TableNameContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableNameContext::multipartIdentifier()
{
    return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::TableNameContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::TableNameContext::TableNameContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TableNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTableName(this);
}
void NebulaSQLParser::TableNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTableName(this);
}
NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::relationPrimary()
{
    RelationPrimaryContext* _localctx = _tracker.createInstance<RelationPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 24, NebulaSQLParser::RuleRelationPrimary);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(267);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TableNameContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(252);
                multipartIdentifier();
                setState(253);
                tableAlias();
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::AliasedQueryContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(255);
                match(NebulaSQLParser::T__2);
                setState(256);
                query();
                setState(257);
                match(NebulaSQLParser::T__3);
                setState(258);
                tableAlias();
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::AliasedRelationContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(260);
                match(NebulaSQLParser::T__2);
                setState(261);
                relation();
                setState(262);
                match(NebulaSQLParser::T__3);
                setState(263);
                tableAlias();
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault2Context>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(265);
                inlineTable();
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TableValuedFunctionContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(266);
                functionTable();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FunctionTableContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext::FunctionTableContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::FunctionTableContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::FunctionTableContext::errorCapturingIdentifier()
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::FunctionTableContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionTableContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::FunctionTableContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFunctionTable;
}

void NebulaSQLParser::FunctionTableContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunctionTable(this);
}

void NebulaSQLParser::FunctionTableContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunctionTable(this);
}

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::functionTable()
{
    FunctionTableContext* _localctx = _tracker.createInstance<FunctionTableContext>(_ctx, getState());
    enterRule(_localctx, 26, NebulaSQLParser::RuleFunctionTable);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(269);
        antlrcpp::downCast<FunctionTableContext*>(_localctx)->funcName = errorCapturingIdentifier();
        setState(270);
        match(NebulaSQLParser::T__2);
        setState(279);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx))
        {
            case 1: {
                setState(271);
                expression();
                setState(276);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(272);
                    match(NebulaSQLParser::T__1);
                    setState(273);
                    expression();
                    setState(278);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                break;
            }

            default:
                break;
        }
        setState(281);
        match(NebulaSQLParser::T__3);
        setState(282);
        tableAlias();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FromStatementContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext::FromStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::FromStatementContext::fromClause()
{
    return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

std::vector<NebulaSQLParser::FromStatementBodyContext*> NebulaSQLParser::FromStatementContext::fromStatementBody()
{
    return getRuleContexts<NebulaSQLParser::FromStatementBodyContext>();
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::FromStatementContext::fromStatementBody(size_t i)
{
    return getRuleContext<NebulaSQLParser::FromStatementBodyContext>(i);
}


size_t NebulaSQLParser::FromStatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFromStatement;
}

void NebulaSQLParser::FromStatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromStatement(this);
}

void NebulaSQLParser::FromStatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromStatement(this);
}

NebulaSQLParser::FromStatementContext* NebulaSQLParser::fromStatement()
{
    FromStatementContext* _localctx = _tracker.createInstance<FromStatementContext>(_ctx, getState());
    enterRule(_localctx, 28, NebulaSQLParser::RuleFromStatement);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(284);
        fromClause();
        setState(286);
        _errHandler->sync(this);
        alt = 1;
        do
        {
            switch (alt)
            {
                case 1: {
                    setState(285);
                    fromStatementBody();
                    break;
                }

                default:
                    throw NoViableAltException(this);
            }
            setState(288);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FromStatementBodyContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementBodyContext::FromStatementBodyContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::FromStatementBodyContext::selectClause()
{
    return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::FromStatementBodyContext::whereClause()
{
    return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::FromStatementBodyContext::aggregationClause()
{
    return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}


size_t NebulaSQLParser::FromStatementBodyContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFromStatementBody;
}

void NebulaSQLParser::FromStatementBodyContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromStatementBody(this);
}

void NebulaSQLParser::FromStatementBodyContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromStatementBody(this);
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::fromStatementBody()
{
    FromStatementBodyContext* _localctx = _tracker.createInstance<FromStatementBodyContext>(_ctx, getState());
    enterRule(_localctx, 30, NebulaSQLParser::RuleFromStatementBody);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(290);
        selectClause();
        setState(292);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx))
        {
            case 1: {
                setState(291);
                whereClause();
                break;
            }

            default:
                break;
        }
        setState(295);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx))
        {
            case 1: {
                setState(294);
                aggregationClause();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SelectClauseContext ------------------------------------------------------------------

NebulaSQLParser::SelectClauseContext::SelectClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SelectClauseContext::SELECT()
{
    return getToken(NebulaSQLParser::SELECT, 0);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::SelectClauseContext::namedExpressionSeq()
{
    return getRuleContext<NebulaSQLParser::NamedExpressionSeqContext>(0);
}

std::vector<NebulaSQLParser::HintContext*> NebulaSQLParser::SelectClauseContext::hint()
{
    return getRuleContexts<NebulaSQLParser::HintContext>();
}

NebulaSQLParser::HintContext* NebulaSQLParser::SelectClauseContext::hint(size_t i)
{
    return getRuleContext<NebulaSQLParser::HintContext>(i);
}


size_t NebulaSQLParser::SelectClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSelectClause;
}

void NebulaSQLParser::SelectClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSelectClause(this);
}

void NebulaSQLParser::SelectClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSelectClause(this);
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::selectClause()
{
    SelectClauseContext* _localctx = _tracker.createInstance<SelectClauseContext>(_ctx, getState());
    enterRule(_localctx, 32, NebulaSQLParser::RuleSelectClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(297);
        match(NebulaSQLParser::SELECT);
        setState(301);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(298);
                antlrcpp::downCast<SelectClauseContext*>(_localctx)->hintContext = hint();
                antlrcpp::downCast<SelectClauseContext*>(_localctx)->hints.push_back(
                    antlrcpp::downCast<SelectClauseContext*>(_localctx)->hintContext);
            }
            setState(303);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
        }
        setState(304);
        namedExpressionSeq();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

NebulaSQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::WhereClauseContext::WHERE()
{
    return getToken(NebulaSQLParser::WHERE, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::WhereClauseContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::WhereClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWhereClause;
}

void NebulaSQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWhereClause(this);
}

void NebulaSQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWhereClause(this);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::whereClause()
{
    WhereClauseContext* _localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
    enterRule(_localctx, 34, NebulaSQLParser::RuleWhereClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(306);
        match(NebulaSQLParser::WHERE);
        setState(307);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

NebulaSQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::HavingClauseContext::HAVING()
{
    return getToken(NebulaSQLParser::HAVING, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::HavingClauseContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::HavingClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleHavingClause;
}

void NebulaSQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterHavingClause(this);
}

void NebulaSQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitHavingClause(this);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::havingClause()
{
    HavingClauseContext* _localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
    enterRule(_localctx, 36, NebulaSQLParser::RuleHavingClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(309);
        match(NebulaSQLParser::HAVING);
        setState(310);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- InlineTableContext ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext::InlineTableContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::InlineTableContext::VALUES()
{
    return getToken(NebulaSQLParser::VALUES, 0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::InlineTableContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::InlineTableContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::InlineTableContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}


size_t NebulaSQLParser::InlineTableContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleInlineTable;
}

void NebulaSQLParser::InlineTableContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterInlineTable(this);
}

void NebulaSQLParser::InlineTableContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitInlineTable(this);
}

NebulaSQLParser::InlineTableContext* NebulaSQLParser::inlineTable()
{
    InlineTableContext* _localctx = _tracker.createInstance<InlineTableContext>(_ctx, getState());
    enterRule(_localctx, 38, NebulaSQLParser::RuleInlineTable);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(312);
        match(NebulaSQLParser::VALUES);
        setState(313);
        expression();
        setState(318);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(314);
                match(NebulaSQLParser::T__1);
                setState(315);
                expression();
            }
            setState(320);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        }
        setState(321);
        tableAlias();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

NebulaSQLParser::TableAliasContext::TableAliasContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::TableAliasContext::strictIdentifier()
{
    return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TableAliasContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::TableAliasContext::identifierList()
{
    return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}


size_t NebulaSQLParser::TableAliasContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTableAlias;
}

void NebulaSQLParser::TableAliasContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTableAlias(this);
}

void NebulaSQLParser::TableAliasContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTableAlias(this);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::tableAlias()
{
    TableAliasContext* _localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
    enterRule(_localctx, 40, NebulaSQLParser::RuleTableAlias);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(330);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx))
        {
            case 1: {
                setState(324);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx))
                {
                    case 1: {
                        setState(323);
                        match(NebulaSQLParser::AS);
                        break;
                    }

                    default:
                        break;
                }
                setState(326);
                strictIdentifier();
                setState(328);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx))
                {
                    case 1: {
                        setState(327);
                        identifierList();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MultipartIdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierListContext::MultipartIdentifierListContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::MultipartIdentifierContext*> NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier()
{
    return getRuleContexts<NebulaSQLParser::MultipartIdentifierContext>();
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierListContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleMultipartIdentifierList;
}

void NebulaSQLParser::MultipartIdentifierListContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterMultipartIdentifierList(this);
}

void NebulaSQLParser::MultipartIdentifierListContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitMultipartIdentifierList(this);
}

NebulaSQLParser::MultipartIdentifierListContext* NebulaSQLParser::multipartIdentifierList()
{
    MultipartIdentifierListContext* _localctx = _tracker.createInstance<MultipartIdentifierListContext>(_ctx, getState());
    enterRule(_localctx, 42, NebulaSQLParser::RuleMultipartIdentifierList);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(332);
        multipartIdentifier();
        setState(337);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1)
        {
            setState(333);
            match(NebulaSQLParser::T__1);
            setState(334);
            multipartIdentifier();
            setState(339);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MultipartIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext::MultipartIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext*> NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier()
{
    return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleMultipartIdentifier;
}

void NebulaSQLParser::MultipartIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterMultipartIdentifier(this);
}

void NebulaSQLParser::MultipartIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitMultipartIdentifier(this);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::multipartIdentifier()
{
    MultipartIdentifierContext* _localctx = _tracker.createInstance<MultipartIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 44, NebulaSQLParser::RuleMultipartIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(340);
        antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->parts.push_back(
            antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext);
        setState(345);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(341);
                match(NebulaSQLParser::T__4);
                setState(342);
                antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
                antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->parts.push_back(
                    antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext);
            }
            setState(347);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NamedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionContext::NamedExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::NamedExpressionContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::NamedExpressionContext::identifierList()
{
    return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* NebulaSQLParser::NamedExpressionContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::NamedExpressionContext::errorCapturingIdentifier()
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}


size_t NebulaSQLParser::NamedExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNamedExpression;
}

void NebulaSQLParser::NamedExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNamedExpression(this);
}

void NebulaSQLParser::NamedExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNamedExpression(this);
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::namedExpression()
{
    NamedExpressionContext* _localctx = _tracker.createInstance<NamedExpressionContext>(_ctx, getState());
    enterRule(_localctx, 46, NebulaSQLParser::RuleNamedExpression);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(348);
        expression();
        setState(356);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx))
        {
            case 1: {
                setState(350);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx))
                {
                    case 1: {
                        setState(349);
                        match(NebulaSQLParser::AS);
                        break;
                    }

                    default:
                        break;
                }
                setState(354);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx))
                {
                    case 1: {
                        setState(352);
                        antlrcpp::downCast<NamedExpressionContext*>(_localctx)->name = errorCapturingIdentifier();
                        break;
                    }

                    case 2: {
                        setState(353);
                        identifierList();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext::IdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::IdentifierContext::strictIdentifier()
{
    return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::IdentifierContext::strictNonReserved()
{
    return getRuleContext<NebulaSQLParser::StrictNonReservedContext>(0);
}


size_t NebulaSQLParser::IdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleIdentifier;
}

void NebulaSQLParser::IdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifier(this);
}

void NebulaSQLParser::IdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifier(this);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::identifier()
{
    IdentifierContext* _localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
    enterRule(_localctx, 48, NebulaSQLParser::RuleIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(361);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(358);
                strictIdentifier();
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(359);

                if (!(!SQL_standard_keyword_behavior))
                    throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
                setState(360);
                strictNonReserved();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StrictIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::StrictIdentifierContext::StrictIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::StrictIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStrictIdentifier;
}

void NebulaSQLParser::StrictIdentifierContext::copyFrom(StrictIdentifierContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- QuotedIdentifierAlternativeContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::QuotedIdentifierAlternativeContext::quotedIdentifier()
{
    return getRuleContext<NebulaSQLParser::QuotedIdentifierContext>(0);
}

NebulaSQLParser::QuotedIdentifierAlternativeContext::QuotedIdentifierAlternativeContext(StrictIdentifierContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::QuotedIdentifierAlternativeContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuotedIdentifierAlternative(this);
}
void NebulaSQLParser::QuotedIdentifierAlternativeContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuotedIdentifierAlternative(this);
}
//----------------- UnquotedIdentifierContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnquotedIdentifierContext::IDENTIFIER()
{
    return getToken(NebulaSQLParser::IDENTIFIER, 0);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::ansiNonReserved()
{
    return getRuleContext<NebulaSQLParser::AnsiNonReservedContext>(0);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::nonReserved()
{
    return getRuleContext<NebulaSQLParser::NonReservedContext>(0);
}

NebulaSQLParser::UnquotedIdentifierContext::UnquotedIdentifierContext(StrictIdentifierContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::UnquotedIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnquotedIdentifier(this);
}
void NebulaSQLParser::UnquotedIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnquotedIdentifier(this);
}
NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::strictIdentifier()
{
    StrictIdentifierContext* _localctx = _tracker.createInstance<StrictIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 50, NebulaSQLParser::RuleStrictIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(369);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(363);
                match(NebulaSQLParser::IDENTIFIER);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::QuotedIdentifierAlternativeContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(364);
                quotedIdentifier();
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(365);

                if (!(SQL_standard_keyword_behavior))
                    throw FailedPredicateException(this, "SQL_standard_keyword_behavior");
                setState(366);
                ansiNonReserved();
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(367);

                if (!(!SQL_standard_keyword_behavior))
                    throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
                setState(368);
                nonReserved();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QuotedIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext::QuotedIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::QuotedIdentifierContext::BACKQUOTED_IDENTIFIER()
{
    return getToken(NebulaSQLParser::BACKQUOTED_IDENTIFIER, 0);
}


size_t NebulaSQLParser::QuotedIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQuotedIdentifier;
}

void NebulaSQLParser::QuotedIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuotedIdentifier(this);
}

void NebulaSQLParser::QuotedIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuotedIdentifier(this);
}

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::quotedIdentifier()
{
    QuotedIdentifierContext* _localctx = _tracker.createInstance<QuotedIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 52, NebulaSQLParser::RuleQuotedIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(371);
        match(NebulaSQLParser::BACKQUOTED_IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::IdentifierListContext::identifierSeq()
{
    return getRuleContext<NebulaSQLParser::IdentifierSeqContext>(0);
}


size_t NebulaSQLParser::IdentifierListContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleIdentifierList;
}

void NebulaSQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifierList(this);
}

void NebulaSQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifierList(this);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::identifierList()
{
    IdentifierListContext* _localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
    enterRule(_localctx, 54, NebulaSQLParser::RuleIdentifierList);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(373);
        match(NebulaSQLParser::T__2);
        setState(374);
        identifierSeq();
        setState(375);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierSeqContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierSeqContext::IdentifierSeqContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext*> NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier()
{
    return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::IdentifierSeqContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleIdentifierSeq;
}

void NebulaSQLParser::IdentifierSeqContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifierSeq(this);
}

void NebulaSQLParser::IdentifierSeqContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifierSeq(this);
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::identifierSeq()
{
    IdentifierSeqContext* _localctx = _tracker.createInstance<IdentifierSeqContext>(_ctx, getState());
    enterRule(_localctx, 56, NebulaSQLParser::RuleIdentifierSeq);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(377);
        antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->ident.push_back(
            antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext);
        setState(382);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1)
        {
            setState(378);
            match(NebulaSQLParser::T__1);
            setState(379);
            antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
            antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->ident.push_back(
                antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext);
            setState(384);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ErrorCapturingIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierContext::ErrorCapturingIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorCapturingIdentifierContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::ErrorCapturingIdentifierContext::errorCapturingIdentifierExtra()
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierExtraContext>(0);
}


size_t NebulaSQLParser::ErrorCapturingIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleErrorCapturingIdentifier;
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterErrorCapturingIdentifier(this);
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitErrorCapturingIdentifier(this);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::errorCapturingIdentifier()
{
    ErrorCapturingIdentifierContext* _localctx = _tracker.createInstance<ErrorCapturingIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 58, NebulaSQLParser::RuleErrorCapturingIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(385);
        identifier();
        setState(386);
        errorCapturingIdentifierExtra();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ErrorCapturingIdentifierExtraContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierExtraContext::ErrorCapturingIdentifierExtraContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ErrorCapturingIdentifierExtraContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleErrorCapturingIdentifierExtra;
}

void NebulaSQLParser::ErrorCapturingIdentifierExtraContext::copyFrom(ErrorCapturingIdentifierExtraContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorIdentContext ------------------------------------------------------------------

std::vector<tree::TerminalNode*> NebulaSQLParser::ErrorIdentContext::MINUS()
{
    return getTokens(NebulaSQLParser::MINUS);
}

tree::TerminalNode* NebulaSQLParser::ErrorIdentContext::MINUS(size_t i)
{
    return getToken(NebulaSQLParser::MINUS, i);
}

std::vector<NebulaSQLParser::IdentifierContext*> NebulaSQLParser::ErrorIdentContext::identifier()
{
    return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorIdentContext::identifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}

NebulaSQLParser::ErrorIdentContext::ErrorIdentContext(ErrorCapturingIdentifierExtraContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ErrorIdentContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterErrorIdent(this);
}
void NebulaSQLParser::ErrorIdentContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitErrorIdent(this);
}
//----------------- RealIdentContext ------------------------------------------------------------------

NebulaSQLParser::RealIdentContext::RealIdentContext(ErrorCapturingIdentifierExtraContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::RealIdentContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterRealIdent(this);
}
void NebulaSQLParser::RealIdentContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitRealIdent(this);
}
NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::errorCapturingIdentifierExtra()
{
    ErrorCapturingIdentifierExtraContext* _localctx = _tracker.createInstance<ErrorCapturingIdentifierExtraContext>(_ctx, getState());
    enterRule(_localctx, 60, NebulaSQLParser::RuleErrorCapturingIdentifierExtra);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        setState(395);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::ErrorIdentContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(390);
                _errHandler->sync(this);
                alt = 1;
                do
                {
                    switch (alt)
                    {
                        case 1: {
                            setState(388);
                            match(NebulaSQLParser::MINUS);
                            setState(389);
                            identifier();
                            break;
                        }

                        default:
                            throw NoViableAltException(this);
                    }
                    setState(392);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
                } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::RealIdentContext>(_localctx);
                enterOuterAlt(_localctx, 2);

                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NamedExpressionSeqContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionSeqContext::NamedExpressionSeqContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::NamedExpressionContext*> NebulaSQLParser::NamedExpressionSeqContext::namedExpression()
{
    return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::NamedExpressionSeqContext::namedExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}


size_t NebulaSQLParser::NamedExpressionSeqContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNamedExpressionSeq;
}

void NebulaSQLParser::NamedExpressionSeqContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNamedExpressionSeq(this);
}

void NebulaSQLParser::NamedExpressionSeqContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNamedExpressionSeq(this);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::namedExpressionSeq()
{
    NamedExpressionSeqContext* _localctx = _tracker.createInstance<NamedExpressionSeqContext>(_ctx, getState());
    enterRule(_localctx, 62, NebulaSQLParser::RuleNamedExpressionSeq);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(397);
        namedExpression();
        setState(402);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(398);
                match(NebulaSQLParser::T__1);
                setState(399);
                namedExpression();
            }
            setState(404);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext::ExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::ExpressionContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::ExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleExpression;
}

void NebulaSQLParser::ExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterExpression(this);
}

void NebulaSQLParser::ExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitExpression(this);
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::expression()
{
    ExpressionContext* _localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
    enterRule(_localctx, 64, NebulaSQLParser::RuleExpression);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(405);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BooleanExpressionContext ------------------------------------------------------------------

NebulaSQLParser::BooleanExpressionContext::BooleanExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::BooleanExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleBooleanExpression;
}

void NebulaSQLParser::BooleanExpressionContext::copyFrom(BooleanExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- LogicalNotContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LogicalNotContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalNotContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}

NebulaSQLParser::LogicalNotContext::LogicalNotContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::LogicalNotContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogicalNot(this);
}
void NebulaSQLParser::LogicalNotContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogicalNot(this);
}
//----------------- PredicatedContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicatedContext::valueExpression()
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::PredicatedContext::predicate()
{
    return getRuleContext<NebulaSQLParser::PredicateContext>(0);
}

NebulaSQLParser::PredicatedContext::PredicatedContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::PredicatedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterPredicated(this);
}
void NebulaSQLParser::PredicatedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitPredicated(this);
}
//----------------- ExistsContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExistsContext::EXISTS()
{
    return getToken(NebulaSQLParser::EXISTS, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::ExistsContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::ExistsContext::ExistsContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ExistsContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterExists(this);
}
void NebulaSQLParser::ExistsContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitExists(this);
}
//----------------- LogicalBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::BooleanExpressionContext*> NebulaSQLParser::LogicalBinaryContext::booleanExpression()
{
    return getRuleContexts<NebulaSQLParser::BooleanExpressionContext>();
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalBinaryContext::booleanExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::AND()
{
    return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::OR()
{
    return getToken(NebulaSQLParser::OR, 0);
}

NebulaSQLParser::LogicalBinaryContext::LogicalBinaryContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::LogicalBinaryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogicalBinary(this);
}
void NebulaSQLParser::LogicalBinaryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogicalBinary(this);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression()
{
    return booleanExpression(0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::BooleanExpressionContext* _localctx = _tracker.createInstance<BooleanExpressionContext>(_ctx, parentState);
    NebulaSQLParser::BooleanExpressionContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 66;
    enterRecursionRule(_localctx, 66, NebulaSQLParser::RuleBooleanExpression, precedence);


#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(419);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<LogicalNotContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;

                setState(408);
                match(NebulaSQLParser::NOT);
                setState(409);
                booleanExpression(5);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<ExistsContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(410);
                match(NebulaSQLParser::EXISTS);
                setState(411);
                match(NebulaSQLParser::T__2);
                setState(412);
                query();
                setState(413);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<PredicatedContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(415);
                valueExpression(0);
                setState(417);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx))
                {
                    case 1: {
                        setState(416);
                        predicate();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(429);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                setState(427);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx))
                {
                    case 1: {
                        auto newContext = _tracker.createInstance<LogicalBinaryContext>(
                            _tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
                        setState(421);

                        if (!(precpred(_ctx, 2)))
                            throw FailedPredicateException(this, "precpred(_ctx, 2)");
                        setState(422);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->op = match(NebulaSQLParser::AND);
                        setState(423);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->right = booleanExpression(3);
                        break;
                    }

                    case 2: {
                        auto newContext = _tracker.createInstance<LogicalBinaryContext>(
                            _tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
                        setState(424);

                        if (!(precpred(_ctx, 1)))
                            throw FailedPredicateException(this, "precpred(_ctx, 1)");
                        setState(425);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->op = match(NebulaSQLParser::OR);
                        setState(426);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->right = booleanExpression(2);
                        break;
                    }

                    default:
                        break;
                }
            }
            setState(431);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- WindowedAggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowedAggregationClauseContext::WindowedAggregationClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::windowClause()
{
    return getRuleContext<NebulaSQLParser::WindowClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::aggregationClause()
{
    return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::watermarkClause()
{
    return getRuleContext<NebulaSQLParser::WatermarkClauseContext>(0);
}


size_t NebulaSQLParser::WindowedAggregationClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWindowedAggregationClause;
}

void NebulaSQLParser::WindowedAggregationClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWindowedAggregationClause(this);
}

void NebulaSQLParser::WindowedAggregationClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWindowedAggregationClause(this);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::windowedAggregationClause()
{
    WindowedAggregationClauseContext* _localctx = _tracker.createInstance<WindowedAggregationClauseContext>(_ctx, getState());
    enterRule(_localctx, 68, NebulaSQLParser::RuleWindowedAggregationClause);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(433);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::GROUP)
        {
            setState(432);
            aggregationClause();
        }
        setState(435);
        windowClause();
        setState(437);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx))
        {
            case 1: {
                setState(436);
                watermarkClause();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::AggregationClauseContext::AggregationClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUP()
{
    return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::AggregationClauseContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::AggregationClauseContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::WITH()
{
    return getToken(NebulaSQLParser::WITH, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::SETS()
{
    return getToken(NebulaSQLParser::SETS, 0);
}

std::vector<NebulaSQLParser::GroupingSetContext*> NebulaSQLParser::AggregationClauseContext::groupingSet()
{
    return getRuleContexts<NebulaSQLParser::GroupingSetContext>();
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::AggregationClauseContext::groupingSet(size_t i)
{
    return getRuleContext<NebulaSQLParser::GroupingSetContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::ROLLUP()
{
    return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::CUBE()
{
    return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUPING()
{
    return getToken(NebulaSQLParser::GROUPING, 0);
}


size_t NebulaSQLParser::AggregationClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleAggregationClause;
}

void NebulaSQLParser::AggregationClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAggregationClause(this);
}

void NebulaSQLParser::AggregationClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAggregationClause(this);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::aggregationClause()
{
    AggregationClauseContext* _localctx = _tracker.createInstance<AggregationClauseContext>(_ctx, getState());
    enterRule(_localctx, 70, NebulaSQLParser::RuleAggregationClause);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        setState(483);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(439);
                match(NebulaSQLParser::GROUP);
                setState(440);
                match(NebulaSQLParser::BY);
                setState(441);
                antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext = expression();
                antlrcpp::downCast<AggregationClauseContext*>(_localctx)->groupingExpressions.push_back(
                    antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext);
                setState(446);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
                {
                    if (alt == 1)
                    {
                        setState(442);
                        match(NebulaSQLParser::T__1);
                        setState(443);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext = expression();
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->groupingExpressions.push_back(
                            antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext);
                    }
                    setState(448);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
                }
                setState(466);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx))
                {
                    case 1: {
                        setState(449);
                        match(NebulaSQLParser::WITH);
                        setState(450);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::ROLLUP);
                        break;
                    }

                    case 2: {
                        setState(451);
                        match(NebulaSQLParser::WITH);
                        setState(452);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::CUBE);
                        break;
                    }

                    case 3: {
                        setState(453);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
                        setState(454);
                        match(NebulaSQLParser::SETS);
                        setState(455);
                        match(NebulaSQLParser::T__2);
                        setState(456);
                        groupingSet();
                        setState(461);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(457);
                            match(NebulaSQLParser::T__1);
                            setState(458);
                            groupingSet();
                            setState(463);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        setState(464);
                        match(NebulaSQLParser::T__3);
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(468);
                match(NebulaSQLParser::GROUP);
                setState(469);
                match(NebulaSQLParser::BY);
                setState(470);
                antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
                setState(471);
                match(NebulaSQLParser::SETS);
                setState(472);
                match(NebulaSQLParser::T__2);
                setState(473);
                groupingSet();
                setState(478);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(474);
                    match(NebulaSQLParser::T__1);
                    setState(475);
                    groupingSet();
                    setState(480);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(481);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- GroupingSetContext ------------------------------------------------------------------

NebulaSQLParser::GroupingSetContext::GroupingSetContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::GroupingSetContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::GroupingSetContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::GroupingSetContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleGroupingSet;
}

void NebulaSQLParser::GroupingSetContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterGroupingSet(this);
}

void NebulaSQLParser::GroupingSetContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitGroupingSet(this);
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::groupingSet()
{
    GroupingSetContext* _localctx = _tracker.createInstance<GroupingSetContext>(_ctx, getState());
    enterRule(_localctx, 72, NebulaSQLParser::RuleGroupingSet);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(498);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(485);
                match(NebulaSQLParser::T__2);
                setState(494);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx))
                {
                    case 1: {
                        setState(486);
                        expression();
                        setState(491);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(487);
                            match(NebulaSQLParser::T__1);
                            setState(488);
                            expression();
                            setState(493);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        break;
                    }

                    default:
                        break;
                }
                setState(496);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(497);
                expression();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::WindowClauseContext::WINDOW()
{
    return getToken(NebulaSQLParser::WINDOW, 0);
}

NebulaSQLParser::WindowSpecContext* NebulaSQLParser::WindowClauseContext::windowSpec()
{
    return getRuleContext<NebulaSQLParser::WindowSpecContext>(0);
}


size_t NebulaSQLParser::WindowClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWindowClause;
}

void NebulaSQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWindowClause(this);
}

void NebulaSQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWindowClause(this);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::windowClause()
{
    WindowClauseContext* _localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
    enterRule(_localctx, 74, NebulaSQLParser::RuleWindowClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(500);
        match(NebulaSQLParser::WINDOW);
        setState(501);
        windowSpec();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WatermarkClauseContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkClauseContext::WatermarkClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::WatermarkClauseContext::WATERMARK()
{
    return getToken(NebulaSQLParser::WATERMARK, 0);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::WatermarkClauseContext::watermarkParameters()
{
    return getRuleContext<NebulaSQLParser::WatermarkParametersContext>(0);
}


size_t NebulaSQLParser::WatermarkClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWatermarkClause;
}

void NebulaSQLParser::WatermarkClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWatermarkClause(this);
}

void NebulaSQLParser::WatermarkClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWatermarkClause(this);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::watermarkClause()
{
    WatermarkClauseContext* _localctx = _tracker.createInstance<WatermarkClauseContext>(_ctx, getState());
    enterRule(_localctx, 76, NebulaSQLParser::RuleWatermarkClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(503);
        match(NebulaSQLParser::WATERMARK);
        setState(504);
        match(NebulaSQLParser::T__2);
        setState(505);
        watermarkParameters();
        setState(506);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WatermarkParametersContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkParametersContext::WatermarkParametersContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::WatermarkParametersContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::WatermarkParametersContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::WatermarkParametersContext::timeUnit()
{
    return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::WatermarkParametersContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWatermarkParameters;
}

void NebulaSQLParser::WatermarkParametersContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWatermarkParameters(this);
}

void NebulaSQLParser::WatermarkParametersContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWatermarkParameters(this);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::watermarkParameters()
{
    WatermarkParametersContext* _localctx = _tracker.createInstance<WatermarkParametersContext>(_ctx, getState());
    enterRule(_localctx, 78, NebulaSQLParser::RuleWatermarkParameters);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(508);
        antlrcpp::downCast<WatermarkParametersContext*>(_localctx)->watermarkIdentifier = identifier();
        setState(509);
        match(NebulaSQLParser::T__1);
        setState(510);
        antlrcpp::downCast<WatermarkParametersContext*>(_localctx)->watermark = match(NebulaSQLParser::INTEGER_VALUE);
        setState(511);
        antlrcpp::downCast<WatermarkParametersContext*>(_localctx)->watermarkTimeUnit = timeUnit();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

NebulaSQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::WindowSpecContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWindowSpec;
}

void NebulaSQLParser::WindowSpecContext::copyFrom(WindowSpecContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TimeBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext* NebulaSQLParser::TimeBasedWindowContext::timeWindow()
{
    return getRuleContext<NebulaSQLParser::TimeWindowContext>(0);
}

NebulaSQLParser::TimeBasedWindowContext::TimeBasedWindowContext(WindowSpecContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TimeBasedWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimeBasedWindow(this);
}
void NebulaSQLParser::TimeBasedWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimeBasedWindow(this);
}
//----------------- CountBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext* NebulaSQLParser::CountBasedWindowContext::countWindow()
{
    return getRuleContext<NebulaSQLParser::CountWindowContext>(0);
}

NebulaSQLParser::CountBasedWindowContext::CountBasedWindowContext(WindowSpecContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::CountBasedWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterCountBasedWindow(this);
}
void NebulaSQLParser::CountBasedWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitCountBasedWindow(this);
}
//----------------- ThresholdBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::ConditionWindowContext* NebulaSQLParser::ThresholdBasedWindowContext::conditionWindow()
{
    return getRuleContext<NebulaSQLParser::ConditionWindowContext>(0);
}

NebulaSQLParser::ThresholdBasedWindowContext::ThresholdBasedWindowContext(WindowSpecContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ThresholdBasedWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterThresholdBasedWindow(this);
}
void NebulaSQLParser::ThresholdBasedWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitThresholdBasedWindow(this);
}
NebulaSQLParser::WindowSpecContext* NebulaSQLParser::windowSpec()
{
    WindowSpecContext* _localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
    enterRule(_localctx, 80, NebulaSQLParser::RuleWindowSpec);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(516);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TimeBasedWindowContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(513);
                timeWindow();
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedWindowContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(514);
                countWindow();
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::ThresholdBasedWindowContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(515);
                conditionWindow();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TimeWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext::TimeWindowContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::TimeWindowContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTimeWindow;
}

void NebulaSQLParser::TimeWindowContext::copyFrom(TimeWindowContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TumblingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TumblingWindowContext::TUMBLING()
{
    return getToken(NebulaSQLParser::TUMBLING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::TumblingWindowContext::sizeParameter()
{
    return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::TumblingWindowContext::timestampParameter()
{
    return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::TumblingWindowContext::TumblingWindowContext(TimeWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TumblingWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTumblingWindow(this);
}
void NebulaSQLParser::TumblingWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTumblingWindow(this);
}
//----------------- SlidingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SlidingWindowContext::SLIDING()
{
    return getToken(NebulaSQLParser::SLIDING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::SlidingWindowContext::sizeParameter()
{
    return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::SlidingWindowContext::advancebyParameter()
{
    return getRuleContext<NebulaSQLParser::AdvancebyParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::SlidingWindowContext::timestampParameter()
{
    return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::SlidingWindowContext::SlidingWindowContext(TimeWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SlidingWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSlidingWindow(this);
}
void NebulaSQLParser::SlidingWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSlidingWindow(this);
}
NebulaSQLParser::TimeWindowContext* NebulaSQLParser::timeWindow()
{
    TimeWindowContext* _localctx = _tracker.createInstance<TimeWindowContext>(_ctx, getState());
    enterRule(_localctx, 82, NebulaSQLParser::RuleTimeWindow);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(540);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::TUMBLING: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TumblingWindowContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(518);
                match(NebulaSQLParser::TUMBLING);
                setState(519);
                match(NebulaSQLParser::T__2);
                setState(523);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::IDENTIFIER)
                {
                    setState(520);
                    timestampParameter();
                    setState(521);
                    match(NebulaSQLParser::T__1);
                }
                setState(525);
                sizeParameter();
                setState(526);
                match(NebulaSQLParser::T__3);
                break;
            }

            case NebulaSQLParser::SLIDING: {
                _localctx = _tracker.createInstance<NebulaSQLParser::SlidingWindowContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(528);
                match(NebulaSQLParser::SLIDING);
                setState(529);
                match(NebulaSQLParser::T__2);
                setState(533);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::IDENTIFIER)
                {
                    setState(530);
                    timestampParameter();
                    setState(531);
                    match(NebulaSQLParser::T__1);
                }
                setState(535);
                sizeParameter();
                setState(536);
                match(NebulaSQLParser::T__1);
                setState(537);
                advancebyParameter();
                setState(538);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- CountWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext::CountWindowContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::CountWindowContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleCountWindow;
}

void NebulaSQLParser::CountWindowContext::copyFrom(CountWindowContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- CountBasedTumblingContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::TUMBLING()
{
    return getToken(NebulaSQLParser::TUMBLING, 0);
}

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::CountBasedTumblingContext::CountBasedTumblingContext(CountWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::CountBasedTumblingContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterCountBasedTumbling(this);
}
void NebulaSQLParser::CountBasedTumblingContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitCountBasedTumbling(this);
}
NebulaSQLParser::CountWindowContext* NebulaSQLParser::countWindow()
{
    CountWindowContext* _localctx = _tracker.createInstance<CountWindowContext>(_ctx, getState());
    enterRule(_localctx, 84, NebulaSQLParser::RuleCountWindow);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedTumblingContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(542);
        match(NebulaSQLParser::TUMBLING);
        setState(543);
        match(NebulaSQLParser::T__2);
        setState(544);
        match(NebulaSQLParser::INTEGER_VALUE);
        setState(545);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConditionWindowContext ------------------------------------------------------------------

NebulaSQLParser::ConditionWindowContext::ConditionWindowContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ConditionWindowContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleConditionWindow;
}

void NebulaSQLParser::ConditionWindowContext::copyFrom(ConditionWindowContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ThresholdWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ThresholdWindowContext::THRESHOLD()
{
    return getToken(NebulaSQLParser::THRESHOLD, 0);
}

NebulaSQLParser::ConditionParameterContext* NebulaSQLParser::ThresholdWindowContext::conditionParameter()
{
    return getRuleContext<NebulaSQLParser::ConditionParameterContext>(0);
}

NebulaSQLParser::ThresholdMinSizeParameterContext* NebulaSQLParser::ThresholdWindowContext::thresholdMinSizeParameter()
{
    return getRuleContext<NebulaSQLParser::ThresholdMinSizeParameterContext>(0);
}

NebulaSQLParser::ThresholdWindowContext::ThresholdWindowContext(ConditionWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ThresholdWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterThresholdWindow(this);
}
void NebulaSQLParser::ThresholdWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitThresholdWindow(this);
}
NebulaSQLParser::ConditionWindowContext* NebulaSQLParser::conditionWindow()
{
    ConditionWindowContext* _localctx = _tracker.createInstance<ConditionWindowContext>(_ctx, getState());
    enterRule(_localctx, 86, NebulaSQLParser::RuleConditionWindow);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        _localctx = _tracker.createInstance<NebulaSQLParser::ThresholdWindowContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(547);
        match(NebulaSQLParser::THRESHOLD);
        setState(548);
        match(NebulaSQLParser::T__2);
        setState(549);
        conditionParameter();
        setState(552);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::T__1)
        {
            setState(550);
            match(NebulaSQLParser::T__1);
            setState(551);
            thresholdMinSizeParameter();
        }
        setState(554);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConditionParameterContext ------------------------------------------------------------------

NebulaSQLParser::ConditionParameterContext::ConditionParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ConditionParameterContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}


size_t NebulaSQLParser::ConditionParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleConditionParameter;
}

void NebulaSQLParser::ConditionParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterConditionParameter(this);
}

void NebulaSQLParser::ConditionParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitConditionParameter(this);
}

NebulaSQLParser::ConditionParameterContext* NebulaSQLParser::conditionParameter()
{
    ConditionParameterContext* _localctx = _tracker.createInstance<ConditionParameterContext>(_ctx, getState());
    enterRule(_localctx, 88, NebulaSQLParser::RuleConditionParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(556);
        expression();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ThresholdMinSizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::ThresholdMinSizeParameterContext::ThresholdMinSizeParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::ThresholdMinSizeParameterContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::ThresholdMinSizeParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleThresholdMinSizeParameter;
}

void NebulaSQLParser::ThresholdMinSizeParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterThresholdMinSizeParameter(this);
}

void NebulaSQLParser::ThresholdMinSizeParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitThresholdMinSizeParameter(this);
}

NebulaSQLParser::ThresholdMinSizeParameterContext* NebulaSQLParser::thresholdMinSizeParameter()
{
    ThresholdMinSizeParameterContext* _localctx = _tracker.createInstance<ThresholdMinSizeParameterContext>(_ctx, getState());
    enterRule(_localctx, 90, NebulaSQLParser::RuleThresholdMinSizeParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(558);
        match(NebulaSQLParser::INTEGER_VALUE);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::SizeParameterContext::SizeParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::SIZE()
{
    return getToken(NebulaSQLParser::SIZE, 0);
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SizeParameterContext::timeUnit()
{
    return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::SizeParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSizeParameter;
}

void NebulaSQLParser::SizeParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSizeParameter(this);
}

void NebulaSQLParser::SizeParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSizeParameter(this);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::sizeParameter()
{
    SizeParameterContext* _localctx = _tracker.createInstance<SizeParameterContext>(_ctx, getState());
    enterRule(_localctx, 92, NebulaSQLParser::RuleSizeParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(560);
        match(NebulaSQLParser::SIZE);
        setState(561);
        match(NebulaSQLParser::INTEGER_VALUE);
        setState(562);
        timeUnit();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AdvancebyParameterContext ------------------------------------------------------------------

NebulaSQLParser::AdvancebyParameterContext::AdvancebyParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::ADVANCE()
{
    return getToken(NebulaSQLParser::ADVANCE, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::AdvancebyParameterContext::timeUnit()
{
    return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::AdvancebyParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleAdvancebyParameter;
}

void NebulaSQLParser::AdvancebyParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAdvancebyParameter(this);
}

void NebulaSQLParser::AdvancebyParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAdvancebyParameter(this);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::advancebyParameter()
{
    AdvancebyParameterContext* _localctx = _tracker.createInstance<AdvancebyParameterContext>(_ctx, getState());
    enterRule(_localctx, 94, NebulaSQLParser::RuleAdvancebyParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(564);
        match(NebulaSQLParser::ADVANCE);
        setState(565);
        match(NebulaSQLParser::BY);
        setState(566);
        match(NebulaSQLParser::INTEGER_VALUE);
        setState(567);
        timeUnit();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TimeUnitContext ------------------------------------------------------------------

NebulaSQLParser::TimeUnitContext::TimeUnitContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MS()
{
    return getToken(NebulaSQLParser::MS, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::SEC()
{
    return getToken(NebulaSQLParser::SEC, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MIN()
{
    return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::HOUR()
{
    return getToken(NebulaSQLParser::HOUR, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::DAY()
{
    return getToken(NebulaSQLParser::DAY, 0);
}


size_t NebulaSQLParser::TimeUnitContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTimeUnit;
}

void NebulaSQLParser::TimeUnitContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimeUnit(this);
}

void NebulaSQLParser::TimeUnitContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimeUnit(this);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::timeUnit()
{
    TimeUnitContext* _localctx = _tracker.createInstance<TimeUnitContext>(_ctx, getState());
    enterRule(_localctx, 96, NebulaSQLParser::RuleTimeUnit);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(569);
        _la = _input->LA(1);
        if (!(((((_la - 84) & ~0x3fULL) == 0) && ((1ULL << (_la - 84)) & 31) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TimestampParameterContext ------------------------------------------------------------------

NebulaSQLParser::TimestampParameterContext::TimestampParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::TimestampParameterContext::IDENTIFIER()
{
    return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::TimestampParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTimestampParameter;
}

void NebulaSQLParser::TimestampParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimestampParameter(this);
}

void NebulaSQLParser::TimestampParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimestampParameter(this);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::timestampParameter()
{
    TimestampParameterContext* _localctx = _tracker.createInstance<TimestampParameterContext>(_ctx, getState());
    enterRule(_localctx, 98, NebulaSQLParser::RuleTimestampParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(571);
        match(NebulaSQLParser::IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::AVG()
{
    return getToken(NebulaSQLParser::AVG, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MAX()
{
    return getToken(NebulaSQLParser::MAX, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MIN()
{
    return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::SUM()
{
    return getToken(NebulaSQLParser::SUM, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::COUNT()
{
    return getToken(NebulaSQLParser::COUNT, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MEDIAN()
{
    return getToken(NebulaSQLParser::MEDIAN, 0);
}


size_t NebulaSQLParser::FunctionNameContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFunctionName;
}

void NebulaSQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunctionName(this);
}

void NebulaSQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunctionName(this);
}

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::functionName()
{
    FunctionNameContext* _localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
    enterRule(_localctx, 100, NebulaSQLParser::RuleFunctionName);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(573);
        _la = _input->LA(1);
        if (!(((((_la - 86) & ~0x3fULL) == 0) && ((1ULL << (_la - 86)) & 249) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SinkClauseContext ------------------------------------------------------------------

NebulaSQLParser::SinkClauseContext::SinkClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::INTO()
{
    return getToken(NebulaSQLParser::INTO, 0);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::SinkClauseContext::sinkType()
{
    return getRuleContext<NebulaSQLParser::SinkTypeContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}


size_t NebulaSQLParser::SinkClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSinkClause;
}

void NebulaSQLParser::SinkClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSinkClause(this);
}

void NebulaSQLParser::SinkClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSinkClause(this);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::sinkClause()
{
    SinkClauseContext* _localctx = _tracker.createInstance<SinkClauseContext>(_ctx, getState());
    enterRule(_localctx, 102, NebulaSQLParser::RuleSinkClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(575);
        match(NebulaSQLParser::INTO);
        setState(576);
        sinkType();
        setState(578);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx))
        {
            case 1: {
                setState(577);
                match(NebulaSQLParser::AS);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SinkTypeContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeContext::SinkTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::SinkTypeContext::sinkTypeFile()
{
    return getRuleContext<NebulaSQLParser::SinkTypeFileContext>(0);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::SinkTypeContext::sinkTypePrint()
{
    return getRuleContext<NebulaSQLParser::SinkTypePrintContext>(0);
}


size_t NebulaSQLParser::SinkTypeContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSinkType;
}

void NebulaSQLParser::SinkTypeContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSinkType(this);
}

void NebulaSQLParser::SinkTypeContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSinkType(this);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::sinkType()
{
    SinkTypeContext* _localctx = _tracker.createInstance<SinkTypeContext>(_ctx, getState());
    enterRule(_localctx, 104, NebulaSQLParser::RuleSinkType);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(582);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::FILE: {
                enterOuterAlt(_localctx, 1);
                setState(580);
                sinkTypeFile();
                break;
            }

            case NebulaSQLParser::PRINT: {
                enterOuterAlt(_localctx, 2);
                setState(581);
                sinkTypePrint();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NullNotnullContext ------------------------------------------------------------------

NebulaSQLParser::NullNotnullContext::NullNotnullContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NULLTOKEN()
{
    return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}


size_t NebulaSQLParser::NullNotnullContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNullNotnull;
}

void NebulaSQLParser::NullNotnullContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNullNotnull(this);
}

void NebulaSQLParser::NullNotnullContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNullNotnull(this);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::nullNotnull()
{
    NullNotnullContext* _localctx = _tracker.createInstance<NullNotnullContext>(_ctx, getState());
    enterRule(_localctx, 106, NebulaSQLParser::RuleNullNotnull);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(585);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::NOT)
        {
            setState(584);
            match(NebulaSQLParser::NOT);
        }
        setState(587);
        match(NebulaSQLParser::NULLTOKEN);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StreamNameContext ------------------------------------------------------------------

NebulaSQLParser::StreamNameContext::StreamNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::StreamNameContext::IDENTIFIER()
{
    return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::StreamNameContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStreamName;
}

void NebulaSQLParser::StreamNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStreamName(this);
}

void NebulaSQLParser::StreamNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStreamName(this);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::streamName()
{
    StreamNameContext* _localctx = _tracker.createInstance<StreamNameContext>(_ctx, getState());
    enterRule(_localctx, 108, NebulaSQLParser::RuleStreamName);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(589);
        match(NebulaSQLParser::IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SinkTypeFileContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeFileContext::SinkTypeFileContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::FILE()
{
    return getToken(NebulaSQLParser::FILE, 0);
}


size_t NebulaSQLParser::SinkTypeFileContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSinkTypeFile;
}

void NebulaSQLParser::SinkTypeFileContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSinkTypeFile(this);
}

void NebulaSQLParser::SinkTypeFileContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSinkTypeFile(this);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::sinkTypeFile()
{
    SinkTypeFileContext* _localctx = _tracker.createInstance<SinkTypeFileContext>(_ctx, getState());
    enterRule(_localctx, 110, NebulaSQLParser::RuleSinkTypeFile);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(591);
        match(NebulaSQLParser::FILE);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SinkTypePrintContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypePrintContext::SinkTypePrintContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SinkTypePrintContext::PRINT()
{
    return getToken(NebulaSQLParser::PRINT, 0);
}


size_t NebulaSQLParser::SinkTypePrintContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSinkTypePrint;
}

void NebulaSQLParser::SinkTypePrintContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSinkTypePrint(this);
}

void NebulaSQLParser::SinkTypePrintContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSinkTypePrint(this);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::sinkTypePrint()
{
    SinkTypePrintContext* _localctx = _tracker.createInstance<SinkTypePrintContext>(_ctx, getState());
    enterRule(_localctx, 112, NebulaSQLParser::RuleSinkTypePrint);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(593);
        match(NebulaSQLParser::PRINT);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FileFormatContext ------------------------------------------------------------------

NebulaSQLParser::FileFormatContext::FileFormatContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::CSV_FORMAT()
{
    return getToken(NebulaSQLParser::CSV_FORMAT, 0);
}


size_t NebulaSQLParser::FileFormatContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFileFormat;
}

void NebulaSQLParser::FileFormatContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFileFormat(this);
}

void NebulaSQLParser::FileFormatContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFileFormat(this);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::fileFormat()
{
    FileFormatContext* _localctx = _tracker.createInstance<FileFormatContext>(_ctx, getState());
    enterRule(_localctx, 114, NebulaSQLParser::RuleFileFormat);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(595);
        match(NebulaSQLParser::CSV_FORMAT);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

NebulaSQLParser::SortItemContext::SortItemContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::SortItemContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::NULLS()
{
    return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::ASC()
{
    return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::DESC()
{
    return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::LAST()
{
    return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::FIRST()
{
    return getToken(NebulaSQLParser::FIRST, 0);
}


size_t NebulaSQLParser::SortItemContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSortItem;
}

void NebulaSQLParser::SortItemContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSortItem(this);
}

void NebulaSQLParser::SortItemContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSortItem(this);
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::sortItem()
{
    SortItemContext* _localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
    enterRule(_localctx, 116, NebulaSQLParser::RuleSortItem);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(597);
        expression();
        setState(599);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::ASC

            || _la == NebulaSQLParser::DESC)
        {
            setState(598);
            antlrcpp::downCast<SortItemContext*>(_localctx)->ordering = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == NebulaSQLParser::ASC

                  || _la == NebulaSQLParser::DESC))
            {
                antlrcpp::downCast<SortItemContext*>(_localctx)->ordering = _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(603);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::NULLS)
        {
            setState(601);
            match(NebulaSQLParser::NULLS);
            setState(602);
            antlrcpp::downCast<SortItemContext*>(_localctx)->nullOrder = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == NebulaSQLParser::FIRST

                  || _la == NebulaSQLParser::LAST))
            {
                antlrcpp::downCast<SortItemContext*>(_localctx)->nullOrder = _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

NebulaSQLParser::PredicateContext::PredicateContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::AND()
{
    return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::BETWEEN()
{
    return getToken(NebulaSQLParser::BETWEEN, 0);
}

std::vector<NebulaSQLParser::ValueExpressionContext*> NebulaSQLParser::PredicateContext::valueExpression()
{
    return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicateContext::valueExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::PredicateContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::PredicateContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IN()
{
    return getToken(NebulaSQLParser::IN, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::PredicateContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::RLIKE()
{
    return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::LIKE()
{
    return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ANY()
{
    return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::SOME()
{
    return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ALL()
{
    return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ESCAPE()
{
    return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::STRING()
{
    return getToken(NebulaSQLParser::STRING, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IS()
{
    return getToken(NebulaSQLParser::IS, 0);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::PredicateContext::nullNotnull()
{
    return getRuleContext<NebulaSQLParser::NullNotnullContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FALSE()
{
    return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::UNKNOWN()
{
    return getToken(NebulaSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FROM()
{
    return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::DISTINCT()
{
    return getToken(NebulaSQLParser::DISTINCT, 0);
}


size_t NebulaSQLParser::PredicateContext::getRuleIndex() const
{
    return NebulaSQLParser::RulePredicate;
}

void NebulaSQLParser::PredicateContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterPredicate(this);
}

void NebulaSQLParser::PredicateContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitPredicate(this);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::predicate()
{
    PredicateContext* _localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
    enterRule(_localctx, 118, NebulaSQLParser::RulePredicate);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(684);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(606);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(605);
                    match(NebulaSQLParser::NOT);
                }
                setState(608);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::BETWEEN);
                setState(609);
                antlrcpp::downCast<PredicateContext*>(_localctx)->lower = valueExpression(0);
                setState(610);
                match(NebulaSQLParser::AND);
                setState(611);
                antlrcpp::downCast<PredicateContext*>(_localctx)->upper = valueExpression(0);
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(614);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(613);
                    match(NebulaSQLParser::NOT);
                }
                setState(616);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::IN);
                setState(617);
                match(NebulaSQLParser::T__2);
                setState(618);
                expression();
                setState(623);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(619);
                    match(NebulaSQLParser::T__1);
                    setState(620);
                    expression();
                    setState(625);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(626);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 3: {
                enterOuterAlt(_localctx, 3);
                setState(629);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(628);
                    match(NebulaSQLParser::NOT);
                }
                setState(631);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::IN);
                setState(632);
                match(NebulaSQLParser::T__2);
                setState(633);
                query();
                setState(634);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 4: {
                enterOuterAlt(_localctx, 4);
                setState(637);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(636);
                    match(NebulaSQLParser::NOT);
                }
                setState(639);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::RLIKE);
                setState(640);
                antlrcpp::downCast<PredicateContext*>(_localctx)->pattern = valueExpression(0);
                break;
            }

            case 5: {
                enterOuterAlt(_localctx, 5);
                setState(642);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(641);
                    match(NebulaSQLParser::NOT);
                }
                setState(644);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::LIKE);
                setState(645);
                antlrcpp::downCast<PredicateContext*>(_localctx)->quantifier = _input->LT(1);
                _la = _input->LA(1);
                if (!(((((_la - 9) & ~0x3fULL) == 0) && ((1ULL << (_la - 9)) & 36028797018963973) != 0)))
                {
                    antlrcpp::downCast<PredicateContext*>(_localctx)->quantifier = _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                setState(659);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx))
                {
                    case 1: {
                        setState(646);
                        match(NebulaSQLParser::T__2);
                        setState(647);
                        match(NebulaSQLParser::T__3);
                        break;
                    }

                    case 2: {
                        setState(648);
                        match(NebulaSQLParser::T__2);
                        setState(649);
                        expression();
                        setState(654);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(650);
                            match(NebulaSQLParser::T__1);
                            setState(651);
                            expression();
                            setState(656);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        setState(657);
                        match(NebulaSQLParser::T__3);
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case 6: {
                enterOuterAlt(_localctx, 6);
                setState(662);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(661);
                    match(NebulaSQLParser::NOT);
                }
                setState(664);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::LIKE);
                setState(665);
                antlrcpp::downCast<PredicateContext*>(_localctx)->pattern = valueExpression(0);
                setState(668);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx))
                {
                    case 1: {
                        setState(666);
                        match(NebulaSQLParser::ESCAPE);
                        setState(667);
                        antlrcpp::downCast<PredicateContext*>(_localctx)->escapeChar = match(NebulaSQLParser::STRING);
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case 7: {
                enterOuterAlt(_localctx, 7);
                setState(670);
                match(NebulaSQLParser::IS);
                setState(671);
                nullNotnull();
                break;
            }

            case 8: {
                enterOuterAlt(_localctx, 8);
                setState(672);
                match(NebulaSQLParser::IS);
                setState(674);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(673);
                    match(NebulaSQLParser::NOT);
                }
                setState(676);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = _input->LT(1);
                _la = _input->LA(1);
                if (!(((((_la - 28) & ~0x3fULL) == 0) && ((1ULL << (_la - 28)) & 9895604649985) != 0)))
                {
                    antlrcpp::downCast<PredicateContext*>(_localctx)->kind = _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                break;
            }

            case 9: {
                enterOuterAlt(_localctx, 9);
                setState(677);
                match(NebulaSQLParser::IS);
                setState(679);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(678);
                    match(NebulaSQLParser::NOT);
                }
                setState(681);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::DISTINCT);
                setState(682);
                match(NebulaSQLParser::FROM);
                setState(683);
                antlrcpp::downCast<PredicateContext*>(_localctx)->right = valueExpression(0);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ValueExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext::ValueExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ValueExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleValueExpression;
}

void NebulaSQLParser::ValueExpressionContext::copyFrom(ValueExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ValueExpressionDefaultContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::ValueExpressionDefaultContext::primaryExpression()
{
    return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::ValueExpressionDefaultContext::ValueExpressionDefaultContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ValueExpressionDefaultContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterValueExpressionDefault(this);
}
void NebulaSQLParser::ValueExpressionDefaultContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitValueExpressionDefault(this);
}
//----------------- ComparisonContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::ComparisonContext::comparisonOperator()
{
    return getRuleContext<NebulaSQLParser::ComparisonOperatorContext>(0);
}

std::vector<NebulaSQLParser::ValueExpressionContext*> NebulaSQLParser::ComparisonContext::valueExpression()
{
    return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ComparisonContext::valueExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

NebulaSQLParser::ComparisonContext::ComparisonContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ComparisonContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterComparison(this);
}
void NebulaSQLParser::ComparisonContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitComparison(this);
}
//----------------- ArithmeticBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::ValueExpressionContext*> NebulaSQLParser::ArithmeticBinaryContext::valueExpression()
{
    return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticBinaryContext::valueExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::ASTERISK()
{
    return getToken(NebulaSQLParser::ASTERISK, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::SLASH()
{
    return getToken(NebulaSQLParser::SLASH, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PERCENT()
{
    return getToken(NebulaSQLParser::PERCENT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::DIV()
{
    return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PLUS()
{
    return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::CONCAT_PIPE()
{
    return getToken(NebulaSQLParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::AMPERSAND()
{
    return getToken(NebulaSQLParser::AMPERSAND, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::HAT()
{
    return getToken(NebulaSQLParser::HAT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PIPE()
{
    return getToken(NebulaSQLParser::PIPE, 0);
}

NebulaSQLParser::ArithmeticBinaryContext::ArithmeticBinaryContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ArithmeticBinaryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterArithmeticBinary(this);
}
void NebulaSQLParser::ArithmeticBinaryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitArithmeticBinary(this);
}
//----------------- ArithmeticUnaryContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticUnaryContext::valueExpression()
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::PLUS()
{
    return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::TILDE()
{
    return getToken(NebulaSQLParser::TILDE, 0);
}

NebulaSQLParser::ArithmeticUnaryContext::ArithmeticUnaryContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ArithmeticUnaryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterArithmeticUnary(this);
}
void NebulaSQLParser::ArithmeticUnaryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitArithmeticUnary(this);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression()
{
    return valueExpression(0);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::ValueExpressionContext* _localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
    NebulaSQLParser::ValueExpressionContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 120;
    enterRecursionRule(_localctx, 120, NebulaSQLParser::RuleValueExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(690);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<ValueExpressionDefaultContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;

                setState(687);
                primaryExpression(0);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<ArithmeticUnaryContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(688);
                antlrcpp::downCast<ArithmeticUnaryContext*>(_localctx)->op = _input->LT(1);
                _la = _input->LA(1);
                if (!(((((_la - 111) & ~0x3fULL) == 0) && ((1ULL << (_la - 111)) & 35) != 0)))
                {
                    antlrcpp::downCast<ArithmeticUnaryContext*>(_localctx)->op = _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                setState(689);
                valueExpression(7);
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(713);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                setState(711);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx))
                {
                    case 1: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(692);

                        if (!(precpred(_ctx, 6)))
                            throw FailedPredicateException(this, "precpred(_ctx, 6)");
                        setState(693);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _input->LT(1);
                        _la = _input->LA(1);
                        if (!(_la == NebulaSQLParser::DIV || ((((_la - 113) & ~0x3fULL) == 0) && ((1ULL << (_la - 113)) & 7) != 0)))
                        {
                            antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _errHandler->recoverInline(this);
                        }
                        else
                        {
                            _errHandler->reportMatch(this);
                            consume();
                        }
                        setState(694);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(7);
                        break;
                    }

                    case 2: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(695);

                        if (!(precpred(_ctx, 5)))
                            throw FailedPredicateException(this, "precpred(_ctx, 5)");
                        setState(696);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _input->LT(1);
                        _la = _input->LA(1);
                        if (!(((((_la - 111) & ~0x3fULL) == 0) && ((1ULL << (_la - 111)) & 259) != 0)))
                        {
                            antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _errHandler->recoverInline(this);
                        }
                        else
                        {
                            _errHandler->reportMatch(this);
                            consume();
                        }
                        setState(697);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(6);
                        break;
                    }

                    case 3: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(698);

                        if (!(precpred(_ctx, 4)))
                            throw FailedPredicateException(this, "precpred(_ctx, 4)");
                        setState(699);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = match(NebulaSQLParser::AMPERSAND);
                        setState(700);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(5);
                        break;
                    }

                    case 4: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(701);

                        if (!(precpred(_ctx, 3)))
                            throw FailedPredicateException(this, "precpred(_ctx, 3)");
                        setState(702);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = match(NebulaSQLParser::HAT);
                        setState(703);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(4);
                        break;
                    }

                    case 5: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(704);

                        if (!(precpred(_ctx, 2)))
                            throw FailedPredicateException(this, "precpred(_ctx, 2)");
                        setState(705);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = match(NebulaSQLParser::PIPE);
                        setState(706);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(3);
                        break;
                    }

                    case 6: {
                        auto newContext = _tracker.createInstance<ComparisonContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(707);

                        if (!(precpred(_ctx, 1)))
                            throw FailedPredicateException(this, "precpred(_ctx, 1)");
                        setState(708);
                        comparisonOperator();
                        setState(709);
                        antlrcpp::downCast<ComparisonContext*>(_localctx)->right = valueExpression(2);
                        break;
                    }

                    default:
                        break;
                }
            }
            setState(715);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::EQ()
{
    return getToken(NebulaSQLParser::EQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQ()
{
    return getToken(NebulaSQLParser::NEQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQJ()
{
    return getToken(NebulaSQLParser::NEQJ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LT()
{
    return getToken(NebulaSQLParser::LT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LTE()
{
    return getToken(NebulaSQLParser::LTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GT()
{
    return getToken(NebulaSQLParser::GT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GTE()
{
    return getToken(NebulaSQLParser::GTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NSEQ()
{
    return getToken(NebulaSQLParser::NSEQ, 0);
}


size_t NebulaSQLParser::ComparisonOperatorContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleComparisonOperator;
}

void NebulaSQLParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterComparisonOperator(this);
}

void NebulaSQLParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitComparisonOperator(this);
}

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::comparisonOperator()
{
    ComparisonOperatorContext* _localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
    enterRule(_localctx, 122, NebulaSQLParser::RuleComparisonOperator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(716);
        _la = _input->LA(1);
        if (!(((((_la - 103) & ~0x3fULL) == 0) && ((1ULL << (_la - 103)) & 255) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- HintContext ------------------------------------------------------------------

NebulaSQLParser::HintContext::HintContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::HintStatementContext*> NebulaSQLParser::HintContext::hintStatement()
{
    return getRuleContexts<NebulaSQLParser::HintStatementContext>();
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::HintContext::hintStatement(size_t i)
{
    return getRuleContext<NebulaSQLParser::HintStatementContext>(i);
}


size_t NebulaSQLParser::HintContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleHint;
}

void NebulaSQLParser::HintContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterHint(this);
}

void NebulaSQLParser::HintContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitHint(this);
}

NebulaSQLParser::HintContext* NebulaSQLParser::hint()
{
    HintContext* _localctx = _tracker.createInstance<HintContext>(_ctx, getState());
    enterRule(_localctx, 124, NebulaSQLParser::RuleHint);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(718);
        match(NebulaSQLParser::T__5);
        setState(719);
        antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext = hintStatement();
        antlrcpp::downCast<HintContext*>(_localctx)->hintStatements.push_back(
            antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext);
        setState(726);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(721);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx))
                {
                    case 1: {
                        setState(720);
                        match(NebulaSQLParser::T__1);
                        break;
                    }

                    default:
                        break;
                }
                setState(723);
                antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext = hintStatement();
                antlrcpp::downCast<HintContext*>(_localctx)->hintStatements.push_back(
                    antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext);
            }
            setState(728);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
        }
        setState(729);
        match(NebulaSQLParser::T__6);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- HintStatementContext ------------------------------------------------------------------

NebulaSQLParser::HintStatementContext::HintStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::HintStatementContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

std::vector<NebulaSQLParser::PrimaryExpressionContext*> NebulaSQLParser::HintStatementContext::primaryExpression()
{
    return getRuleContexts<NebulaSQLParser::PrimaryExpressionContext>();
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::HintStatementContext::primaryExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(i);
}


size_t NebulaSQLParser::HintStatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleHintStatement;
}

void NebulaSQLParser::HintStatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterHintStatement(this);
}

void NebulaSQLParser::HintStatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitHintStatement(this);
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::hintStatement()
{
    HintStatementContext* _localctx = _tracker.createInstance<HintStatementContext>(_ctx, getState());
    enterRule(_localctx, 126, NebulaSQLParser::RuleHintStatement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(744);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(731);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->hintName = identifier();
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(732);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->hintName = identifier();
                setState(733);
                match(NebulaSQLParser::T__2);
                setState(734);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext = primaryExpression(0);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->parameters.push_back(
                    antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext);
                setState(739);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(735);
                    match(NebulaSQLParser::T__1);
                    setState(736);
                    antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext = primaryExpression(0);
                    antlrcpp::downCast<HintStatementContext*>(_localctx)->parameters.push_back(
                        antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext);
                    setState(741);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(742);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::PrimaryExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RulePrimaryExpression;
}

void NebulaSQLParser::PrimaryExpressionContext::copyFrom(PrimaryExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- DereferenceContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::DereferenceContext::primaryExpression()
{
    return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::DereferenceContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::DereferenceContext::DereferenceContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::DereferenceContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterDereference(this);
}
void NebulaSQLParser::DereferenceContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitDereference(this);
}
//----------------- ConstantDefaultContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext* NebulaSQLParser::ConstantDefaultContext::constant()
{
    return getRuleContext<NebulaSQLParser::ConstantContext>(0);
}

NebulaSQLParser::ConstantDefaultContext::ConstantDefaultContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ConstantDefaultContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterConstantDefault(this);
}
void NebulaSQLParser::ConstantDefaultContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitConstantDefault(this);
}
//----------------- ColumnReferenceContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ColumnReferenceContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ColumnReferenceContext::ColumnReferenceContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ColumnReferenceContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterColumnReference(this);
}
void NebulaSQLParser::ColumnReferenceContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitColumnReference(this);
}
//----------------- RowConstructorContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::NamedExpressionContext*> NebulaSQLParser::RowConstructorContext::namedExpression()
{
    return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::RowConstructorContext::namedExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}

NebulaSQLParser::RowConstructorContext::RowConstructorContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::RowConstructorContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterRowConstructor(this);
}
void NebulaSQLParser::RowConstructorContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitRowConstructor(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ParenthesizedExpressionContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterParenthesizedExpression(this);
}
void NebulaSQLParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitParenthesizedExpression(this);
}
//----------------- StarContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::StarContext::ASTERISK()
{
    return getToken(NebulaSQLParser::ASTERISK, 0);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::StarContext::qualifiedName()
{
    return getRuleContext<NebulaSQLParser::QualifiedNameContext>(0);
}

NebulaSQLParser::StarContext::StarContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::StarContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStar(this);
}
void NebulaSQLParser::StarContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStar(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::FunctionCallContext::functionName()
{
    return getRuleContext<NebulaSQLParser::FunctionNameContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::FunctionCallContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionCallContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::FunctionCallContext::FunctionCallContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunctionCall(this);
}
void NebulaSQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunctionCall(this);
}
//----------------- SubqueryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryExpressionContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryExpressionContext::SubqueryExpressionContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SubqueryExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubqueryExpression(this);
}
void NebulaSQLParser::SubqueryExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubqueryExpression(this);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression()
{
    return primaryExpression(0);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::PrimaryExpressionContext* _localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
    NebulaSQLParser::PrimaryExpressionContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 128;
    enterRecursionRule(_localctx, 128, NebulaSQLParser::RulePrimaryExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(786);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<StarContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;

                setState(747);
                match(NebulaSQLParser::ASTERISK);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<StarContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(748);
                qualifiedName();
                setState(749);
                match(NebulaSQLParser::T__4);
                setState(750);
                match(NebulaSQLParser::ASTERISK);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<SubqueryExpressionContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(752);
                match(NebulaSQLParser::T__2);
                setState(753);
                query();
                setState(754);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<RowConstructorContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(756);
                match(NebulaSQLParser::T__2);
                setState(757);
                namedExpression();
                setState(760);
                _errHandler->sync(this);
                _la = _input->LA(1);
                do
                {
                    setState(758);
                    match(NebulaSQLParser::T__1);
                    setState(759);
                    namedExpression();
                    setState(762);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                } while (_la == NebulaSQLParser::T__1);
                setState(764);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(766);
                functionName();
                setState(767);
                match(NebulaSQLParser::T__2);
                setState(776);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx))
                {
                    case 1: {
                        setState(768);
                        antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext = expression();
                        antlrcpp::downCast<FunctionCallContext*>(_localctx)->argument.push_back(
                            antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext);
                        setState(773);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(769);
                            match(NebulaSQLParser::T__1);
                            setState(770);
                            antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext = expression();
                            antlrcpp::downCast<FunctionCallContext*>(_localctx)->argument.push_back(
                                antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext);
                            setState(775);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        break;
                    }

                    default:
                        break;
                }
                setState(778);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 6: {
                _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(780);
                match(NebulaSQLParser::T__2);
                setState(781);
                expression();
                setState(782);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 7: {
                _localctx = _tracker.createInstance<ConstantDefaultContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(784);
                constant();
                break;
            }

            case 8: {
                _localctx = _tracker.createInstance<ColumnReferenceContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(785);
                identifier();
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(793);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                auto newContext = _tracker.createInstance<DereferenceContext>(
                    _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
                _localctx = newContext;
                newContext->base = previousContext;
                pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
                setState(788);

                if (!(precpred(_ctx, 7)))
                    throw FailedPredicateException(this, "precpred(_ctx, 7)");
                setState(789);
                match(NebulaSQLParser::T__4);
                setState(790);
                antlrcpp::downCast<DereferenceContext*>(_localctx)->fieldName = identifier();
            }
            setState(795);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

NebulaSQLParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::IdentifierContext*> NebulaSQLParser::QualifiedNameContext::identifier()
{
    return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::QualifiedNameContext::identifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}


size_t NebulaSQLParser::QualifiedNameContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQualifiedName;
}

void NebulaSQLParser::QualifiedNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQualifiedName(this);
}

void NebulaSQLParser::QualifiedNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQualifiedName(this);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::qualifiedName()
{
    QualifiedNameContext* _localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
    enterRule(_localctx, 130, NebulaSQLParser::RuleQualifiedName);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(796);
        identifier();
        setState(801);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(797);
                match(NebulaSQLParser::T__4);
                setState(798);
                identifier();
            }
            setState(803);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext::NumberContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::NumberContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNumber;
}

void NebulaSQLParser::NumberContext::copyFrom(NumberContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- DecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::DECIMAL_VALUE()
{
    return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DecimalLiteralContext::DecimalLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::DecimalLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterDecimalLiteral(this);
}
void NebulaSQLParser::DecimalLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitDecimalLiteral(this);
}
//----------------- BigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::BIGINT_LITERAL()
{
    return getToken(NebulaSQLParser::BIGINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigIntLiteralContext::BigIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::BigIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBigIntLiteral(this);
}
void NebulaSQLParser::BigIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBigIntLiteral(this);
}
//----------------- TinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::TINYINT_LITERAL()
{
    return getToken(NebulaSQLParser::TINYINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::TinyIntLiteralContext::TinyIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TinyIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTinyIntLiteral(this);
}
void NebulaSQLParser::TinyIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTinyIntLiteral(this);
}
//----------------- LegacyDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::EXPONENT_VALUE()
{
    return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::DECIMAL_VALUE()
{
    return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::LegacyDecimalLiteralContext::LegacyDecimalLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::LegacyDecimalLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterLegacyDecimalLiteral(this);
}
void NebulaSQLParser::LegacyDecimalLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitLegacyDecimalLiteral(this);
}
//----------------- BigDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::BIGDECIMAL_LITERAL()
{
    return getToken(NebulaSQLParser::BIGDECIMAL_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigDecimalLiteralContext::BigDecimalLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::BigDecimalLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBigDecimalLiteral(this);
}
void NebulaSQLParser::BigDecimalLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBigDecimalLiteral(this);
}
//----------------- ExponentLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::EXPONENT_VALUE()
{
    return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::ExponentLiteralContext::ExponentLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ExponentLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterExponentLiteral(this);
}
void NebulaSQLParser::ExponentLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitExponentLiteral(this);
}
//----------------- DoubleLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::DOUBLE_LITERAL()
{
    return getToken(NebulaSQLParser::DOUBLE_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DoubleLiteralContext::DoubleLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::DoubleLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterDoubleLiteral(this);
}
void NebulaSQLParser::DoubleLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitDoubleLiteral(this);
}
//----------------- IntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::IntegerLiteralContext::IntegerLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::IntegerLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIntegerLiteral(this);
}
void NebulaSQLParser::IntegerLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIntegerLiteral(this);
}
//----------------- FloatLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::FLOAT_LITERAL()
{
    return getToken(NebulaSQLParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::FloatLiteralContext::FloatLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::FloatLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFloatLiteral(this);
}
void NebulaSQLParser::FloatLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFloatLiteral(this);
}
//----------------- SmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::SMALLINT_LITERAL()
{
    return getToken(NebulaSQLParser::SMALLINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::SmallIntLiteralContext::SmallIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SmallIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSmallIntLiteral(this);
}
void NebulaSQLParser::SmallIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSmallIntLiteral(this);
}
NebulaSQLParser::NumberContext* NebulaSQLParser::number()
{
    NumberContext* _localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
    enterRule(_localctx, 132, NebulaSQLParser::RuleNumber);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(847);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::ExponentLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(804);

                if (!(!legacy_exponent_literal_as_decimal_enabled))
                    throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
                setState(806);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(805);
                    match(NebulaSQLParser::MINUS);
                }
                setState(808);
                match(NebulaSQLParser::EXPONENT_VALUE);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::DecimalLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(809);

                if (!(!legacy_exponent_literal_as_decimal_enabled))
                    throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
                setState(811);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(810);
                    match(NebulaSQLParser::MINUS);
                }
                setState(813);
                match(NebulaSQLParser::DECIMAL_VALUE);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::LegacyDecimalLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(814);

                if (!(legacy_exponent_literal_as_decimal_enabled))
                    throw FailedPredicateException(this, "legacy_exponent_literal_as_decimal_enabled");
                setState(816);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(815);
                    match(NebulaSQLParser::MINUS);
                }
                setState(818);
                _la = _input->LA(1);
                if (!(_la == NebulaSQLParser::EXPONENT_VALUE

                      || _la == NebulaSQLParser::DECIMAL_VALUE))
                {
                    _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::IntegerLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(820);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(819);
                    match(NebulaSQLParser::MINUS);
                }
                setState(822);
                match(NebulaSQLParser::INTEGER_VALUE);
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<NebulaSQLParser::BigIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(824);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(823);
                    match(NebulaSQLParser::MINUS);
                }
                setState(826);
                match(NebulaSQLParser::BIGINT_LITERAL);
                break;
            }

            case 6: {
                _localctx = _tracker.createInstance<NebulaSQLParser::SmallIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 6);
                setState(828);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(827);
                    match(NebulaSQLParser::MINUS);
                }
                setState(830);
                match(NebulaSQLParser::SMALLINT_LITERAL);
                break;
            }

            case 7: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TinyIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 7);
                setState(832);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(831);
                    match(NebulaSQLParser::MINUS);
                }
                setState(834);
                match(NebulaSQLParser::TINYINT_LITERAL);
                break;
            }

            case 8: {
                _localctx = _tracker.createInstance<NebulaSQLParser::DoubleLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 8);
                setState(836);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(835);
                    match(NebulaSQLParser::MINUS);
                }
                setState(838);
                match(NebulaSQLParser::DOUBLE_LITERAL);
                break;
            }

            case 9: {
                _localctx = _tracker.createInstance<NebulaSQLParser::FloatLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 9);
                setState(840);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(839);
                    match(NebulaSQLParser::MINUS);
                }
                setState(842);
                match(NebulaSQLParser::FLOAT_LITERAL);
                break;
            }

            case 10: {
                _localctx = _tracker.createInstance<NebulaSQLParser::BigDecimalLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 10);
                setState(844);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(843);
                    match(NebulaSQLParser::MINUS);
                }
                setState(846);
                match(NebulaSQLParser::BIGDECIMAL_LITERAL);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext::ConstantContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ConstantContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleConstant;
}

void NebulaSQLParser::ConstantContext::copyFrom(ConstantContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- NullLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::NullLiteralContext::NULLTOKEN()
{
    return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

NebulaSQLParser::NullLiteralContext::NullLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNullLiteral(this);
}
void NebulaSQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNullLiteral(this);
}
//----------------- StringLiteralContext ------------------------------------------------------------------

std::vector<tree::TerminalNode*> NebulaSQLParser::StringLiteralContext::STRING()
{
    return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::StringLiteralContext::STRING(size_t i)
{
    return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::StringLiteralContext::StringLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::StringLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStringLiteral(this);
}
void NebulaSQLParser::StringLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStringLiteral(this);
}
//----------------- TypeConstructorContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::TypeConstructorContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TypeConstructorContext::STRING()
{
    return getToken(NebulaSQLParser::STRING, 0);
}

NebulaSQLParser::TypeConstructorContext::TypeConstructorContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TypeConstructorContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTypeConstructor(this);
}
void NebulaSQLParser::TypeConstructorContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTypeConstructor(this);
}
//----------------- NumericLiteralContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext* NebulaSQLParser::NumericLiteralContext::number()
{
    return getRuleContext<NebulaSQLParser::NumberContext>(0);
}

NebulaSQLParser::NumericLiteralContext::NumericLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::NumericLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNumericLiteral(this);
}
void NebulaSQLParser::NumericLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNumericLiteral(this);
}
//----------------- BooleanLiteralContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::BooleanLiteralContext::booleanValue()
{
    return getRuleContext<NebulaSQLParser::BooleanValueContext>(0);
}

NebulaSQLParser::BooleanLiteralContext::BooleanLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBooleanLiteral(this);
}
void NebulaSQLParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBooleanLiteral(this);
}
NebulaSQLParser::ConstantContext* NebulaSQLParser::constant()
{
    ConstantContext* _localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
    enterRule(_localctx, 134, NebulaSQLParser::RuleConstant);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        setState(860);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::NullLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(849);
                match(NebulaSQLParser::NULLTOKEN);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TypeConstructorContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(850);
                identifier();
                setState(851);
                match(NebulaSQLParser::STRING);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::NumericLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(853);
                number();
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::BooleanLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(854);
                booleanValue();
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<NebulaSQLParser::StringLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(856);
                _errHandler->sync(this);
                alt = 1;
                do
                {
                    switch (alt)
                    {
                        case 1: {
                            setState(855);
                            match(NebulaSQLParser::STRING);
                            break;
                        }

                        default:
                            throw NoViableAltException(this);
                    }
                    setState(858);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
                } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext::BooleanValueContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::FALSE()
{
    return getToken(NebulaSQLParser::FALSE, 0);
}


size_t NebulaSQLParser::BooleanValueContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleBooleanValue;
}

void NebulaSQLParser::BooleanValueContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBooleanValue(this);
}

void NebulaSQLParser::BooleanValueContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBooleanValue(this);
}

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::booleanValue()
{
    BooleanValueContext* _localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
    enterRule(_localctx, 136, NebulaSQLParser::RuleBooleanValue);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(862);
        _la = _input->LA(1);
        if (!(_la == NebulaSQLParser::FALSE

              || _la == NebulaSQLParser::TRUE))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StrictNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::StrictNonReservedContext::StrictNonReservedContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::FULL()
{
    return getToken(NebulaSQLParser::FULL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::INNER()
{
    return getToken(NebulaSQLParser::INNER, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::JOIN()
{
    return getToken(NebulaSQLParser::JOIN, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::LEFT()
{
    return getToken(NebulaSQLParser::LEFT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::NATURAL()
{
    return getToken(NebulaSQLParser::NATURAL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::ON()
{
    return getToken(NebulaSQLParser::ON, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::RIGHT()
{
    return getToken(NebulaSQLParser::RIGHT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::UNION()
{
    return getToken(NebulaSQLParser::UNION, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::USING()
{
    return getToken(NebulaSQLParser::USING, 0);
}


size_t NebulaSQLParser::StrictNonReservedContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStrictNonReserved;
}

void NebulaSQLParser::StrictNonReservedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStrictNonReserved(this);
}

void NebulaSQLParser::StrictNonReservedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStrictNonReserved(this);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::strictNonReserved()
{
    StrictNonReservedContext* _localctx = _tracker.createInstance<StrictNonReservedContext>(_ctx, getState());
    enterRule(_localctx, 138, NebulaSQLParser::RuleStrictNonReserved);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(864);
        _la = _input->LA(1);
        if (!(((((_la - 32) & ~0x3fULL) == 0) && ((1ULL << (_la - 32)) & 2474039710785) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AnsiNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::AnsiNonReservedContext::AnsiNonReservedContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ASC()
{
    return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::AT()
{
    return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BETWEEN()
{
    return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::CUBE()
{
    return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DELETE()
{
    return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DESC()
{
    return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DIV()
{
    return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DROP()
{
    return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::EXISTS()
{
    return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::FIRST()
{
    return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::GROUPING()
{
    return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::INSERT()
{
    return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LAST()
{
    return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIKE()
{
    return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIMIT()
{
    return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::MERGE()
{
    return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::NULLS()
{
    return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::QUERY()
{
    return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::RLIKE()
{
    return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ROLLUP()
{
    return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::SETS()
{
    return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TYPE()
{
    return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::VALUES()
{
    return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::WINDOW()
{
    return getToken(NebulaSQLParser::WINDOW, 0);
}


size_t NebulaSQLParser::AnsiNonReservedContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleAnsiNonReserved;
}

void NebulaSQLParser::AnsiNonReservedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAnsiNonReserved(this);
}

void NebulaSQLParser::AnsiNonReservedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAnsiNonReserved(this);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::ansiNonReserved()
{
    AnsiNonReservedContext* _localctx = _tracker.createInstance<AnsiNonReservedContext>(_ctx, getState());
    enterRule(_localctx, 140, NebulaSQLParser::RuleAnsiNonReserved);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(866);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -5615592343523696640) != 0)
              || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 579) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NonReservedContext ------------------------------------------------------------------

NebulaSQLParser::NonReservedContext::NonReservedContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ASC()
{
    return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AT()
{
    return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BETWEEN()
{
    return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::CUBE()
{
    return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DELETE()
{
    return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DESC()
{
    return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DIV()
{
    return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DROP()
{
    return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::EXISTS()
{
    return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FIRST()
{
    return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUPING()
{
    return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INSERT()
{
    return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LAST()
{
    return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIKE()
{
    return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIMIT()
{
    return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::MERGE()
{
    return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLS()
{
    return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::QUERY()
{
    return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::RLIKE()
{
    return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ROLLUP()
{
    return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SETS()
{
    return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TYPE()
{
    return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::VALUES()
{
    return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WINDOW()
{
    return getToken(NebulaSQLParser::WINDOW, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ALL()
{
    return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AND()
{
    return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ANY()
{
    return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DISTINCT()
{
    return getToken(NebulaSQLParser::DISTINCT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ESCAPE()
{
    return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FALSE()
{
    return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FROM()
{
    return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUP()
{
    return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::HAVING()
{
    return getToken(NebulaSQLParser::HAVING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IN()
{
    return getToken(NebulaSQLParser::IN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INTO()
{
    return getToken(NebulaSQLParser::INTO, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IS()
{
    return getToken(NebulaSQLParser::IS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLTOKEN()
{
    return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::OR()
{
    return getToken(NebulaSQLParser::OR, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ORDER()
{
    return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SELECT()
{
    return getToken(NebulaSQLParser::SELECT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SOME()
{
    return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TABLE()
{
    return getToken(NebulaSQLParser::TABLE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WHERE()
{
    return getToken(NebulaSQLParser::WHERE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WITH()
{
    return getToken(NebulaSQLParser::WITH, 0);
}


size_t NebulaSQLParser::NonReservedContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNonReserved;
}

void NebulaSQLParser::NonReservedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNonReserved(this);
}

void NebulaSQLParser::NonReservedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNonReserved(this);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::nonReserved()
{
    NonReservedContext* _localctx = _tracker.createInstance<NonReservedContext>(_ctx, getState());
    enterRule(_localctx, 142, NebulaSQLParser::RuleNonReserved);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(868);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -892438752910246400) != 0)
              || ((((_la - 64) & ~0x3fULL) == 0) && ((1ULL << (_la - 64)) & 29749) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

bool NebulaSQLParser::sempred(RuleContext* context, size_t ruleIndex, size_t predicateIndex)
{
    switch (ruleIndex)
    {
        case 4:
            return queryTermSempred(antlrcpp::downCast<QueryTermContext*>(context), predicateIndex);
        case 24:
            return identifierSempred(antlrcpp::downCast<IdentifierContext*>(context), predicateIndex);
        case 25:
            return strictIdentifierSempred(antlrcpp::downCast<StrictIdentifierContext*>(context), predicateIndex);
        case 33:
            return booleanExpressionSempred(antlrcpp::downCast<BooleanExpressionContext*>(context), predicateIndex);
        case 60:
            return valueExpressionSempred(antlrcpp::downCast<ValueExpressionContext*>(context), predicateIndex);
        case 64:
            return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext*>(context), predicateIndex);
        case 66:
            return numberSempred(antlrcpp::downCast<NumberContext*>(context), predicateIndex);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::queryTermSempred(QueryTermContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 0:
            return precpred(_ctx, 1);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::identifierSempred(IdentifierContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 1:
            return !SQL_standard_keyword_behavior;

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::strictIdentifierSempred(StrictIdentifierContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 2:
            return SQL_standard_keyword_behavior;
        case 3:
            return !SQL_standard_keyword_behavior;

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::booleanExpressionSempred(BooleanExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 4:
            return precpred(_ctx, 2);
        case 5:
            return precpred(_ctx, 1);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::valueExpressionSempred(ValueExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 6:
            return precpred(_ctx, 6);
        case 7:
            return precpred(_ctx, 5);
        case 8:
            return precpred(_ctx, 4);
        case 9:
            return precpred(_ctx, 3);
        case 10:
            return precpred(_ctx, 2);
        case 11:
            return precpred(_ctx, 1);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::primaryExpressionSempred(PrimaryExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 12:
            return precpred(_ctx, 7);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::numberSempred(NumberContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 13:
            return !legacy_exponent_literal_as_decimal_enabled;
        case 14:
            return !legacy_exponent_literal_as_decimal_enabled;
        case 15:
            return legacy_exponent_literal_as_decimal_enabled;

        default:
            break;
    }
    return true;
}

void NebulaSQLParser::initialize()
{
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    nebulasqlParserInitialize();
#else
    ::antlr4::internal::call_once(nebulasqlParserOnceFlag, nebulasqlParserInitialize);
#endif
}
