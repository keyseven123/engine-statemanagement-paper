
// Generated from nes-nebuli/parser/NebulaSQL.g4 by ANTLR 4.13.2


#include "NebulaSQLListener.h"

#include "NebulaSQLParser.h"


#include <Util/DisableWarningsPragma.hpp>
DISABLE_WARNING_PUSH
DISABLE_WARNING(-Wlogical-op-parentheses)
DISABLE_WARNING(-Wunused-parameter)


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct NebulaSQLParserStaticData final {
  NebulaSQLParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  NebulaSQLParserStaticData(const NebulaSQLParserStaticData&) = delete;
  NebulaSQLParserStaticData(NebulaSQLParserStaticData&&) = delete;
  NebulaSQLParserStaticData& operator=(const NebulaSQLParserStaticData&) = delete;
  NebulaSQLParserStaticData& operator=(NebulaSQLParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag nebulasqlParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<NebulaSQLParserStaticData> nebulasqlParserStaticData = nullptr;

void nebulasqlParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (nebulasqlParserStaticData != nullptr) {
    return;
  }
#else
  assert(nebulasqlParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<NebulaSQLParserStaticData>(
    std::vector<std::string>{
      "singleStatement", "statement", "query", "queryOrganization", "queryTerm", 
      "queryPrimary", "querySpecification", "fromClause", "relation", "joinRelation", 
      "joinType", "joinCriteria", "relationPrimary", "functionTable", "fromStatement", 
      "fromStatementBody", "selectClause", "whereClause", "havingClause", 
      "inlineTable", "tableAlias", "multipartIdentifierList", "multipartIdentifier", 
      "namedExpression", "identifier", "strictIdentifier", "quotedIdentifier", 
      "identifierList", "identifierSeq", "errorCapturingIdentifier", "errorCapturingIdentifierExtra", 
      "namedExpressionSeq", "expression", "booleanExpression", "windowedAggregationClause", 
      "aggregationClause", "groupingSet", "windowClause", "watermarkClause", 
      "watermarkParameters", "windowSpec", "timeWindow", "countWindow", 
      "conditionWindow", "conditionParameter", "thresholdMinSizeParameter", 
      "sizeParameter", "advancebyParameter", "timeUnit", "timestampParameter", 
      "functionName", "sinkClause", "sinkType", "sinkTypeZMQ", "nullNotnull", 
      "zmqKeyword", "streamName", "host", "port", "sinkTypeKafka", "kafkaKeyword", 
      "kafkaBroker", "kafkaTopic", "kafkaProducerTimout", "sinkTypeFile", 
      "fileFormat", "sinkTypeMQTT", "qos", "sinkTypeOPC", "sinkTypePrint", 
      "sortItem", "predicate", "valueExpression", "comparisonOperator", 
      "hint", "hintStatement", "primaryExpression", "qualifiedName", "number", 
      "constant", "booleanValue", "strictNonReserved", "ansiNonReserved", 
      "nonReserved"
    },
    std::vector<std::string>{
      "", "';'", "','", "'('", "')'", "'.'", "'/*+'", "'*/'", "", "", "", 
      "'ANY'", "", "", "'AT'", "", "", "'COMMENT'", "'CUBE'", "'DELETE'", 
      "", "'DISTINCT'", "'DIV'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", 
      "'EXISTS'", "'FALSE'", "'FIRST'", "'FOR'", "", "'FULL'", "", "'GROUPING'", 
      "", "'IF'", "", "", "", "", "", "", "'LAST'", "'LEFT'", "'LIKE'", 
      "", "'LIST'", "", "'NATURAL'", "", "'NULL'", "'NULLS'", "'OF'", "", 
      "", "", "'QUERY'", "'RECOVER'", "'RIGHT'", "", "'ROLLUP'", "", "'SETS'", 
      "'SOME'", "'START'", "'TABLE'", "'TO'", "'TRUE'", "'TYPE'", "", "'UNKNOWN'", 
      "'USE'", "'USING'", "'VALUES'", "'WHEN'", "", "", "'WITH'", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "'FILE'", "'MQTT'", "'OPC'", "", "", "'CSV_FORMAT'", "'NES_FORMAT'", 
      "'TEXT_FORMAT'", "'AT_MOST_ONCE'", "'AT_LEAST_ONCE'", "", "", "'<=>'", 
      "'<>'", "'!='", "'<'", "", "'>'", "", "'+'", "'-'", "'*'", "'/'", 
      "'%'", "'~'", "'&'", "'|'", "'||'", "'^'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "BACKQUOTED_IDENTIFIER", "ALL", "AND", 
      "ANY", "AS", "ASC", "AT", "BETWEEN", "BY", "COMMENT", "CUBE", "DELETE", 
      "DESC", "DISTINCT", "DIV", "DROP", "ELSE", "END", "ESCAPE", "EXISTS", 
      "FALSE", "FIRST", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "HAVING", 
      "IF", "IN", "INNER", "INSERT", "INTO", "IS", "JOIN", "LAST", "LEFT", 
      "LIKE", "LIMIT", "LIST", "MERGE", "NATURAL", "NOT", "NULLTOKEN", "NULLS", 
      "OF", "ON", "OR", "ORDER", "QUERY", "RECOVER", "RIGHT", "RLIKE", "ROLLUP", 
      "SELECT", "SETS", "SOME", "START", "TABLE", "TO", "TRUE", "TYPE", 
      "UNION", "UNKNOWN", "USE", "USING", "VALUES", "WHEN", "WHERE", "WINDOW", 
      "WITH", "TUMBLING", "SLIDING", "THRESHOLD", "SIZE", "ADVANCE", "MS", 
      "SEC", "MIN", "HOUR", "DAY", "MAX", "AVG", "SUM", "COUNT", "MEDIAN", 
      "WATERMARK", "OFFSET", "ZMQ", "KAFKA", "FILE", "MQTT", "OPC", "PRINT", 
      "LOCALHOST", "CSV_FORMAT", "NES_FORMAT", "TEXT_FORMAT", "AT_MOST_ONCE", 
      "AT_LEAST_ONCE", "BOOLEAN_VALUE", "EQ", "NSEQ", "NEQ", "NEQJ", "LT", 
      "LTE", "GT", "GTE", "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", 
      "TILDE", "AMPERSAND", "PIPE", "CONCAT_PIPE", "HAT", "STRING", "BIGINT_LITERAL", 
      "SMALLINT_LITERAL", "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE", 
      "DECIMAL_VALUE", "FLOAT_LITERAL", "DOUBLE_LITERAL", "BIGDECIMAL_LITERAL", 
      "IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT", "WS", "FOUR_OCTETS", 
      "OCTET", "UNRECOGNIZED"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,143,970,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,1,0,1,
  	0,5,0,171,8,0,10,0,12,0,174,9,0,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,3,1,3,1,
  	3,1,3,1,3,5,3,188,8,3,10,3,12,3,191,9,3,3,3,193,8,3,1,3,1,3,1,3,3,3,198,
  	8,3,3,3,200,8,3,1,3,1,3,3,3,204,8,3,1,4,1,4,1,4,1,4,1,4,1,4,5,4,212,8,
  	4,10,4,12,4,215,9,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,226,8,5,1,
  	6,1,6,1,6,3,6,231,8,6,1,6,3,6,234,8,6,1,6,3,6,237,8,6,1,6,3,6,240,8,6,
  	1,7,1,7,1,7,1,7,5,7,246,8,7,10,7,12,7,249,9,7,1,8,1,8,5,8,253,8,8,10,
  	8,12,8,256,9,8,1,9,1,9,1,9,1,9,3,9,262,8,9,1,9,1,9,1,9,1,9,1,9,3,9,269,
  	8,9,1,10,3,10,272,8,10,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,
  	12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,292,8,12,1,13,1,13,1,
  	13,1,13,1,13,5,13,299,8,13,10,13,12,13,302,9,13,3,13,304,8,13,1,13,1,
  	13,1,13,1,14,1,14,4,14,311,8,14,11,14,12,14,312,1,15,1,15,3,15,317,8,
  	15,1,15,3,15,320,8,15,1,16,1,16,5,16,324,8,16,10,16,12,16,327,9,16,1,
  	16,1,16,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,1,19,5,19,341,8,
  	19,10,19,12,19,344,9,19,1,19,1,19,1,20,3,20,349,8,20,1,20,1,20,3,20,353,
  	8,20,3,20,355,8,20,1,21,1,21,1,21,5,21,360,8,21,10,21,12,21,363,9,21,
  	1,22,1,22,1,22,5,22,368,8,22,10,22,12,22,371,9,22,1,23,1,23,3,23,375,
  	8,23,1,23,1,23,3,23,379,8,23,3,23,381,8,23,1,24,1,24,1,24,3,24,386,8,
  	24,1,25,1,25,1,25,1,25,1,25,1,25,3,25,394,8,25,1,26,1,26,1,27,1,27,1,
  	27,1,27,1,28,1,28,1,28,5,28,405,8,28,10,28,12,28,408,9,28,1,29,1,29,1,
  	29,1,30,1,30,4,30,415,8,30,11,30,12,30,416,1,30,3,30,420,8,30,1,31,1,
  	31,1,31,5,31,425,8,31,10,31,12,31,428,9,31,1,32,1,32,1,33,1,33,1,33,1,
  	33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,442,8,33,3,33,444,8,33,1,33,1,33,
  	1,33,1,33,1,33,1,33,5,33,452,8,33,10,33,12,33,455,9,33,1,34,3,34,458,
  	8,34,1,34,1,34,3,34,462,8,34,1,35,1,35,1,35,1,35,1,35,5,35,469,8,35,10,
  	35,12,35,472,9,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,
  	35,484,8,35,10,35,12,35,487,9,35,1,35,1,35,3,35,491,8,35,1,35,1,35,1,
  	35,1,35,1,35,1,35,1,35,1,35,5,35,501,8,35,10,35,12,35,504,9,35,1,35,1,
  	35,3,35,508,8,35,1,36,1,36,1,36,1,36,5,36,514,8,36,10,36,12,36,517,9,
  	36,3,36,519,8,36,1,36,1,36,3,36,523,8,36,1,37,1,37,1,37,1,38,1,38,1,38,
  	1,38,1,38,1,39,1,39,1,39,1,39,1,39,1,40,1,40,1,40,3,40,541,8,40,1,41,
  	1,41,1,41,1,41,1,41,3,41,548,8,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,
  	1,41,3,41,558,8,41,1,41,1,41,1,41,1,41,1,41,3,41,565,8,41,1,42,1,42,1,
  	42,1,42,1,42,1,43,1,43,1,43,1,43,1,43,3,43,577,8,43,1,43,1,43,1,44,1,
  	44,1,45,1,45,1,46,1,46,1,46,1,46,1,47,1,47,1,47,1,47,1,47,1,48,1,48,1,
  	49,1,49,1,50,1,50,1,51,1,51,1,51,3,51,603,8,51,1,52,1,52,1,52,1,52,1,
  	52,1,52,3,52,611,8,52,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,
  	54,3,54,623,8,54,1,54,1,54,1,55,1,55,1,56,1,56,1,57,1,57,1,58,1,58,1,
  	59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,60,1,60,1,61,1,61,1,62,1,
  	62,1,63,1,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,65,1,65,1,
  	66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,
  	66,1,66,1,66,1,66,1,66,1,67,1,67,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,
  	68,1,68,1,68,1,68,1,69,1,69,1,70,1,70,3,70,699,8,70,1,70,1,70,3,70,703,
  	8,70,1,71,3,71,706,8,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,714,8,71,1,
  	71,1,71,1,71,1,71,1,71,5,71,721,8,71,10,71,12,71,724,9,71,1,71,1,71,1,
  	71,3,71,729,8,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,737,8,71,1,71,1,71,
  	1,71,3,71,742,8,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,5,71,752,8,
  	71,10,71,12,71,755,9,71,1,71,1,71,3,71,759,8,71,1,71,3,71,762,8,71,1,
  	71,1,71,1,71,1,71,3,71,768,8,71,1,71,1,71,1,71,1,71,3,71,774,8,71,1,71,
  	1,71,1,71,3,71,779,8,71,1,71,1,71,1,71,3,71,784,8,71,1,72,1,72,1,72,1,
  	72,3,72,790,8,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,
  	72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,811,8,72,10,72,12,72,
  	814,9,72,1,73,1,73,1,74,1,74,1,74,3,74,821,8,74,1,74,5,74,824,8,74,10,
  	74,12,74,827,9,74,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,75,5,75,837,8,
  	75,10,75,12,75,840,9,75,1,75,1,75,3,75,844,8,75,1,76,1,76,1,76,1,76,1,
  	76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,4,76,860,8,76,11,76,12,
  	76,861,1,76,1,76,1,76,1,76,1,76,1,76,1,76,5,76,871,8,76,10,76,12,76,874,
  	9,76,3,76,876,8,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,3,76,886,8,
  	76,1,76,1,76,1,76,5,76,891,8,76,10,76,12,76,894,9,76,1,77,1,77,1,77,5,
  	77,899,8,77,10,77,12,77,902,9,77,1,78,1,78,3,78,906,8,78,1,78,1,78,1,
  	78,3,78,911,8,78,1,78,1,78,1,78,3,78,916,8,78,1,78,1,78,3,78,920,8,78,
  	1,78,1,78,3,78,924,8,78,1,78,1,78,3,78,928,8,78,1,78,1,78,3,78,932,8,
  	78,1,78,1,78,3,78,936,8,78,1,78,1,78,3,78,940,8,78,1,78,1,78,3,78,944,
  	8,78,1,78,3,78,947,8,78,1,79,1,79,1,79,1,79,1,79,1,79,1,79,4,79,956,8,
  	79,11,79,12,79,957,3,79,960,8,79,1,80,1,80,1,81,1,81,1,82,1,82,1,83,1,
  	83,1,83,0,4,8,66,144,152,84,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,
  	32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,
  	78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
  	118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
  	154,156,158,160,162,164,166,0,18,1,0,84,88,2,0,86,86,89,93,2,0,102,102,
  	141,141,1,0,103,105,1,0,106,107,2,0,13,13,20,20,2,0,29,29,43,43,3,0,9,
  	9,11,11,64,64,3,0,28,28,68,68,71,71,2,0,117,118,122,122,2,0,22,22,119,
  	121,2,0,117,118,125,125,1,0,109,116,1,0,132,133,2,0,28,28,68,68,9,0,32,
  	32,38,38,42,42,44,44,49,49,54,54,59,59,70,70,73,73,17,0,13,16,18,20,22,
  	23,27,27,29,29,34,34,39,39,43,43,45,46,48,48,52,52,57,57,60,61,63,63,
  	68,69,74,74,77,77,17,0,9,16,18,23,26,29,31,31,33,35,37,37,39,41,43,43,
  	45,46,48,48,50,52,55,57,60,64,66,66,68,69,74,74,76,78,1031,0,168,1,0,
  	0,0,2,177,1,0,0,0,4,179,1,0,0,0,6,192,1,0,0,0,8,205,1,0,0,0,10,225,1,
  	0,0,0,12,227,1,0,0,0,14,241,1,0,0,0,16,250,1,0,0,0,18,268,1,0,0,0,20,
  	271,1,0,0,0,22,273,1,0,0,0,24,291,1,0,0,0,26,293,1,0,0,0,28,308,1,0,0,
  	0,30,314,1,0,0,0,32,321,1,0,0,0,34,330,1,0,0,0,36,333,1,0,0,0,38,336,
  	1,0,0,0,40,354,1,0,0,0,42,356,1,0,0,0,44,364,1,0,0,0,46,372,1,0,0,0,48,
  	385,1,0,0,0,50,393,1,0,0,0,52,395,1,0,0,0,54,397,1,0,0,0,56,401,1,0,0,
  	0,58,409,1,0,0,0,60,419,1,0,0,0,62,421,1,0,0,0,64,429,1,0,0,0,66,443,
  	1,0,0,0,68,457,1,0,0,0,70,507,1,0,0,0,72,522,1,0,0,0,74,524,1,0,0,0,76,
  	527,1,0,0,0,78,532,1,0,0,0,80,540,1,0,0,0,82,564,1,0,0,0,84,566,1,0,0,
  	0,86,571,1,0,0,0,88,580,1,0,0,0,90,582,1,0,0,0,92,584,1,0,0,0,94,588,
  	1,0,0,0,96,593,1,0,0,0,98,595,1,0,0,0,100,597,1,0,0,0,102,599,1,0,0,0,
  	104,610,1,0,0,0,106,612,1,0,0,0,108,622,1,0,0,0,110,626,1,0,0,0,112,628,
  	1,0,0,0,114,630,1,0,0,0,116,632,1,0,0,0,118,634,1,0,0,0,120,643,1,0,0,
  	0,122,645,1,0,0,0,124,647,1,0,0,0,126,649,1,0,0,0,128,651,1,0,0,0,130,
  	660,1,0,0,0,132,662,1,0,0,0,134,681,1,0,0,0,136,683,1,0,0,0,138,694,1,
  	0,0,0,140,696,1,0,0,0,142,783,1,0,0,0,144,789,1,0,0,0,146,815,1,0,0,0,
  	148,817,1,0,0,0,150,843,1,0,0,0,152,885,1,0,0,0,154,895,1,0,0,0,156,946,
  	1,0,0,0,158,959,1,0,0,0,160,961,1,0,0,0,162,963,1,0,0,0,164,965,1,0,0,
  	0,166,967,1,0,0,0,168,172,3,2,1,0,169,171,5,1,0,0,170,169,1,0,0,0,171,
  	174,1,0,0,0,172,170,1,0,0,0,172,173,1,0,0,0,173,175,1,0,0,0,174,172,1,
  	0,0,0,175,176,5,0,0,1,176,1,1,0,0,0,177,178,3,4,2,0,178,3,1,0,0,0,179,
  	180,3,8,4,0,180,181,3,6,3,0,181,5,1,0,0,0,182,183,5,56,0,0,183,184,5,
  	16,0,0,184,189,3,140,70,0,185,186,5,2,0,0,186,188,3,140,70,0,187,185,
  	1,0,0,0,188,191,1,0,0,0,189,187,1,0,0,0,189,190,1,0,0,0,190,193,1,0,0,
  	0,191,189,1,0,0,0,192,182,1,0,0,0,192,193,1,0,0,0,193,199,1,0,0,0,194,
  	197,5,46,0,0,195,198,5,9,0,0,196,198,5,131,0,0,197,195,1,0,0,0,197,196,
  	1,0,0,0,198,200,1,0,0,0,199,194,1,0,0,0,199,200,1,0,0,0,200,203,1,0,0,
  	0,201,202,5,95,0,0,202,204,5,131,0,0,203,201,1,0,0,0,203,204,1,0,0,0,
  	204,7,1,0,0,0,205,206,6,4,-1,0,206,207,3,10,5,0,207,213,1,0,0,0,208,209,
  	10,1,0,0,209,210,5,70,0,0,210,212,3,8,4,2,211,208,1,0,0,0,212,215,1,0,
  	0,0,213,211,1,0,0,0,213,214,1,0,0,0,214,9,1,0,0,0,215,213,1,0,0,0,216,
  	226,3,12,6,0,217,226,3,28,14,0,218,219,5,66,0,0,219,226,3,44,22,0,220,
  	226,3,38,19,0,221,222,5,3,0,0,222,223,3,4,2,0,223,224,5,4,0,0,224,226,
  	1,0,0,0,225,216,1,0,0,0,225,217,1,0,0,0,225,218,1,0,0,0,225,220,1,0,0,
  	0,225,221,1,0,0,0,226,11,1,0,0,0,227,228,3,32,16,0,228,230,3,14,7,0,229,
  	231,3,34,17,0,230,229,1,0,0,0,230,231,1,0,0,0,231,233,1,0,0,0,232,234,
  	3,68,34,0,233,232,1,0,0,0,233,234,1,0,0,0,234,236,1,0,0,0,235,237,3,36,
  	18,0,236,235,1,0,0,0,236,237,1,0,0,0,237,239,1,0,0,0,238,240,3,102,51,
  	0,239,238,1,0,0,0,239,240,1,0,0,0,240,13,1,0,0,0,241,242,5,31,0,0,242,
  	247,3,16,8,0,243,244,5,2,0,0,244,246,3,16,8,0,245,243,1,0,0,0,246,249,
  	1,0,0,0,247,245,1,0,0,0,247,248,1,0,0,0,248,15,1,0,0,0,249,247,1,0,0,
  	0,250,254,3,24,12,0,251,253,3,18,9,0,252,251,1,0,0,0,253,256,1,0,0,0,
  	254,252,1,0,0,0,254,255,1,0,0,0,255,17,1,0,0,0,256,254,1,0,0,0,257,258,
  	3,20,10,0,258,259,5,42,0,0,259,261,3,24,12,0,260,262,3,22,11,0,261,260,
  	1,0,0,0,261,262,1,0,0,0,262,269,1,0,0,0,263,264,5,49,0,0,264,265,3,20,
  	10,0,265,266,5,42,0,0,266,267,3,24,12,0,267,269,1,0,0,0,268,257,1,0,0,
  	0,268,263,1,0,0,0,269,19,1,0,0,0,270,272,5,38,0,0,271,270,1,0,0,0,271,
  	272,1,0,0,0,272,21,1,0,0,0,273,274,5,54,0,0,274,275,3,66,33,0,275,23,
  	1,0,0,0,276,277,3,44,22,0,277,278,3,40,20,0,278,292,1,0,0,0,279,280,5,
  	3,0,0,280,281,3,4,2,0,281,282,5,4,0,0,282,283,3,40,20,0,283,292,1,0,0,
  	0,284,285,5,3,0,0,285,286,3,16,8,0,286,287,5,4,0,0,287,288,3,40,20,0,
  	288,292,1,0,0,0,289,292,3,38,19,0,290,292,3,26,13,0,291,276,1,0,0,0,291,
  	279,1,0,0,0,291,284,1,0,0,0,291,289,1,0,0,0,291,290,1,0,0,0,292,25,1,
  	0,0,0,293,294,3,58,29,0,294,303,5,3,0,0,295,300,3,64,32,0,296,297,5,2,
  	0,0,297,299,3,64,32,0,298,296,1,0,0,0,299,302,1,0,0,0,300,298,1,0,0,0,
  	300,301,1,0,0,0,301,304,1,0,0,0,302,300,1,0,0,0,303,295,1,0,0,0,303,304,
  	1,0,0,0,304,305,1,0,0,0,305,306,5,4,0,0,306,307,3,40,20,0,307,27,1,0,
  	0,0,308,310,3,14,7,0,309,311,3,30,15,0,310,309,1,0,0,0,311,312,1,0,0,
  	0,312,310,1,0,0,0,312,313,1,0,0,0,313,29,1,0,0,0,314,316,3,32,16,0,315,
  	317,3,34,17,0,316,315,1,0,0,0,316,317,1,0,0,0,317,319,1,0,0,0,318,320,
  	3,70,35,0,319,318,1,0,0,0,319,320,1,0,0,0,320,31,1,0,0,0,321,325,5,62,
  	0,0,322,324,3,148,74,0,323,322,1,0,0,0,324,327,1,0,0,0,325,323,1,0,0,
  	0,325,326,1,0,0,0,326,328,1,0,0,0,327,325,1,0,0,0,328,329,3,62,31,0,329,
  	33,1,0,0,0,330,331,5,76,0,0,331,332,3,66,33,0,332,35,1,0,0,0,333,334,
  	5,35,0,0,334,335,3,66,33,0,335,37,1,0,0,0,336,337,5,74,0,0,337,342,3,
  	64,32,0,338,339,5,2,0,0,339,341,3,64,32,0,340,338,1,0,0,0,341,344,1,0,
  	0,0,342,340,1,0,0,0,342,343,1,0,0,0,343,345,1,0,0,0,344,342,1,0,0,0,345,
  	346,3,40,20,0,346,39,1,0,0,0,347,349,5,12,0,0,348,347,1,0,0,0,348,349,
  	1,0,0,0,349,350,1,0,0,0,350,352,3,50,25,0,351,353,3,54,27,0,352,351,1,
  	0,0,0,352,353,1,0,0,0,353,355,1,0,0,0,354,348,1,0,0,0,354,355,1,0,0,0,
  	355,41,1,0,0,0,356,361,3,44,22,0,357,358,5,2,0,0,358,360,3,44,22,0,359,
  	357,1,0,0,0,360,363,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,362,43,1,
  	0,0,0,363,361,1,0,0,0,364,369,3,58,29,0,365,366,5,5,0,0,366,368,3,58,
  	29,0,367,365,1,0,0,0,368,371,1,0,0,0,369,367,1,0,0,0,369,370,1,0,0,0,
  	370,45,1,0,0,0,371,369,1,0,0,0,372,380,3,64,32,0,373,375,5,12,0,0,374,
  	373,1,0,0,0,374,375,1,0,0,0,375,378,1,0,0,0,376,379,3,58,29,0,377,379,
  	3,54,27,0,378,376,1,0,0,0,378,377,1,0,0,0,379,381,1,0,0,0,380,374,1,0,
  	0,0,380,381,1,0,0,0,381,47,1,0,0,0,382,386,3,50,25,0,383,384,4,24,1,0,
  	384,386,3,162,81,0,385,382,1,0,0,0,385,383,1,0,0,0,386,49,1,0,0,0,387,
  	394,5,137,0,0,388,394,3,52,26,0,389,390,4,25,2,0,390,394,3,164,82,0,391,
  	392,4,25,3,0,392,394,3,166,83,0,393,387,1,0,0,0,393,388,1,0,0,0,393,389,
  	1,0,0,0,393,391,1,0,0,0,394,51,1,0,0,0,395,396,5,8,0,0,396,53,1,0,0,0,
  	397,398,5,3,0,0,398,399,3,56,28,0,399,400,5,4,0,0,400,55,1,0,0,0,401,
  	406,3,58,29,0,402,403,5,2,0,0,403,405,3,58,29,0,404,402,1,0,0,0,405,408,
  	1,0,0,0,406,404,1,0,0,0,406,407,1,0,0,0,407,57,1,0,0,0,408,406,1,0,0,
  	0,409,410,3,48,24,0,410,411,3,60,30,0,411,59,1,0,0,0,412,413,5,118,0,
  	0,413,415,3,48,24,0,414,412,1,0,0,0,415,416,1,0,0,0,416,414,1,0,0,0,416,
  	417,1,0,0,0,417,420,1,0,0,0,418,420,1,0,0,0,419,414,1,0,0,0,419,418,1,
  	0,0,0,420,61,1,0,0,0,421,426,3,46,23,0,422,423,5,2,0,0,423,425,3,46,23,
  	0,424,422,1,0,0,0,425,428,1,0,0,0,426,424,1,0,0,0,426,427,1,0,0,0,427,
  	63,1,0,0,0,428,426,1,0,0,0,429,430,3,66,33,0,430,65,1,0,0,0,431,432,6,
  	33,-1,0,432,433,5,50,0,0,433,444,3,66,33,5,434,435,5,27,0,0,435,436,5,
  	3,0,0,436,437,3,4,2,0,437,438,5,4,0,0,438,444,1,0,0,0,439,441,3,144,72,
  	0,440,442,3,142,71,0,441,440,1,0,0,0,441,442,1,0,0,0,442,444,1,0,0,0,
  	443,431,1,0,0,0,443,434,1,0,0,0,443,439,1,0,0,0,444,453,1,0,0,0,445,446,
  	10,2,0,0,446,447,5,10,0,0,447,452,3,66,33,3,448,449,10,1,0,0,449,450,
  	5,55,0,0,450,452,3,66,33,2,451,445,1,0,0,0,451,448,1,0,0,0,452,455,1,
  	0,0,0,453,451,1,0,0,0,453,454,1,0,0,0,454,67,1,0,0,0,455,453,1,0,0,0,
  	456,458,3,70,35,0,457,456,1,0,0,0,457,458,1,0,0,0,458,459,1,0,0,0,459,
  	461,3,74,37,0,460,462,3,76,38,0,461,460,1,0,0,0,461,462,1,0,0,0,462,69,
  	1,0,0,0,463,464,5,33,0,0,464,465,5,16,0,0,465,470,3,64,32,0,466,467,5,
  	2,0,0,467,469,3,64,32,0,468,466,1,0,0,0,469,472,1,0,0,0,470,468,1,0,0,
  	0,470,471,1,0,0,0,471,490,1,0,0,0,472,470,1,0,0,0,473,474,5,78,0,0,474,
  	491,5,61,0,0,475,476,5,78,0,0,476,491,5,18,0,0,477,478,5,34,0,0,478,479,
  	5,63,0,0,479,480,5,3,0,0,480,485,3,72,36,0,481,482,5,2,0,0,482,484,3,
  	72,36,0,483,481,1,0,0,0,484,487,1,0,0,0,485,483,1,0,0,0,485,486,1,0,0,
  	0,486,488,1,0,0,0,487,485,1,0,0,0,488,489,5,4,0,0,489,491,1,0,0,0,490,
  	473,1,0,0,0,490,475,1,0,0,0,490,477,1,0,0,0,490,491,1,0,0,0,491,508,1,
  	0,0,0,492,493,5,33,0,0,493,494,5,16,0,0,494,495,5,34,0,0,495,496,5,63,
  	0,0,496,497,5,3,0,0,497,502,3,72,36,0,498,499,5,2,0,0,499,501,3,72,36,
  	0,500,498,1,0,0,0,501,504,1,0,0,0,502,500,1,0,0,0,502,503,1,0,0,0,503,
  	505,1,0,0,0,504,502,1,0,0,0,505,506,5,4,0,0,506,508,1,0,0,0,507,463,1,
  	0,0,0,507,492,1,0,0,0,508,71,1,0,0,0,509,518,5,3,0,0,510,515,3,64,32,
  	0,511,512,5,2,0,0,512,514,3,64,32,0,513,511,1,0,0,0,514,517,1,0,0,0,515,
  	513,1,0,0,0,515,516,1,0,0,0,516,519,1,0,0,0,517,515,1,0,0,0,518,510,1,
  	0,0,0,518,519,1,0,0,0,519,520,1,0,0,0,520,523,5,4,0,0,521,523,3,64,32,
  	0,522,509,1,0,0,0,522,521,1,0,0,0,523,73,1,0,0,0,524,525,5,77,0,0,525,
  	526,3,80,40,0,526,75,1,0,0,0,527,528,5,94,0,0,528,529,5,3,0,0,529,530,
  	3,78,39,0,530,531,5,4,0,0,531,77,1,0,0,0,532,533,3,48,24,0,533,534,5,
  	2,0,0,534,535,5,131,0,0,535,536,3,96,48,0,536,79,1,0,0,0,537,541,3,82,
  	41,0,538,541,3,84,42,0,539,541,3,86,43,0,540,537,1,0,0,0,540,538,1,0,
  	0,0,540,539,1,0,0,0,541,81,1,0,0,0,542,543,5,79,0,0,543,547,5,3,0,0,544,
  	545,3,98,49,0,545,546,5,2,0,0,546,548,1,0,0,0,547,544,1,0,0,0,547,548,
  	1,0,0,0,548,549,1,0,0,0,549,550,3,92,46,0,550,551,5,4,0,0,551,565,1,0,
  	0,0,552,553,5,80,0,0,553,557,5,3,0,0,554,555,3,98,49,0,555,556,5,2,0,
  	0,556,558,1,0,0,0,557,554,1,0,0,0,557,558,1,0,0,0,558,559,1,0,0,0,559,
  	560,3,92,46,0,560,561,5,2,0,0,561,562,3,94,47,0,562,563,5,4,0,0,563,565,
  	1,0,0,0,564,542,1,0,0,0,564,552,1,0,0,0,565,83,1,0,0,0,566,567,5,79,0,
  	0,567,568,5,3,0,0,568,569,5,131,0,0,569,570,5,4,0,0,570,85,1,0,0,0,571,
  	572,5,81,0,0,572,573,5,3,0,0,573,576,3,88,44,0,574,575,5,2,0,0,575,577,
  	3,90,45,0,576,574,1,0,0,0,576,577,1,0,0,0,577,578,1,0,0,0,578,579,5,4,
  	0,0,579,87,1,0,0,0,580,581,3,64,32,0,581,89,1,0,0,0,582,583,5,131,0,0,
  	583,91,1,0,0,0,584,585,5,82,0,0,585,586,5,131,0,0,586,587,3,96,48,0,587,
  	93,1,0,0,0,588,589,5,83,0,0,589,590,5,16,0,0,590,591,5,131,0,0,591,592,
  	3,96,48,0,592,95,1,0,0,0,593,594,7,0,0,0,594,97,1,0,0,0,595,596,5,137,
  	0,0,596,99,1,0,0,0,597,598,7,1,0,0,598,101,1,0,0,0,599,600,5,40,0,0,600,
  	602,3,104,52,0,601,603,5,12,0,0,602,601,1,0,0,0,602,603,1,0,0,0,603,103,
  	1,0,0,0,604,611,3,106,53,0,605,611,3,118,59,0,606,611,3,128,64,0,607,
  	611,3,132,66,0,608,611,3,136,68,0,609,611,3,138,69,0,610,604,1,0,0,0,
  	610,605,1,0,0,0,610,606,1,0,0,0,610,607,1,0,0,0,610,608,1,0,0,0,610,609,
  	1,0,0,0,611,105,1,0,0,0,612,613,3,110,55,0,613,614,5,3,0,0,614,615,3,
  	112,56,0,615,616,5,2,0,0,616,617,3,114,57,0,617,618,5,2,0,0,618,619,3,
  	116,58,0,619,620,5,4,0,0,620,107,1,0,0,0,621,623,5,50,0,0,622,621,1,0,
  	0,0,622,623,1,0,0,0,623,624,1,0,0,0,624,625,5,51,0,0,625,109,1,0,0,0,
  	626,627,5,96,0,0,627,111,1,0,0,0,628,629,5,137,0,0,629,113,1,0,0,0,630,
  	631,7,2,0,0,631,115,1,0,0,0,632,633,5,131,0,0,633,117,1,0,0,0,634,635,
  	3,120,60,0,635,636,5,3,0,0,636,637,3,122,61,0,637,638,5,2,0,0,638,639,
  	3,124,62,0,639,640,5,2,0,0,640,641,3,126,63,0,641,642,5,4,0,0,642,119,
  	1,0,0,0,643,644,5,97,0,0,644,121,1,0,0,0,645,646,5,137,0,0,646,123,1,
  	0,0,0,647,648,5,137,0,0,648,125,1,0,0,0,649,650,5,131,0,0,650,127,1,0,
  	0,0,651,652,5,98,0,0,652,653,5,3,0,0,653,654,5,127,0,0,654,655,5,2,0,
  	0,655,656,3,130,65,0,656,657,5,2,0,0,657,658,5,127,0,0,658,659,5,4,0,
  	0,659,129,1,0,0,0,660,661,7,3,0,0,661,131,1,0,0,0,662,663,5,99,0,0,663,
  	664,5,3,0,0,664,665,5,127,0,0,665,666,5,2,0,0,666,667,5,127,0,0,667,668,
  	5,2,0,0,668,669,5,127,0,0,669,670,5,2,0,0,670,671,5,131,0,0,671,672,5,
  	2,0,0,672,673,3,96,48,0,673,674,5,2,0,0,674,675,5,131,0,0,675,676,5,2,
  	0,0,676,677,3,134,67,0,677,678,5,2,0,0,678,679,5,108,0,0,679,680,5,4,
  	0,0,680,133,1,0,0,0,681,682,7,4,0,0,682,135,1,0,0,0,683,684,5,100,0,0,
  	684,685,5,3,0,0,685,686,5,127,0,0,686,687,5,2,0,0,687,688,5,127,0,0,688,
  	689,5,2,0,0,689,690,5,127,0,0,690,691,5,2,0,0,691,692,5,127,0,0,692,693,
  	5,4,0,0,693,137,1,0,0,0,694,695,5,101,0,0,695,139,1,0,0,0,696,698,3,64,
  	32,0,697,699,7,5,0,0,698,697,1,0,0,0,698,699,1,0,0,0,699,702,1,0,0,0,
  	700,701,5,52,0,0,701,703,7,6,0,0,702,700,1,0,0,0,702,703,1,0,0,0,703,
  	141,1,0,0,0,704,706,5,50,0,0,705,704,1,0,0,0,705,706,1,0,0,0,706,707,
  	1,0,0,0,707,708,5,15,0,0,708,709,3,144,72,0,709,710,5,10,0,0,710,711,
  	3,144,72,0,711,784,1,0,0,0,712,714,5,50,0,0,713,712,1,0,0,0,713,714,1,
  	0,0,0,714,715,1,0,0,0,715,716,5,37,0,0,716,717,5,3,0,0,717,722,3,64,32,
  	0,718,719,5,2,0,0,719,721,3,64,32,0,720,718,1,0,0,0,721,724,1,0,0,0,722,
  	720,1,0,0,0,722,723,1,0,0,0,723,725,1,0,0,0,724,722,1,0,0,0,725,726,5,
  	4,0,0,726,784,1,0,0,0,727,729,5,50,0,0,728,727,1,0,0,0,728,729,1,0,0,
  	0,729,730,1,0,0,0,730,731,5,37,0,0,731,732,5,3,0,0,732,733,3,4,2,0,733,
  	734,5,4,0,0,734,784,1,0,0,0,735,737,5,50,0,0,736,735,1,0,0,0,736,737,
  	1,0,0,0,737,738,1,0,0,0,738,739,5,60,0,0,739,784,3,144,72,0,740,742,5,
  	50,0,0,741,740,1,0,0,0,741,742,1,0,0,0,742,743,1,0,0,0,743,744,5,45,0,
  	0,744,758,7,7,0,0,745,746,5,3,0,0,746,759,5,4,0,0,747,748,5,3,0,0,748,
  	753,3,64,32,0,749,750,5,2,0,0,750,752,3,64,32,0,751,749,1,0,0,0,752,755,
  	1,0,0,0,753,751,1,0,0,0,753,754,1,0,0,0,754,756,1,0,0,0,755,753,1,0,0,
  	0,756,757,5,4,0,0,757,759,1,0,0,0,758,745,1,0,0,0,758,747,1,0,0,0,759,
  	784,1,0,0,0,760,762,5,50,0,0,761,760,1,0,0,0,761,762,1,0,0,0,762,763,
  	1,0,0,0,763,764,5,45,0,0,764,767,3,144,72,0,765,766,5,26,0,0,766,768,
  	5,127,0,0,767,765,1,0,0,0,767,768,1,0,0,0,768,784,1,0,0,0,769,770,5,41,
  	0,0,770,784,3,108,54,0,771,773,5,41,0,0,772,774,5,50,0,0,773,772,1,0,
  	0,0,773,774,1,0,0,0,774,775,1,0,0,0,775,784,7,8,0,0,776,778,5,41,0,0,
  	777,779,5,50,0,0,778,777,1,0,0,0,778,779,1,0,0,0,779,780,1,0,0,0,780,
  	781,5,21,0,0,781,782,5,31,0,0,782,784,3,144,72,0,783,705,1,0,0,0,783,
  	713,1,0,0,0,783,728,1,0,0,0,783,736,1,0,0,0,783,741,1,0,0,0,783,761,1,
  	0,0,0,783,769,1,0,0,0,783,771,1,0,0,0,783,776,1,0,0,0,784,143,1,0,0,0,
  	785,786,6,72,-1,0,786,790,3,152,76,0,787,788,7,9,0,0,788,790,3,144,72,
  	7,789,785,1,0,0,0,789,787,1,0,0,0,790,812,1,0,0,0,791,792,10,6,0,0,792,
  	793,7,10,0,0,793,811,3,144,72,7,794,795,10,5,0,0,795,796,7,11,0,0,796,
  	811,3,144,72,6,797,798,10,4,0,0,798,799,5,123,0,0,799,811,3,144,72,5,
  	800,801,10,3,0,0,801,802,5,126,0,0,802,811,3,144,72,4,803,804,10,2,0,
  	0,804,805,5,124,0,0,805,811,3,144,72,3,806,807,10,1,0,0,807,808,3,146,
  	73,0,808,809,3,144,72,2,809,811,1,0,0,0,810,791,1,0,0,0,810,794,1,0,0,
  	0,810,797,1,0,0,0,810,800,1,0,0,0,810,803,1,0,0,0,810,806,1,0,0,0,811,
  	814,1,0,0,0,812,810,1,0,0,0,812,813,1,0,0,0,813,145,1,0,0,0,814,812,1,
  	0,0,0,815,816,7,12,0,0,816,147,1,0,0,0,817,818,5,6,0,0,818,825,3,150,
  	75,0,819,821,5,2,0,0,820,819,1,0,0,0,820,821,1,0,0,0,821,822,1,0,0,0,
  	822,824,3,150,75,0,823,820,1,0,0,0,824,827,1,0,0,0,825,823,1,0,0,0,825,
  	826,1,0,0,0,826,828,1,0,0,0,827,825,1,0,0,0,828,829,5,7,0,0,829,149,1,
  	0,0,0,830,844,3,48,24,0,831,832,3,48,24,0,832,833,5,3,0,0,833,838,3,152,
  	76,0,834,835,5,2,0,0,835,837,3,152,76,0,836,834,1,0,0,0,837,840,1,0,0,
  	0,838,836,1,0,0,0,838,839,1,0,0,0,839,841,1,0,0,0,840,838,1,0,0,0,841,
  	842,5,4,0,0,842,844,1,0,0,0,843,830,1,0,0,0,843,831,1,0,0,0,844,151,1,
  	0,0,0,845,846,6,76,-1,0,846,886,5,119,0,0,847,848,3,154,77,0,848,849,
  	5,5,0,0,849,850,5,119,0,0,850,886,1,0,0,0,851,852,5,3,0,0,852,853,3,4,
  	2,0,853,854,5,4,0,0,854,886,1,0,0,0,855,856,5,3,0,0,856,859,3,46,23,0,
  	857,858,5,2,0,0,858,860,3,46,23,0,859,857,1,0,0,0,860,861,1,0,0,0,861,
  	859,1,0,0,0,861,862,1,0,0,0,862,863,1,0,0,0,863,864,5,4,0,0,864,886,1,
  	0,0,0,865,866,3,100,50,0,866,875,5,3,0,0,867,872,3,64,32,0,868,869,5,
  	2,0,0,869,871,3,64,32,0,870,868,1,0,0,0,871,874,1,0,0,0,872,870,1,0,0,
  	0,872,873,1,0,0,0,873,876,1,0,0,0,874,872,1,0,0,0,875,867,1,0,0,0,875,
  	876,1,0,0,0,876,877,1,0,0,0,877,878,5,4,0,0,878,886,1,0,0,0,879,880,5,
  	3,0,0,880,881,3,64,32,0,881,882,5,4,0,0,882,886,1,0,0,0,883,886,3,158,
  	79,0,884,886,3,48,24,0,885,845,1,0,0,0,885,847,1,0,0,0,885,851,1,0,0,
  	0,885,855,1,0,0,0,885,865,1,0,0,0,885,879,1,0,0,0,885,883,1,0,0,0,885,
  	884,1,0,0,0,886,892,1,0,0,0,887,888,10,7,0,0,888,889,5,5,0,0,889,891,
  	3,48,24,0,890,887,1,0,0,0,891,894,1,0,0,0,892,890,1,0,0,0,892,893,1,0,
  	0,0,893,153,1,0,0,0,894,892,1,0,0,0,895,900,3,48,24,0,896,897,5,5,0,0,
  	897,899,3,48,24,0,898,896,1,0,0,0,899,902,1,0,0,0,900,898,1,0,0,0,900,
  	901,1,0,0,0,901,155,1,0,0,0,902,900,1,0,0,0,903,905,4,78,13,0,904,906,
  	5,118,0,0,905,904,1,0,0,0,905,906,1,0,0,0,906,907,1,0,0,0,907,947,5,132,
  	0,0,908,910,4,78,14,0,909,911,5,118,0,0,910,909,1,0,0,0,910,911,1,0,0,
  	0,911,912,1,0,0,0,912,947,5,133,0,0,913,915,4,78,15,0,914,916,5,118,0,
  	0,915,914,1,0,0,0,915,916,1,0,0,0,916,917,1,0,0,0,917,947,7,13,0,0,918,
  	920,5,118,0,0,919,918,1,0,0,0,919,920,1,0,0,0,920,921,1,0,0,0,921,947,
  	5,131,0,0,922,924,5,118,0,0,923,922,1,0,0,0,923,924,1,0,0,0,924,925,1,
  	0,0,0,925,947,5,128,0,0,926,928,5,118,0,0,927,926,1,0,0,0,927,928,1,0,
  	0,0,928,929,1,0,0,0,929,947,5,129,0,0,930,932,5,118,0,0,931,930,1,0,0,
  	0,931,932,1,0,0,0,932,933,1,0,0,0,933,947,5,130,0,0,934,936,5,118,0,0,
  	935,934,1,0,0,0,935,936,1,0,0,0,936,937,1,0,0,0,937,947,5,135,0,0,938,
  	940,5,118,0,0,939,938,1,0,0,0,939,940,1,0,0,0,940,941,1,0,0,0,941,947,
  	5,134,0,0,942,944,5,118,0,0,943,942,1,0,0,0,943,944,1,0,0,0,944,945,1,
  	0,0,0,945,947,5,136,0,0,946,903,1,0,0,0,946,908,1,0,0,0,946,913,1,0,0,
  	0,946,919,1,0,0,0,946,923,1,0,0,0,946,927,1,0,0,0,946,931,1,0,0,0,946,
  	935,1,0,0,0,946,939,1,0,0,0,946,943,1,0,0,0,947,157,1,0,0,0,948,960,5,
  	51,0,0,949,950,3,48,24,0,950,951,5,127,0,0,951,960,1,0,0,0,952,960,3,
  	156,78,0,953,960,3,160,80,0,954,956,5,127,0,0,955,954,1,0,0,0,956,957,
  	1,0,0,0,957,955,1,0,0,0,957,958,1,0,0,0,958,960,1,0,0,0,959,948,1,0,0,
  	0,959,949,1,0,0,0,959,952,1,0,0,0,959,953,1,0,0,0,959,955,1,0,0,0,960,
  	159,1,0,0,0,961,962,7,14,0,0,962,161,1,0,0,0,963,964,7,15,0,0,964,163,
  	1,0,0,0,965,966,7,16,0,0,966,165,1,0,0,0,967,968,7,17,0,0,968,167,1,0,
  	0,0,102,172,189,192,197,199,203,213,225,230,233,236,239,247,254,261,268,
  	271,291,300,303,312,316,319,325,342,348,352,354,361,369,374,378,380,385,
  	393,406,416,419,426,441,443,451,453,457,461,470,485,490,502,507,515,518,
  	522,540,547,557,564,576,602,610,622,698,702,705,713,722,728,736,741,753,
  	758,761,767,773,778,783,789,810,812,820,825,838,843,861,872,875,885,892,
  	900,905,910,915,919,923,927,931,935,939,943,946,957,959
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  nebulasqlParserStaticData = std::move(staticData);
}

}

NebulaSQLParser::NebulaSQLParser(TokenStream *input) : NebulaSQLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

NebulaSQLParser::NebulaSQLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  NebulaSQLParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *nebulasqlParserStaticData->atn, nebulasqlParserStaticData->decisionToDFA, nebulasqlParserStaticData->sharedContextCache, options);
}

NebulaSQLParser::~NebulaSQLParser() {
  delete _interpreter;
}

const atn::ATN& NebulaSQLParser::getATN() const {
  return *nebulasqlParserStaticData->atn;
}

std::string NebulaSQLParser::getGrammarFileName() const {
  return "NebulaSQL.g4";
}

const std::vector<std::string>& NebulaSQLParser::getRuleNames() const {
  return nebulasqlParserStaticData->ruleNames;
}

const dfa::Vocabulary& NebulaSQLParser::getVocabulary() const {
  return nebulasqlParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NebulaSQLParser::getSerializedATN() const {
  return nebulasqlParserStaticData->serializedATN;
}


//----------------- SingleStatementContext ------------------------------------------------------------------

NebulaSQLParser::SingleStatementContext::SingleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StatementContext* NebulaSQLParser::SingleStatementContext::statement() {
  return getRuleContext<NebulaSQLParser::StatementContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SingleStatementContext::EOF() {
  return getToken(NebulaSQLParser::EOF, 0);
}


size_t NebulaSQLParser::SingleStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSingleStatement;
}

void NebulaSQLParser::SingleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleStatement(this);
}

void NebulaSQLParser::SingleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleStatement(this);
}

NebulaSQLParser::SingleStatementContext* NebulaSQLParser::singleStatement() {
  SingleStatementContext *_localctx = _tracker.createInstance<SingleStatementContext>(_ctx, getState());
  enterRule(_localctx, 0, NebulaSQLParser::RuleSingleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(168);
    statement();
    setState(172);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__0) {
      setState(169);
      match(NebulaSQLParser::T__0);
      setState(174);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(175);
    match(NebulaSQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NebulaSQLParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::QueryContext* NebulaSQLParser::StatementContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}


size_t NebulaSQLParser::StatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStatement;
}

void NebulaSQLParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void NebulaSQLParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

NebulaSQLParser::StatementContext* NebulaSQLParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 2, NebulaSQLParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(177);
    query();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::QueryContext::queryTerm() {
  return getRuleContext<NebulaSQLParser::QueryTermContext>(0);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::QueryContext::queryOrganization() {
  return getRuleContext<NebulaSQLParser::QueryOrganizationContext>(0);
}


size_t NebulaSQLParser::QueryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuery;
}

void NebulaSQLParser::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void NebulaSQLParser::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 4, NebulaSQLParser::RuleQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(179);
    queryTerm(0);
    setState(180);
    queryOrganization();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryOrganizationContext ------------------------------------------------------------------

NebulaSQLParser::QueryOrganizationContext::QueryOrganizationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ORDER() {
  return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::OFFSET() {
  return getToken(NebulaSQLParser::OFFSET, 0);
}

std::vector<NebulaSQLParser::SortItemContext *> NebulaSQLParser::QueryOrganizationContext::sortItem() {
  return getRuleContexts<NebulaSQLParser::SortItemContext>();
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::QueryOrganizationContext::sortItem(size_t i) {
  return getRuleContext<NebulaSQLParser::SortItemContext>(i);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE() {
  return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE(size_t i) {
  return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}


size_t NebulaSQLParser::QueryOrganizationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryOrganization;
}

void NebulaSQLParser::QueryOrganizationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryOrganization(this);
}

void NebulaSQLParser::QueryOrganizationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryOrganization(this);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::queryOrganization() {
  QueryOrganizationContext *_localctx = _tracker.createInstance<QueryOrganizationContext>(_ctx, getState());
  enterRule(_localctx, 6, NebulaSQLParser::RuleQueryOrganization);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(192);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::ORDER) {
      setState(182);
      match(NebulaSQLParser::ORDER);
      setState(183);
      match(NebulaSQLParser::BY);
      setState(184);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
      setState(189);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(185);
        match(NebulaSQLParser::T__1);
        setState(186);
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext = sortItem();
        antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->order.push_back(antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->sortItemContext);
        setState(191);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(199);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::LIMIT) {
      setState(194);
      match(NebulaSQLParser::LIMIT);
      setState(197);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NebulaSQLParser::ALL: {
          setState(195);
          match(NebulaSQLParser::ALL);
          break;
        }

        case NebulaSQLParser::INTEGER_VALUE: {
          setState(196);
          antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->limit = match(NebulaSQLParser::INTEGER_VALUE);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
    setState(203);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::OFFSET) {
      setState(201);
      match(NebulaSQLParser::OFFSET);
      setState(202);
      antlrcpp::downCast<QueryOrganizationContext *>(_localctx)->offset = match(NebulaSQLParser::INTEGER_VALUE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryTermContext ------------------------------------------------------------------

NebulaSQLParser::QueryTermContext::QueryTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::QueryTermContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryTerm;
}

void NebulaSQLParser::QueryTermContext::copyFrom(QueryTermContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::PrimaryQueryContext::queryPrimary() {
  return getRuleContext<NebulaSQLParser::QueryPrimaryContext>(0);
}

NebulaSQLParser::PrimaryQueryContext::PrimaryQueryContext(QueryTermContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::PrimaryQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryQuery(this);
}
void NebulaSQLParser::PrimaryQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryQuery(this);
}
//----------------- SetOperationContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::QueryTermContext *> NebulaSQLParser::SetOperationContext::queryTerm() {
  return getRuleContexts<NebulaSQLParser::QueryTermContext>();
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::SetOperationContext::queryTerm(size_t i) {
  return getRuleContext<NebulaSQLParser::QueryTermContext>(i);
}

tree::TerminalNode* NebulaSQLParser::SetOperationContext::UNION() {
  return getToken(NebulaSQLParser::UNION, 0);
}

NebulaSQLParser::SetOperationContext::SetOperationContext(QueryTermContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SetOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetOperation(this);
}
void NebulaSQLParser::SetOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetOperation(this);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm() {
   return queryTerm(0);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::QueryTermContext *_localctx = _tracker.createInstance<QueryTermContext>(_ctx, parentState);
  NebulaSQLParser::QueryTermContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 8;
  enterRecursionRule(_localctx, 8, NebulaSQLParser::RuleQueryTerm, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryQueryContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(206);
    queryPrimary();
    _ctx->stop = _input->LT(-1);
    setState(213);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<SetOperationContext>(_tracker.createInstance<QueryTermContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->left = previousContext;
        pushNewRecursionContext(newContext, startState, RuleQueryTerm);
        setState(208);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(209);
        antlrcpp::downCast<SetOperationContext *>(_localctx)->setoperator = match(NebulaSQLParser::UNION);
        setState(210);
        antlrcpp::downCast<SetOperationContext *>(_localctx)->right = queryTerm(2); 
      }
      setState(215);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::QueryPrimaryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQueryPrimary;
}

void NebulaSQLParser::QueryPrimaryContext::copyFrom(QueryPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryContext::SubqueryContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}
void NebulaSQLParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}
//----------------- QueryPrimaryDefaultContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::QueryPrimaryDefaultContext::querySpecification() {
  return getRuleContext<NebulaSQLParser::QuerySpecificationContext>(0);
}

NebulaSQLParser::QueryPrimaryDefaultContext::QueryPrimaryDefaultContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::QueryPrimaryDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimaryDefault(this);
}
void NebulaSQLParser::QueryPrimaryDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimaryDefault(this);
}
//----------------- InlineTableDefault1Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault1Context::inlineTable() {
  return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault1Context::InlineTableDefault1Context(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::InlineTableDefault1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTableDefault1(this);
}
void NebulaSQLParser::InlineTableDefault1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTableDefault1(this);
}
//----------------- FromStmtContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext* NebulaSQLParser::FromStmtContext::fromStatement() {
  return getRuleContext<NebulaSQLParser::FromStatementContext>(0);
}

NebulaSQLParser::FromStmtContext::FromStmtContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FromStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStmt(this);
}
void NebulaSQLParser::FromStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStmt(this);
}
//----------------- TableContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TableContext::TABLE() {
  return getToken(NebulaSQLParser::TABLE, 0);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableContext::multipartIdentifier() {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableContext::TableContext(QueryPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable(this);
}
void NebulaSQLParser::TableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable(this);
}
NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::queryPrimary() {
  QueryPrimaryContext *_localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 10, NebulaSQLParser::RuleQueryPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(225);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::SELECT: {
        _localctx = _tracker.createInstance<NebulaSQLParser::QueryPrimaryDefaultContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(216);
        querySpecification();
        break;
      }

      case NebulaSQLParser::FROM: {
        _localctx = _tracker.createInstance<NebulaSQLParser::FromStmtContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(217);
        fromStatement();
        break;
      }

      case NebulaSQLParser::TABLE: {
        _localctx = _tracker.createInstance<NebulaSQLParser::TableContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(218);
        match(NebulaSQLParser::TABLE);
        setState(219);
        multipartIdentifier();
        break;
      }

      case NebulaSQLParser::VALUES: {
        _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault1Context>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(220);
        inlineTable();
        break;
      }

      case NebulaSQLParser::T__2: {
        _localctx = _tracker.createInstance<NebulaSQLParser::SubqueryContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(221);
        match(NebulaSQLParser::T__2);
        setState(222);
        query();
        setState(223);
        match(NebulaSQLParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::QuerySpecificationContext::selectClause() {
  return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::QuerySpecificationContext::windowedAggregationClause() {
  return getRuleContext<NebulaSQLParser::WindowedAggregationClauseContext>(0);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<NebulaSQLParser::HavingClauseContext>(0);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::QuerySpecificationContext::sinkClause() {
  return getRuleContext<NebulaSQLParser::SinkClauseContext>(0);
}


size_t NebulaSQLParser::QuerySpecificationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuerySpecification;
}

void NebulaSQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void NebulaSQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 12, NebulaSQLParser::RuleQuerySpecification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(227);
    selectClause();
    setState(228);
    fromClause();
    setState(230);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      setState(229);
      whereClause();
      break;
    }

    default:
      break;
    }
    setState(233);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(232);
      windowedAggregationClause();
      break;
    }

    default:
      break;
    }
    setState(236);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      setState(235);
      havingClause();
      break;
    }

    default:
      break;
    }
    setState(239);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(238);
      sinkClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

NebulaSQLParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FromClauseContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

std::vector<NebulaSQLParser::RelationContext *> NebulaSQLParser::FromClauseContext::relation() {
  return getRuleContexts<NebulaSQLParser::RelationContext>();
}

NebulaSQLParser::RelationContext* NebulaSQLParser::FromClauseContext::relation(size_t i) {
  return getRuleContext<NebulaSQLParser::RelationContext>(i);
}


size_t NebulaSQLParser::FromClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromClause;
}

void NebulaSQLParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void NebulaSQLParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 14, NebulaSQLParser::RuleFromClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(241);
    match(NebulaSQLParser::FROM);
    setState(242);
    relation();
    setState(247);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(243);
        match(NebulaSQLParser::T__1);
        setState(244);
        relation(); 
      }
      setState(249);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext::RelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::RelationContext::relationPrimary() {
  return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

std::vector<NebulaSQLParser::JoinRelationContext *> NebulaSQLParser::RelationContext::joinRelation() {
  return getRuleContexts<NebulaSQLParser::JoinRelationContext>();
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::RelationContext::joinRelation(size_t i) {
  return getRuleContext<NebulaSQLParser::JoinRelationContext>(i);
}


size_t NebulaSQLParser::RelationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleRelation;
}

void NebulaSQLParser::RelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelation(this);
}

void NebulaSQLParser::RelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelation(this);
}

NebulaSQLParser::RelationContext* NebulaSQLParser::relation() {
  RelationContext *_localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
  enterRule(_localctx, 16, NebulaSQLParser::RuleRelation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(250);
    relationPrimary();
    setState(254);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(251);
        joinRelation(); 
      }
      setState(256);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinRelationContext ------------------------------------------------------------------

NebulaSQLParser::JoinRelationContext::JoinRelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::JOIN() {
  return getToken(NebulaSQLParser::JOIN, 0);
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::JoinRelationContext::relationPrimary() {
  return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::JoinRelationContext::joinType() {
  return getRuleContext<NebulaSQLParser::JoinTypeContext>(0);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::JoinRelationContext::joinCriteria() {
  return getRuleContext<NebulaSQLParser::JoinCriteriaContext>(0);
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::NATURAL() {
  return getToken(NebulaSQLParser::NATURAL, 0);
}


size_t NebulaSQLParser::JoinRelationContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinRelation;
}

void NebulaSQLParser::JoinRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinRelation(this);
}

void NebulaSQLParser::JoinRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinRelation(this);
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::joinRelation() {
  JoinRelationContext *_localctx = _tracker.createInstance<JoinRelationContext>(_ctx, getState());
  enterRule(_localctx, 18, NebulaSQLParser::RuleJoinRelation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(268);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::INNER:
      case NebulaSQLParser::JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(257);
        joinType();
        setState(258);
        match(NebulaSQLParser::JOIN);
        setState(259);
        antlrcpp::downCast<JoinRelationContext *>(_localctx)->right = relationPrimary();
        setState(261);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
        case 1: {
          setState(260);
          joinCriteria();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NebulaSQLParser::NATURAL: {
        enterOuterAlt(_localctx, 2);
        setState(263);
        match(NebulaSQLParser::NATURAL);
        setState(264);
        joinType();
        setState(265);
        match(NebulaSQLParser::JOIN);
        setState(266);
        antlrcpp::downCast<JoinRelationContext *>(_localctx)->right = relationPrimary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinTypeContext ------------------------------------------------------------------

NebulaSQLParser::JoinTypeContext::JoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinTypeContext::INNER() {
  return getToken(NebulaSQLParser::INNER, 0);
}


size_t NebulaSQLParser::JoinTypeContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinType;
}

void NebulaSQLParser::JoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinType(this);
}

void NebulaSQLParser::JoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinType(this);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::joinType() {
  JoinTypeContext *_localctx = _tracker.createInstance<JoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 20, NebulaSQLParser::RuleJoinType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::INNER) {
      setState(270);
      match(NebulaSQLParser::INNER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinCriteriaContext ------------------------------------------------------------------

NebulaSQLParser::JoinCriteriaContext::JoinCriteriaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::JoinCriteriaContext::ON() {
  return getToken(NebulaSQLParser::ON, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::JoinCriteriaContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::JoinCriteriaContext::getRuleIndex() const {
  return NebulaSQLParser::RuleJoinCriteria;
}

void NebulaSQLParser::JoinCriteriaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinCriteria(this);
}

void NebulaSQLParser::JoinCriteriaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinCriteria(this);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::joinCriteria() {
  JoinCriteriaContext *_localctx = _tracker.createInstance<JoinCriteriaContext>(_ctx, getState());
  enterRule(_localctx, 22, NebulaSQLParser::RuleJoinCriteria);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(273);
    match(NebulaSQLParser::ON);
    setState(274);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::RelationPrimaryContext::RelationPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::RelationPrimaryContext::getRuleIndex() const {
  return NebulaSQLParser::RuleRelationPrimary;
}

void NebulaSQLParser::RelationPrimaryContext::copyFrom(RelationPrimaryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TableValuedFunctionContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::TableValuedFunctionContext::functionTable() {
  return getRuleContext<NebulaSQLParser::FunctionTableContext>(0);
}

NebulaSQLParser::TableValuedFunctionContext::TableValuedFunctionContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableValuedFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableValuedFunction(this);
}
void NebulaSQLParser::TableValuedFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableValuedFunction(this);
}
//----------------- InlineTableDefault2Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault2Context::inlineTable() {
  return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault2Context::InlineTableDefault2Context(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::InlineTableDefault2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTableDefault2(this);
}
void NebulaSQLParser::InlineTableDefault2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTableDefault2(this);
}
//----------------- AliasedRelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext* NebulaSQLParser::AliasedRelationContext::relation() {
  return getRuleContext<NebulaSQLParser::RelationContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedRelationContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedRelationContext::AliasedRelationContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::AliasedRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasedRelation(this);
}
void NebulaSQLParser::AliasedRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasedRelation(this);
}
//----------------- AliasedQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::AliasedQueryContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedQueryContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedQueryContext::AliasedQueryContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::AliasedQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasedQuery(this);
}
void NebulaSQLParser::AliasedQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasedQuery(this);
}
//----------------- TableNameContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableNameContext::multipartIdentifier() {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::TableNameContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::TableNameContext::TableNameContext(RelationPrimaryContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}
void NebulaSQLParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}
NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::relationPrimary() {
  RelationPrimaryContext *_localctx = _tracker.createInstance<RelationPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 24, NebulaSQLParser::RuleRelationPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(291);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TableNameContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(276);
      multipartIdentifier();
      setState(277);
      tableAlias();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::AliasedQueryContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(279);
      match(NebulaSQLParser::T__2);
      setState(280);
      query();
      setState(281);
      match(NebulaSQLParser::T__3);
      setState(282);
      tableAlias();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::AliasedRelationContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(284);
      match(NebulaSQLParser::T__2);
      setState(285);
      relation();
      setState(286);
      match(NebulaSQLParser::T__3);
      setState(287);
      tableAlias();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault2Context>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(289);
      inlineTable();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TableValuedFunctionContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(290);
      functionTable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTableContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext::FunctionTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::FunctionTableContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::FunctionTableContext::errorCapturingIdentifier() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::FunctionTableContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionTableContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::FunctionTableContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFunctionTable;
}

void NebulaSQLParser::FunctionTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTable(this);
}

void NebulaSQLParser::FunctionTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTable(this);
}

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::functionTable() {
  FunctionTableContext *_localctx = _tracker.createInstance<FunctionTableContext>(_ctx, getState());
  enterRule(_localctx, 26, NebulaSQLParser::RuleFunctionTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    antlrcpp::downCast<FunctionTableContext *>(_localctx)->funcName = errorCapturingIdentifier();
    setState(294);
    match(NebulaSQLParser::T__2);
    setState(303);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(295);
      expression();
      setState(300);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(296);
        match(NebulaSQLParser::T__1);
        setState(297);
        expression();
        setState(302);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(305);
    match(NebulaSQLParser::T__3);
    setState(306);
    tableAlias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromStatementContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext::FromStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::FromStatementContext::fromClause() {
  return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

std::vector<NebulaSQLParser::FromStatementBodyContext *> NebulaSQLParser::FromStatementContext::fromStatementBody() {
  return getRuleContexts<NebulaSQLParser::FromStatementBodyContext>();
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::FromStatementContext::fromStatementBody(size_t i) {
  return getRuleContext<NebulaSQLParser::FromStatementBodyContext>(i);
}


size_t NebulaSQLParser::FromStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromStatement;
}

void NebulaSQLParser::FromStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStatement(this);
}

void NebulaSQLParser::FromStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStatement(this);
}

NebulaSQLParser::FromStatementContext* NebulaSQLParser::fromStatement() {
  FromStatementContext *_localctx = _tracker.createInstance<FromStatementContext>(_ctx, getState());
  enterRule(_localctx, 28, NebulaSQLParser::RuleFromStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(308);
    fromClause();
    setState(310); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(309);
              fromStatementBody();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(312); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromStatementBodyContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementBodyContext::FromStatementBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::FromStatementBodyContext::selectClause() {
  return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::FromStatementBodyContext::whereClause() {
  return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::FromStatementBodyContext::aggregationClause() {
  return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}


size_t NebulaSQLParser::FromStatementBodyContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFromStatementBody;
}

void NebulaSQLParser::FromStatementBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromStatementBody(this);
}

void NebulaSQLParser::FromStatementBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromStatementBody(this);
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::fromStatementBody() {
  FromStatementBodyContext *_localctx = _tracker.createInstance<FromStatementBodyContext>(_ctx, getState());
  enterRule(_localctx, 30, NebulaSQLParser::RuleFromStatementBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(314);
    selectClause();
    setState(316);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(315);
      whereClause();
      break;
    }

    default:
      break;
    }
    setState(319);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(318);
      aggregationClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectClauseContext ------------------------------------------------------------------

NebulaSQLParser::SelectClauseContext::SelectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SelectClauseContext::SELECT() {
  return getToken(NebulaSQLParser::SELECT, 0);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::SelectClauseContext::namedExpressionSeq() {
  return getRuleContext<NebulaSQLParser::NamedExpressionSeqContext>(0);
}

std::vector<NebulaSQLParser::HintContext *> NebulaSQLParser::SelectClauseContext::hint() {
  return getRuleContexts<NebulaSQLParser::HintContext>();
}

NebulaSQLParser::HintContext* NebulaSQLParser::SelectClauseContext::hint(size_t i) {
  return getRuleContext<NebulaSQLParser::HintContext>(i);
}


size_t NebulaSQLParser::SelectClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSelectClause;
}

void NebulaSQLParser::SelectClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectClause(this);
}

void NebulaSQLParser::SelectClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectClause(this);
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::selectClause() {
  SelectClauseContext *_localctx = _tracker.createInstance<SelectClauseContext>(_ctx, getState());
  enterRule(_localctx, 32, NebulaSQLParser::RuleSelectClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(321);
    match(NebulaSQLParser::SELECT);
    setState(325);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(322);
        antlrcpp::downCast<SelectClauseContext *>(_localctx)->hintContext = hint();
        antlrcpp::downCast<SelectClauseContext *>(_localctx)->hints.push_back(antlrcpp::downCast<SelectClauseContext *>(_localctx)->hintContext); 
      }
      setState(327);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
    setState(328);
    namedExpressionSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

NebulaSQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WhereClauseContext::WHERE() {
  return getToken(NebulaSQLParser::WHERE, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::WhereClauseContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::WhereClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWhereClause;
}

void NebulaSQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void NebulaSQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 34, NebulaSQLParser::RuleWhereClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(330);
    match(NebulaSQLParser::WHERE);
    setState(331);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

NebulaSQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::HavingClauseContext::HAVING() {
  return getToken(NebulaSQLParser::HAVING, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::HavingClauseContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::HavingClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHavingClause;
}

void NebulaSQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void NebulaSQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 36, NebulaSQLParser::RuleHavingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    match(NebulaSQLParser::HAVING);
    setState(334);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineTableContext ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext::InlineTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::InlineTableContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::InlineTableContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::InlineTableContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::InlineTableContext::tableAlias() {
  return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}


size_t NebulaSQLParser::InlineTableContext::getRuleIndex() const {
  return NebulaSQLParser::RuleInlineTable;
}

void NebulaSQLParser::InlineTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineTable(this);
}

void NebulaSQLParser::InlineTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineTable(this);
}

NebulaSQLParser::InlineTableContext* NebulaSQLParser::inlineTable() {
  InlineTableContext *_localctx = _tracker.createInstance<InlineTableContext>(_ctx, getState());
  enterRule(_localctx, 38, NebulaSQLParser::RuleInlineTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(336);
    match(NebulaSQLParser::VALUES);
    setState(337);
    expression();
    setState(342);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(338);
        match(NebulaSQLParser::T__1);
        setState(339);
        expression(); 
      }
      setState(344);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
    }
    setState(345);
    tableAlias();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

NebulaSQLParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::TableAliasContext::strictIdentifier() {
  return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TableAliasContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::TableAliasContext::identifierList() {
  return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}


size_t NebulaSQLParser::TableAliasContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTableAlias;
}

void NebulaSQLParser::TableAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAlias(this);
}

void NebulaSQLParser::TableAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAlias(this);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 40, NebulaSQLParser::RuleTableAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(354);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(348);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        setState(347);
        match(NebulaSQLParser::AS);
        break;
      }

      default:
        break;
      }
      setState(350);
      strictIdentifier();
      setState(352);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
      case 1: {
        setState(351);
        identifierList();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierListContext::MultipartIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::MultipartIdentifierContext *> NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier() {
  return getRuleContexts<NebulaSQLParser::MultipartIdentifierContext>();
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierListContext::getRuleIndex() const {
  return NebulaSQLParser::RuleMultipartIdentifierList;
}

void NebulaSQLParser::MultipartIdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipartIdentifierList(this);
}

void NebulaSQLParser::MultipartIdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipartIdentifierList(this);
}

NebulaSQLParser::MultipartIdentifierListContext* NebulaSQLParser::multipartIdentifierList() {
  MultipartIdentifierListContext *_localctx = _tracker.createInstance<MultipartIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 42, NebulaSQLParser::RuleMultipartIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    multipartIdentifier();
    setState(361);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(357);
      match(NebulaSQLParser::T__1);
      setState(358);
      multipartIdentifier();
      setState(363);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipartIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext::MultipartIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext *> NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier() {
  return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleMultipartIdentifier;
}

void NebulaSQLParser::MultipartIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipartIdentifier(this);
}

void NebulaSQLParser::MultipartIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipartIdentifier(this);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::multipartIdentifier() {
  MultipartIdentifierContext *_localctx = _tracker.createInstance<MultipartIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 44, NebulaSQLParser::RuleMultipartIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(364);
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(369);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(365);
        match(NebulaSQLParser::T__4);
        setState(366);
        antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->parts.push_back(antlrcpp::downCast<MultipartIdentifierContext *>(_localctx)->errorCapturingIdentifierContext); 
      }
      setState(371);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionContext::NamedExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::NamedExpressionContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::NamedExpressionContext::identifierList() {
  return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* NebulaSQLParser::NamedExpressionContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::NamedExpressionContext::errorCapturingIdentifier() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}


size_t NebulaSQLParser::NamedExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNamedExpression;
}

void NebulaSQLParser::NamedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedExpression(this);
}

void NebulaSQLParser::NamedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedExpression(this);
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::namedExpression() {
  NamedExpressionContext *_localctx = _tracker.createInstance<NamedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 46, NebulaSQLParser::RuleNamedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(372);
    expression();
    setState(380);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(374);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
      case 1: {
        setState(373);
        match(NebulaSQLParser::AS);
        break;
      }

      default:
        break;
      }
      setState(378);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
      case 1: {
        setState(376);
        antlrcpp::downCast<NamedExpressionContext *>(_localctx)->name = errorCapturingIdentifier();
        break;
      }

      case 2: {
        setState(377);
        identifierList();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::IdentifierContext::strictIdentifier() {
  return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::IdentifierContext::strictNonReserved() {
  return getRuleContext<NebulaSQLParser::StrictNonReservedContext>(0);
}


size_t NebulaSQLParser::IdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifier;
}

void NebulaSQLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void NebulaSQLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 48, NebulaSQLParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(385);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(382);
      strictIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(383);

      if (!(!SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
      setState(384);
      strictNonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::StrictIdentifierContext::StrictIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::StrictIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStrictIdentifier;
}

void NebulaSQLParser::StrictIdentifierContext::copyFrom(StrictIdentifierContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- QuotedIdentifierAlternativeContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::QuotedIdentifierAlternativeContext::quotedIdentifier() {
  return getRuleContext<NebulaSQLParser::QuotedIdentifierContext>(0);
}

NebulaSQLParser::QuotedIdentifierAlternativeContext::QuotedIdentifierAlternativeContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::QuotedIdentifierAlternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedIdentifierAlternative(this);
}
void NebulaSQLParser::QuotedIdentifierAlternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedIdentifierAlternative(this);
}
//----------------- UnquotedIdentifierContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnquotedIdentifierContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::ansiNonReserved() {
  return getRuleContext<NebulaSQLParser::AnsiNonReservedContext>(0);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::nonReserved() {
  return getRuleContext<NebulaSQLParser::NonReservedContext>(0);
}

NebulaSQLParser::UnquotedIdentifierContext::UnquotedIdentifierContext(StrictIdentifierContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::UnquotedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnquotedIdentifier(this);
}
void NebulaSQLParser::UnquotedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnquotedIdentifier(this);
}
NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::strictIdentifier() {
  StrictIdentifierContext *_localctx = _tracker.createInstance<StrictIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 50, NebulaSQLParser::RuleStrictIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(387);
      match(NebulaSQLParser::IDENTIFIER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::QuotedIdentifierAlternativeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(388);
      quotedIdentifier();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(389);

      if (!(SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "SQL_standard_keyword_behavior");
      setState(390);
      ansiNonReserved();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(391);

      if (!(!SQL_standard_keyword_behavior)) throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
      setState(392);
      nonReserved();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuotedIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext::QuotedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QuotedIdentifierContext::BACKQUOTED_IDENTIFIER() {
  return getToken(NebulaSQLParser::BACKQUOTED_IDENTIFIER, 0);
}


size_t NebulaSQLParser::QuotedIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQuotedIdentifier;
}

void NebulaSQLParser::QuotedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuotedIdentifier(this);
}

void NebulaSQLParser::QuotedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuotedIdentifier(this);
}

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::quotedIdentifier() {
  QuotedIdentifierContext *_localctx = _tracker.createInstance<QuotedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 52, NebulaSQLParser::RuleQuotedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(395);
    match(NebulaSQLParser::BACKQUOTED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::IdentifierListContext::identifierSeq() {
  return getRuleContext<NebulaSQLParser::IdentifierSeqContext>(0);
}


size_t NebulaSQLParser::IdentifierListContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifierList;
}

void NebulaSQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void NebulaSQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 54, NebulaSQLParser::RuleIdentifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    match(NebulaSQLParser::T__2);
    setState(398);
    identifierSeq();
    setState(399);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierSeqContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierSeqContext::IdentifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext *> NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier() {
  return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier(size_t i) {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::IdentifierSeqContext::getRuleIndex() const {
  return NebulaSQLParser::RuleIdentifierSeq;
}

void NebulaSQLParser::IdentifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierSeq(this);
}

void NebulaSQLParser::IdentifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierSeq(this);
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::identifierSeq() {
  IdentifierSeqContext *_localctx = _tracker.createInstance<IdentifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 56, NebulaSQLParser::RuleIdentifierSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(401);
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
    antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
    setState(406);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NebulaSQLParser::T__1) {
      setState(402);
      match(NebulaSQLParser::T__1);
      setState(403);
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
      antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->ident.push_back(antlrcpp::downCast<IdentifierSeqContext *>(_localctx)->errorCapturingIdentifierContext);
      setState(408);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierContext::ErrorCapturingIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorCapturingIdentifierContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::ErrorCapturingIdentifierContext::errorCapturingIdentifierExtra() {
  return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierExtraContext>(0);
}


size_t NebulaSQLParser::ErrorCapturingIdentifierContext::getRuleIndex() const {
  return NebulaSQLParser::RuleErrorCapturingIdentifier;
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorCapturingIdentifier(this);
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorCapturingIdentifier(this);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::errorCapturingIdentifier() {
  ErrorCapturingIdentifierContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 58, NebulaSQLParser::RuleErrorCapturingIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(409);
    identifier();
    setState(410);
    errorCapturingIdentifierExtra();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ErrorCapturingIdentifierExtraContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierExtraContext::ErrorCapturingIdentifierExtraContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ErrorCapturingIdentifierExtraContext::getRuleIndex() const {
  return NebulaSQLParser::RuleErrorCapturingIdentifierExtra;
}

void NebulaSQLParser::ErrorCapturingIdentifierExtraContext::copyFrom(ErrorCapturingIdentifierExtraContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorIdentContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> NebulaSQLParser::ErrorIdentContext::MINUS() {
  return getTokens(NebulaSQLParser::MINUS);
}

tree::TerminalNode* NebulaSQLParser::ErrorIdentContext::MINUS(size_t i) {
  return getToken(NebulaSQLParser::MINUS, i);
}

std::vector<NebulaSQLParser::IdentifierContext *> NebulaSQLParser::ErrorIdentContext::identifier() {
  return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorIdentContext::identifier(size_t i) {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}

NebulaSQLParser::ErrorIdentContext::ErrorIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ErrorIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterErrorIdent(this);
}
void NebulaSQLParser::ErrorIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitErrorIdent(this);
}
//----------------- RealIdentContext ------------------------------------------------------------------

NebulaSQLParser::RealIdentContext::RealIdentContext(ErrorCapturingIdentifierExtraContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::RealIdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealIdent(this);
}
void NebulaSQLParser::RealIdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealIdent(this);
}
NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::errorCapturingIdentifierExtra() {
  ErrorCapturingIdentifierExtraContext *_localctx = _tracker.createInstance<ErrorCapturingIdentifierExtraContext>(_ctx, getState());
  enterRule(_localctx, 60, NebulaSQLParser::RuleErrorCapturingIdentifierExtra);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(419);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ErrorIdentContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(414); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(412);
                match(NebulaSQLParser::MINUS);
                setState(413);
                identifier();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(416); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::RealIdentContext>(_localctx);
      enterOuterAlt(_localctx, 2);

      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedExpressionSeqContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionSeqContext::NamedExpressionSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::NamedExpressionContext *> NebulaSQLParser::NamedExpressionSeqContext::namedExpression() {
  return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::NamedExpressionSeqContext::namedExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}


size_t NebulaSQLParser::NamedExpressionSeqContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNamedExpressionSeq;
}

void NebulaSQLParser::NamedExpressionSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedExpressionSeq(this);
}

void NebulaSQLParser::NamedExpressionSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedExpressionSeq(this);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::namedExpressionSeq() {
  NamedExpressionSeqContext *_localctx = _tracker.createInstance<NamedExpressionSeqContext>(_ctx, getState());
  enterRule(_localctx, 62, NebulaSQLParser::RuleNamedExpressionSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(421);
    namedExpression();
    setState(426);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(422);
        match(NebulaSQLParser::T__1);
        setState(423);
        namedExpression(); 
      }
      setState(428);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::ExpressionContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::ExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleExpression;
}

void NebulaSQLParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void NebulaSQLParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 64, NebulaSQLParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(429);
    booleanExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanExpressionContext ------------------------------------------------------------------

NebulaSQLParser::BooleanExpressionContext::BooleanExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::BooleanExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleBooleanExpression;
}

void NebulaSQLParser::BooleanExpressionContext::copyFrom(BooleanExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- LogicalNotContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LogicalNotContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalNotContext::booleanExpression() {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}

NebulaSQLParser::LogicalNotContext::LogicalNotContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LogicalNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalNot(this);
}
void NebulaSQLParser::LogicalNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalNot(this);
}
//----------------- PredicatedContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicatedContext::valueExpression() {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::PredicatedContext::predicate() {
  return getRuleContext<NebulaSQLParser::PredicateContext>(0);
}

NebulaSQLParser::PredicatedContext::PredicatedContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::PredicatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicated(this);
}
void NebulaSQLParser::PredicatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicated(this);
}
//----------------- ExistsContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExistsContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::ExistsContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::ExistsContext::ExistsContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExists(this);
}
void NebulaSQLParser::ExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExists(this);
}
//----------------- LogicalBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::BooleanExpressionContext *> NebulaSQLParser::LogicalBinaryContext::booleanExpression() {
  return getRuleContexts<NebulaSQLParser::BooleanExpressionContext>();
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalBinaryContext::booleanExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::OR() {
  return getToken(NebulaSQLParser::OR, 0);
}

NebulaSQLParser::LogicalBinaryContext::LogicalBinaryContext(BooleanExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LogicalBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalBinary(this);
}
void NebulaSQLParser::LogicalBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalBinary(this);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression() {
   return booleanExpression(0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::BooleanExpressionContext *_localctx = _tracker.createInstance<BooleanExpressionContext>(_ctx, parentState);
  NebulaSQLParser::BooleanExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 66;
  enterRecursionRule(_localctx, 66, NebulaSQLParser::RuleBooleanExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(443);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LogicalNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(432);
      match(NebulaSQLParser::NOT);
      setState(433);
      booleanExpression(5);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ExistsContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(434);
      match(NebulaSQLParser::EXISTS);
      setState(435);
      match(NebulaSQLParser::T__2);
      setState(436);
      query();
      setState(437);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<PredicatedContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(439);
      valueExpression(0);
      setState(441);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
      case 1: {
        setState(440);
        predicate();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(453);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(451);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(445);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(446);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->op = match(NebulaSQLParser::AND);
          setState(447);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(3);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<LogicalBinaryContext>(_tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
          setState(448);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(449);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->op = match(NebulaSQLParser::OR);
          setState(450);
          antlrcpp::downCast<LogicalBinaryContext *>(_localctx)->right = booleanExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(455);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- WindowedAggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowedAggregationClauseContext::WindowedAggregationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::windowClause() {
  return getRuleContext<NebulaSQLParser::WindowClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::aggregationClause() {
  return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::watermarkClause() {
  return getRuleContext<NebulaSQLParser::WatermarkClauseContext>(0);
}


size_t NebulaSQLParser::WindowedAggregationClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowedAggregationClause;
}

void NebulaSQLParser::WindowedAggregationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowedAggregationClause(this);
}

void NebulaSQLParser::WindowedAggregationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowedAggregationClause(this);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::windowedAggregationClause() {
  WindowedAggregationClauseContext *_localctx = _tracker.createInstance<WindowedAggregationClauseContext>(_ctx, getState());
  enterRule(_localctx, 68, NebulaSQLParser::RuleWindowedAggregationClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(457);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::GROUP) {
      setState(456);
      aggregationClause();
    }
    setState(459);
    windowClause();
    setState(461);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(460);
      watermarkClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::AggregationClauseContext::AggregationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUP() {
  return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::AggregationClauseContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::AggregationClauseContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::WITH() {
  return getToken(NebulaSQLParser::WITH, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

std::vector<NebulaSQLParser::GroupingSetContext *> NebulaSQLParser::AggregationClauseContext::groupingSet() {
  return getRuleContexts<NebulaSQLParser::GroupingSetContext>();
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::AggregationClauseContext::groupingSet(size_t i) {
  return getRuleContext<NebulaSQLParser::GroupingSetContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}


size_t NebulaSQLParser::AggregationClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAggregationClause;
}

void NebulaSQLParser::AggregationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregationClause(this);
}

void NebulaSQLParser::AggregationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregationClause(this);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::aggregationClause() {
  AggregationClauseContext *_localctx = _tracker.createInstance<AggregationClauseContext>(_ctx, getState());
  enterRule(_localctx, 70, NebulaSQLParser::RuleAggregationClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(507);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(463);
      match(NebulaSQLParser::GROUP);
      setState(464);
      match(NebulaSQLParser::BY);
      setState(465);
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext = expression();
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->groupingExpressions.push_back(antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext);
      setState(470);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(466);
          match(NebulaSQLParser::T__1);
          setState(467);
          antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<AggregationClauseContext *>(_localctx)->groupingExpressions.push_back(antlrcpp::downCast<AggregationClauseContext *>(_localctx)->expressionContext); 
        }
        setState(472);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
      }
      setState(490);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
      case 1: {
        setState(473);
        match(NebulaSQLParser::WITH);
        setState(474);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::ROLLUP);
        break;
      }

      case 2: {
        setState(475);
        match(NebulaSQLParser::WITH);
        setState(476);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::CUBE);
        break;
      }

      case 3: {
        setState(477);
        antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
        setState(478);
        match(NebulaSQLParser::SETS);
        setState(479);
        match(NebulaSQLParser::T__2);
        setState(480);
        groupingSet();
        setState(485);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(481);
          match(NebulaSQLParser::T__1);
          setState(482);
          groupingSet();
          setState(487);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(488);
        match(NebulaSQLParser::T__3);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(492);
      match(NebulaSQLParser::GROUP);
      setState(493);
      match(NebulaSQLParser::BY);
      setState(494);
      antlrcpp::downCast<AggregationClauseContext *>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
      setState(495);
      match(NebulaSQLParser::SETS);
      setState(496);
      match(NebulaSQLParser::T__2);
      setState(497);
      groupingSet();
      setState(502);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(498);
        match(NebulaSQLParser::T__1);
        setState(499);
        groupingSet();
        setState(504);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(505);
      match(NebulaSQLParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingSetContext ------------------------------------------------------------------

NebulaSQLParser::GroupingSetContext::GroupingSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::GroupingSetContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::GroupingSetContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::GroupingSetContext::getRuleIndex() const {
  return NebulaSQLParser::RuleGroupingSet;
}

void NebulaSQLParser::GroupingSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingSet(this);
}

void NebulaSQLParser::GroupingSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingSet(this);
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::groupingSet() {
  GroupingSetContext *_localctx = _tracker.createInstance<GroupingSetContext>(_ctx, getState());
  enterRule(_localctx, 72, NebulaSQLParser::RuleGroupingSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(522);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(509);
      match(NebulaSQLParser::T__2);
      setState(518);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(510);
        expression();
        setState(515);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(511);
          match(NebulaSQLParser::T__1);
          setState(512);
          expression();
          setState(517);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(520);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(521);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WindowClauseContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}

NebulaSQLParser::WindowSpecContext* NebulaSQLParser::WindowClauseContext::windowSpec() {
  return getRuleContext<NebulaSQLParser::WindowSpecContext>(0);
}


size_t NebulaSQLParser::WindowClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowClause;
}

void NebulaSQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void NebulaSQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 74, NebulaSQLParser::RuleWindowClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(524);
    match(NebulaSQLParser::WINDOW);
    setState(525);
    windowSpec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WatermarkClauseContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkClauseContext::WatermarkClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::WatermarkClauseContext::WATERMARK() {
  return getToken(NebulaSQLParser::WATERMARK, 0);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::WatermarkClauseContext::watermarkParameters() {
  return getRuleContext<NebulaSQLParser::WatermarkParametersContext>(0);
}


size_t NebulaSQLParser::WatermarkClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWatermarkClause;
}

void NebulaSQLParser::WatermarkClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWatermarkClause(this);
}

void NebulaSQLParser::WatermarkClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWatermarkClause(this);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::watermarkClause() {
  WatermarkClauseContext *_localctx = _tracker.createInstance<WatermarkClauseContext>(_ctx, getState());
  enterRule(_localctx, 76, NebulaSQLParser::RuleWatermarkClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    match(NebulaSQLParser::WATERMARK);
    setState(528);
    match(NebulaSQLParser::T__2);
    setState(529);
    watermarkParameters();
    setState(530);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WatermarkParametersContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkParametersContext::WatermarkParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::WatermarkParametersContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::WatermarkParametersContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::WatermarkParametersContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::WatermarkParametersContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWatermarkParameters;
}

void NebulaSQLParser::WatermarkParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWatermarkParameters(this);
}

void NebulaSQLParser::WatermarkParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWatermarkParameters(this);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::watermarkParameters() {
  WatermarkParametersContext *_localctx = _tracker.createInstance<WatermarkParametersContext>(_ctx, getState());
  enterRule(_localctx, 78, NebulaSQLParser::RuleWatermarkParameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(532);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermarkIdentifier = identifier();
    setState(533);
    match(NebulaSQLParser::T__1);
    setState(534);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermark = match(NebulaSQLParser::INTEGER_VALUE);
    setState(535);
    antlrcpp::downCast<WatermarkParametersContext *>(_localctx)->watermarkTimeUnit = timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

NebulaSQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::WindowSpecContext::getRuleIndex() const {
  return NebulaSQLParser::RuleWindowSpec;
}

void NebulaSQLParser::WindowSpecContext::copyFrom(WindowSpecContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TimeBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext* NebulaSQLParser::TimeBasedWindowContext::timeWindow() {
  return getRuleContext<NebulaSQLParser::TimeWindowContext>(0);
}

NebulaSQLParser::TimeBasedWindowContext::TimeBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TimeBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeBasedWindow(this);
}
void NebulaSQLParser::TimeBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeBasedWindow(this);
}
//----------------- CountBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext* NebulaSQLParser::CountBasedWindowContext::countWindow() {
  return getRuleContext<NebulaSQLParser::CountWindowContext>(0);
}

NebulaSQLParser::CountBasedWindowContext::CountBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::CountBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountBasedWindow(this);
}
void NebulaSQLParser::CountBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountBasedWindow(this);
}
//----------------- ThresholdBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::ConditionWindowContext* NebulaSQLParser::ThresholdBasedWindowContext::conditionWindow() {
  return getRuleContext<NebulaSQLParser::ConditionWindowContext>(0);
}

NebulaSQLParser::ThresholdBasedWindowContext::ThresholdBasedWindowContext(WindowSpecContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ThresholdBasedWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThresholdBasedWindow(this);
}
void NebulaSQLParser::ThresholdBasedWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThresholdBasedWindow(this);
}
NebulaSQLParser::WindowSpecContext* NebulaSQLParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 80, NebulaSQLParser::RuleWindowSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(540);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TimeBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(537);
      timeWindow();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(538);
      countWindow();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ThresholdBasedWindowContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(539);
      conditionWindow();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext::TimeWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::TimeWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimeWindow;
}

void NebulaSQLParser::TimeWindowContext::copyFrom(TimeWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TumblingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TumblingWindowContext::TUMBLING() {
  return getToken(NebulaSQLParser::TUMBLING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::TumblingWindowContext::sizeParameter() {
  return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::TumblingWindowContext::timestampParameter() {
  return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::TumblingWindowContext::TumblingWindowContext(TimeWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TumblingWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTumblingWindow(this);
}
void NebulaSQLParser::TumblingWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTumblingWindow(this);
}
//----------------- SlidingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SlidingWindowContext::SLIDING() {
  return getToken(NebulaSQLParser::SLIDING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::SlidingWindowContext::sizeParameter() {
  return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::SlidingWindowContext::advancebyParameter() {
  return getRuleContext<NebulaSQLParser::AdvancebyParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::SlidingWindowContext::timestampParameter() {
  return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::SlidingWindowContext::SlidingWindowContext(TimeWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SlidingWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlidingWindow(this);
}
void NebulaSQLParser::SlidingWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlidingWindow(this);
}
NebulaSQLParser::TimeWindowContext* NebulaSQLParser::timeWindow() {
  TimeWindowContext *_localctx = _tracker.createInstance<TimeWindowContext>(_ctx, getState());
  enterRule(_localctx, 82, NebulaSQLParser::RuleTimeWindow);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(564);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::TUMBLING: {
        _localctx = _tracker.createInstance<NebulaSQLParser::TumblingWindowContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(542);
        match(NebulaSQLParser::TUMBLING);
        setState(543);
        match(NebulaSQLParser::T__2);
        setState(547);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::IDENTIFIER) {
          setState(544);
          timestampParameter();
          setState(545);
          match(NebulaSQLParser::T__1);
        }
        setState(549);
        sizeParameter();
        setState(550);
        match(NebulaSQLParser::T__3);
        break;
      }

      case NebulaSQLParser::SLIDING: {
        _localctx = _tracker.createInstance<NebulaSQLParser::SlidingWindowContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(552);
        match(NebulaSQLParser::SLIDING);
        setState(553);
        match(NebulaSQLParser::T__2);
        setState(557);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::IDENTIFIER) {
          setState(554);
          timestampParameter();
          setState(555);
          match(NebulaSQLParser::T__1);
        }
        setState(559);
        sizeParameter();
        setState(560);
        match(NebulaSQLParser::T__1);
        setState(561);
        advancebyParameter();
        setState(562);
        match(NebulaSQLParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CountWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext::CountWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::CountWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleCountWindow;
}

void NebulaSQLParser::CountWindowContext::copyFrom(CountWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CountBasedTumblingContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::TUMBLING() {
  return getToken(NebulaSQLParser::TUMBLING, 0);
}

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::CountBasedTumblingContext::CountBasedTumblingContext(CountWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::CountBasedTumblingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCountBasedTumbling(this);
}
void NebulaSQLParser::CountBasedTumblingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCountBasedTumbling(this);
}
NebulaSQLParser::CountWindowContext* NebulaSQLParser::countWindow() {
  CountWindowContext *_localctx = _tracker.createInstance<CountWindowContext>(_ctx, getState());
  enterRule(_localctx, 84, NebulaSQLParser::RuleCountWindow);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedTumblingContext>(_localctx);
    enterOuterAlt(_localctx, 1);
    setState(566);
    match(NebulaSQLParser::TUMBLING);
    setState(567);
    match(NebulaSQLParser::T__2);
    setState(568);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(569);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionWindowContext ------------------------------------------------------------------

NebulaSQLParser::ConditionWindowContext::ConditionWindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ConditionWindowContext::getRuleIndex() const {
  return NebulaSQLParser::RuleConditionWindow;
}

void NebulaSQLParser::ConditionWindowContext::copyFrom(ConditionWindowContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ThresholdWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ThresholdWindowContext::THRESHOLD() {
  return getToken(NebulaSQLParser::THRESHOLD, 0);
}

NebulaSQLParser::ConditionParameterContext* NebulaSQLParser::ThresholdWindowContext::conditionParameter() {
  return getRuleContext<NebulaSQLParser::ConditionParameterContext>(0);
}

NebulaSQLParser::ThresholdMinSizeParameterContext* NebulaSQLParser::ThresholdWindowContext::thresholdMinSizeParameter() {
  return getRuleContext<NebulaSQLParser::ThresholdMinSizeParameterContext>(0);
}

NebulaSQLParser::ThresholdWindowContext::ThresholdWindowContext(ConditionWindowContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ThresholdWindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThresholdWindow(this);
}
void NebulaSQLParser::ThresholdWindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThresholdWindow(this);
}
NebulaSQLParser::ConditionWindowContext* NebulaSQLParser::conditionWindow() {
  ConditionWindowContext *_localctx = _tracker.createInstance<ConditionWindowContext>(_ctx, getState());
  enterRule(_localctx, 86, NebulaSQLParser::RuleConditionWindow);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    _localctx = _tracker.createInstance<NebulaSQLParser::ThresholdWindowContext>(_localctx);
    enterOuterAlt(_localctx, 1);
    setState(571);
    match(NebulaSQLParser::THRESHOLD);
    setState(572);
    match(NebulaSQLParser::T__2);
    setState(573);
    conditionParameter();
    setState(576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::T__1) {
      setState(574);
      match(NebulaSQLParser::T__1);
      setState(575);
      thresholdMinSizeParameter();
    }
    setState(578);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionParameterContext ------------------------------------------------------------------

NebulaSQLParser::ConditionParameterContext::ConditionParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ConditionParameterContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}


size_t NebulaSQLParser::ConditionParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleConditionParameter;
}

void NebulaSQLParser::ConditionParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionParameter(this);
}

void NebulaSQLParser::ConditionParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionParameter(this);
}

NebulaSQLParser::ConditionParameterContext* NebulaSQLParser::conditionParameter() {
  ConditionParameterContext *_localctx = _tracker.createInstance<ConditionParameterContext>(_ctx, getState());
  enterRule(_localctx, 88, NebulaSQLParser::RuleConditionParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(580);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThresholdMinSizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::ThresholdMinSizeParameterContext::ThresholdMinSizeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ThresholdMinSizeParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::ThresholdMinSizeParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleThresholdMinSizeParameter;
}

void NebulaSQLParser::ThresholdMinSizeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThresholdMinSizeParameter(this);
}

void NebulaSQLParser::ThresholdMinSizeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThresholdMinSizeParameter(this);
}

NebulaSQLParser::ThresholdMinSizeParameterContext* NebulaSQLParser::thresholdMinSizeParameter() {
  ThresholdMinSizeParameterContext *_localctx = _tracker.createInstance<ThresholdMinSizeParameterContext>(_ctx, getState());
  enterRule(_localctx, 90, NebulaSQLParser::RuleThresholdMinSizeParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(582);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::SizeParameterContext::SizeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::SIZE() {
  return getToken(NebulaSQLParser::SIZE, 0);
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SizeParameterContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::SizeParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSizeParameter;
}

void NebulaSQLParser::SizeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeParameter(this);
}

void NebulaSQLParser::SizeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeParameter(this);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::sizeParameter() {
  SizeParameterContext *_localctx = _tracker.createInstance<SizeParameterContext>(_ctx, getState());
  enterRule(_localctx, 92, NebulaSQLParser::RuleSizeParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(584);
    match(NebulaSQLParser::SIZE);
    setState(585);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(586);
    timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdvancebyParameterContext ------------------------------------------------------------------

NebulaSQLParser::AdvancebyParameterContext::AdvancebyParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::ADVANCE() {
  return getToken(NebulaSQLParser::ADVANCE, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::AdvancebyParameterContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::AdvancebyParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAdvancebyParameter;
}

void NebulaSQLParser::AdvancebyParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdvancebyParameter(this);
}

void NebulaSQLParser::AdvancebyParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdvancebyParameter(this);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::advancebyParameter() {
  AdvancebyParameterContext *_localctx = _tracker.createInstance<AdvancebyParameterContext>(_ctx, getState());
  enterRule(_localctx, 94, NebulaSQLParser::RuleAdvancebyParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(588);
    match(NebulaSQLParser::ADVANCE);
    setState(589);
    match(NebulaSQLParser::BY);
    setState(590);
    match(NebulaSQLParser::INTEGER_VALUE);
    setState(591);
    timeUnit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeUnitContext ------------------------------------------------------------------

NebulaSQLParser::TimeUnitContext::TimeUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MS() {
  return getToken(NebulaSQLParser::MS, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::SEC() {
  return getToken(NebulaSQLParser::SEC, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MIN() {
  return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::HOUR() {
  return getToken(NebulaSQLParser::HOUR, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::DAY() {
  return getToken(NebulaSQLParser::DAY, 0);
}


size_t NebulaSQLParser::TimeUnitContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimeUnit;
}

void NebulaSQLParser::TimeUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeUnit(this);
}

void NebulaSQLParser::TimeUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeUnit(this);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::timeUnit() {
  TimeUnitContext *_localctx = _tracker.createInstance<TimeUnitContext>(_ctx, getState());
  enterRule(_localctx, 96, NebulaSQLParser::RuleTimeUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(593);
    _la = _input->LA(1);
    if (!(((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimestampParameterContext ------------------------------------------------------------------

NebulaSQLParser::TimestampParameterContext::TimestampParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::TimestampParameterContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::TimestampParameterContext::getRuleIndex() const {
  return NebulaSQLParser::RuleTimestampParameter;
}

void NebulaSQLParser::TimestampParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimestampParameter(this);
}

void NebulaSQLParser::TimestampParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimestampParameter(this);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::timestampParameter() {
  TimestampParameterContext *_localctx = _tracker.createInstance<TimestampParameterContext>(_ctx, getState());
  enterRule(_localctx, 98, NebulaSQLParser::RuleTimestampParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(595);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::AVG() {
  return getToken(NebulaSQLParser::AVG, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MAX() {
  return getToken(NebulaSQLParser::MAX, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MIN() {
  return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::SUM() {
  return getToken(NebulaSQLParser::SUM, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::COUNT() {
  return getToken(NebulaSQLParser::COUNT, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MEDIAN() {
  return getToken(NebulaSQLParser::MEDIAN, 0);
}


size_t NebulaSQLParser::FunctionNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFunctionName;
}

void NebulaSQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void NebulaSQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 100, NebulaSQLParser::RuleFunctionName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(597);
    _la = _input->LA(1);
    if (!(((((_la - 86) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 86)) & 249) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkClauseContext ------------------------------------------------------------------

NebulaSQLParser::SinkClauseContext::SinkClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::INTO() {
  return getToken(NebulaSQLParser::INTO, 0);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::SinkClauseContext::sinkType() {
  return getRuleContext<NebulaSQLParser::SinkTypeContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}


size_t NebulaSQLParser::SinkClauseContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkClause;
}

void NebulaSQLParser::SinkClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkClause(this);
}

void NebulaSQLParser::SinkClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkClause(this);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::sinkClause() {
  SinkClauseContext *_localctx = _tracker.createInstance<SinkClauseContext>(_ctx, getState());
  enterRule(_localctx, 102, NebulaSQLParser::RuleSinkClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(599);
    match(NebulaSQLParser::INTO);
    setState(600);
    sinkType();
    setState(602);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(601);
      match(NebulaSQLParser::AS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeContext::SinkTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::SinkTypeZMQContext* NebulaSQLParser::SinkTypeContext::sinkTypeZMQ() {
  return getRuleContext<NebulaSQLParser::SinkTypeZMQContext>(0);
}

NebulaSQLParser::SinkTypeKafkaContext* NebulaSQLParser::SinkTypeContext::sinkTypeKafka() {
  return getRuleContext<NebulaSQLParser::SinkTypeKafkaContext>(0);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::SinkTypeContext::sinkTypeFile() {
  return getRuleContext<NebulaSQLParser::SinkTypeFileContext>(0);
}

NebulaSQLParser::SinkTypeMQTTContext* NebulaSQLParser::SinkTypeContext::sinkTypeMQTT() {
  return getRuleContext<NebulaSQLParser::SinkTypeMQTTContext>(0);
}

NebulaSQLParser::SinkTypeOPCContext* NebulaSQLParser::SinkTypeContext::sinkTypeOPC() {
  return getRuleContext<NebulaSQLParser::SinkTypeOPCContext>(0);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::SinkTypeContext::sinkTypePrint() {
  return getRuleContext<NebulaSQLParser::SinkTypePrintContext>(0);
}


size_t NebulaSQLParser::SinkTypeContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkType;
}

void NebulaSQLParser::SinkTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkType(this);
}

void NebulaSQLParser::SinkTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkType(this);
}

NebulaSQLParser::SinkTypeContext* NebulaSQLParser::sinkType() {
  SinkTypeContext *_localctx = _tracker.createInstance<SinkTypeContext>(_ctx, getState());
  enterRule(_localctx, 104, NebulaSQLParser::RuleSinkType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(610);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NebulaSQLParser::ZMQ: {
        enterOuterAlt(_localctx, 1);
        setState(604);
        sinkTypeZMQ();
        break;
      }

      case NebulaSQLParser::KAFKA: {
        enterOuterAlt(_localctx, 2);
        setState(605);
        sinkTypeKafka();
        break;
      }

      case NebulaSQLParser::FILE: {
        enterOuterAlt(_localctx, 3);
        setState(606);
        sinkTypeFile();
        break;
      }

      case NebulaSQLParser::MQTT: {
        enterOuterAlt(_localctx, 4);
        setState(607);
        sinkTypeMQTT();
        break;
      }

      case NebulaSQLParser::OPC: {
        enterOuterAlt(_localctx, 5);
        setState(608);
        sinkTypeOPC();
        break;
      }

      case NebulaSQLParser::PRINT: {
        enterOuterAlt(_localctx, 6);
        setState(609);
        sinkTypePrint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeZMQContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeZMQContext::SinkTypeZMQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ZmqKeywordContext* NebulaSQLParser::SinkTypeZMQContext::zmqKeyword() {
  return getRuleContext<NebulaSQLParser::ZmqKeywordContext>(0);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::SinkTypeZMQContext::streamName() {
  return getRuleContext<NebulaSQLParser::StreamNameContext>(0);
}

NebulaSQLParser::HostContext* NebulaSQLParser::SinkTypeZMQContext::host() {
  return getRuleContext<NebulaSQLParser::HostContext>(0);
}

NebulaSQLParser::PortContext* NebulaSQLParser::SinkTypeZMQContext::port() {
  return getRuleContext<NebulaSQLParser::PortContext>(0);
}


size_t NebulaSQLParser::SinkTypeZMQContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeZMQ;
}

void NebulaSQLParser::SinkTypeZMQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeZMQ(this);
}

void NebulaSQLParser::SinkTypeZMQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeZMQ(this);
}

NebulaSQLParser::SinkTypeZMQContext* NebulaSQLParser::sinkTypeZMQ() {
  SinkTypeZMQContext *_localctx = _tracker.createInstance<SinkTypeZMQContext>(_ctx, getState());
  enterRule(_localctx, 106, NebulaSQLParser::RuleSinkTypeZMQ);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(612);
    zmqKeyword();
    setState(613);
    match(NebulaSQLParser::T__2);
    setState(614);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqStreamName = streamName();
    setState(615);
    match(NebulaSQLParser::T__1);
    setState(616);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqHostLabel = host();
    setState(617);
    match(NebulaSQLParser::T__1);
    setState(618);
    antlrcpp::downCast<SinkTypeZMQContext *>(_localctx)->zmqPort = port();
    setState(619);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullNotnullContext ------------------------------------------------------------------

NebulaSQLParser::NullNotnullContext::NullNotnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}


size_t NebulaSQLParser::NullNotnullContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNullNotnull;
}

void NebulaSQLParser::NullNotnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullNotnull(this);
}

void NebulaSQLParser::NullNotnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullNotnull(this);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::nullNotnull() {
  NullNotnullContext *_localctx = _tracker.createInstance<NullNotnullContext>(_ctx, getState());
  enterRule(_localctx, 108, NebulaSQLParser::RuleNullNotnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(622);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::NOT) {
      setState(621);
      match(NebulaSQLParser::NOT);
    }
    setState(624);
    match(NebulaSQLParser::NULLTOKEN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ZmqKeywordContext ------------------------------------------------------------------

NebulaSQLParser::ZmqKeywordContext::ZmqKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ZmqKeywordContext::ZMQ() {
  return getToken(NebulaSQLParser::ZMQ, 0);
}


size_t NebulaSQLParser::ZmqKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleZmqKeyword;
}

void NebulaSQLParser::ZmqKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterZmqKeyword(this);
}

void NebulaSQLParser::ZmqKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitZmqKeyword(this);
}

NebulaSQLParser::ZmqKeywordContext* NebulaSQLParser::zmqKeyword() {
  ZmqKeywordContext *_localctx = _tracker.createInstance<ZmqKeywordContext>(_ctx, getState());
  enterRule(_localctx, 110, NebulaSQLParser::RuleZmqKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(626);
    match(NebulaSQLParser::ZMQ);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamNameContext ------------------------------------------------------------------

NebulaSQLParser::StreamNameContext::StreamNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::StreamNameContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::StreamNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStreamName;
}

void NebulaSQLParser::StreamNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamName(this);
}

void NebulaSQLParser::StreamNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamName(this);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::streamName() {
  StreamNameContext *_localctx = _tracker.createInstance<StreamNameContext>(_ctx, getState());
  enterRule(_localctx, 112, NebulaSQLParser::RuleStreamName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(628);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HostContext ------------------------------------------------------------------

NebulaSQLParser::HostContext::HostContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::HostContext::FOUR_OCTETS() {
  return getToken(NebulaSQLParser::FOUR_OCTETS, 0);
}

tree::TerminalNode* NebulaSQLParser::HostContext::LOCALHOST() {
  return getToken(NebulaSQLParser::LOCALHOST, 0);
}


size_t NebulaSQLParser::HostContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHost;
}

void NebulaSQLParser::HostContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHost(this);
}

void NebulaSQLParser::HostContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHost(this);
}

NebulaSQLParser::HostContext* NebulaSQLParser::host() {
  HostContext *_localctx = _tracker.createInstance<HostContext>(_ctx, getState());
  enterRule(_localctx, 114, NebulaSQLParser::RuleHost);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(630);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::LOCALHOST

    || _la == NebulaSQLParser::FOUR_OCTETS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

NebulaSQLParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::PortContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::PortContext::getRuleIndex() const {
  return NebulaSQLParser::RulePort;
}

void NebulaSQLParser::PortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPort(this);
}

void NebulaSQLParser::PortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPort(this);
}

NebulaSQLParser::PortContext* NebulaSQLParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 116, NebulaSQLParser::RulePort);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(632);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeKafkaContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeKafkaContext::SinkTypeKafkaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::KafkaKeywordContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaKeyword() {
  return getRuleContext<NebulaSQLParser::KafkaKeywordContext>(0);
}

NebulaSQLParser::KafkaBrokerContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaBroker() {
  return getRuleContext<NebulaSQLParser::KafkaBrokerContext>(0);
}

NebulaSQLParser::KafkaTopicContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaTopic() {
  return getRuleContext<NebulaSQLParser::KafkaTopicContext>(0);
}

NebulaSQLParser::KafkaProducerTimoutContext* NebulaSQLParser::SinkTypeKafkaContext::kafkaProducerTimout() {
  return getRuleContext<NebulaSQLParser::KafkaProducerTimoutContext>(0);
}


size_t NebulaSQLParser::SinkTypeKafkaContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeKafka;
}

void NebulaSQLParser::SinkTypeKafkaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeKafka(this);
}

void NebulaSQLParser::SinkTypeKafkaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeKafka(this);
}

NebulaSQLParser::SinkTypeKafkaContext* NebulaSQLParser::sinkTypeKafka() {
  SinkTypeKafkaContext *_localctx = _tracker.createInstance<SinkTypeKafkaContext>(_ctx, getState());
  enterRule(_localctx, 118, NebulaSQLParser::RuleSinkTypeKafka);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(634);
    kafkaKeyword();
    setState(635);
    match(NebulaSQLParser::T__2);
    setState(636);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->broker = kafkaBroker();
    setState(637);
    match(NebulaSQLParser::T__1);
    setState(638);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->topic = kafkaTopic();
    setState(639);
    match(NebulaSQLParser::T__1);
    setState(640);
    antlrcpp::downCast<SinkTypeKafkaContext *>(_localctx)->timeout = kafkaProducerTimout();
    setState(641);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaKeywordContext ------------------------------------------------------------------

NebulaSQLParser::KafkaKeywordContext::KafkaKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaKeywordContext::KAFKA() {
  return getToken(NebulaSQLParser::KAFKA, 0);
}


size_t NebulaSQLParser::KafkaKeywordContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaKeyword;
}

void NebulaSQLParser::KafkaKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaKeyword(this);
}

void NebulaSQLParser::KafkaKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaKeyword(this);
}

NebulaSQLParser::KafkaKeywordContext* NebulaSQLParser::kafkaKeyword() {
  KafkaKeywordContext *_localctx = _tracker.createInstance<KafkaKeywordContext>(_ctx, getState());
  enterRule(_localctx, 120, NebulaSQLParser::RuleKafkaKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    match(NebulaSQLParser::KAFKA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaBrokerContext ------------------------------------------------------------------

NebulaSQLParser::KafkaBrokerContext::KafkaBrokerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaBrokerContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::KafkaBrokerContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaBroker;
}

void NebulaSQLParser::KafkaBrokerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaBroker(this);
}

void NebulaSQLParser::KafkaBrokerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaBroker(this);
}

NebulaSQLParser::KafkaBrokerContext* NebulaSQLParser::kafkaBroker() {
  KafkaBrokerContext *_localctx = _tracker.createInstance<KafkaBrokerContext>(_ctx, getState());
  enterRule(_localctx, 122, NebulaSQLParser::RuleKafkaBroker);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(645);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaTopicContext ------------------------------------------------------------------

NebulaSQLParser::KafkaTopicContext::KafkaTopicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaTopicContext::IDENTIFIER() {
  return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::KafkaTopicContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaTopic;
}

void NebulaSQLParser::KafkaTopicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaTopic(this);
}

void NebulaSQLParser::KafkaTopicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaTopic(this);
}

NebulaSQLParser::KafkaTopicContext* NebulaSQLParser::kafkaTopic() {
  KafkaTopicContext *_localctx = _tracker.createInstance<KafkaTopicContext>(_ctx, getState());
  enterRule(_localctx, 124, NebulaSQLParser::RuleKafkaTopic);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(647);
    match(NebulaSQLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaProducerTimoutContext ------------------------------------------------------------------

NebulaSQLParser::KafkaProducerTimoutContext::KafkaProducerTimoutContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::KafkaProducerTimoutContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::KafkaProducerTimoutContext::getRuleIndex() const {
  return NebulaSQLParser::RuleKafkaProducerTimout;
}

void NebulaSQLParser::KafkaProducerTimoutContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaProducerTimout(this);
}

void NebulaSQLParser::KafkaProducerTimoutContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaProducerTimout(this);
}

NebulaSQLParser::KafkaProducerTimoutContext* NebulaSQLParser::kafkaProducerTimout() {
  KafkaProducerTimoutContext *_localctx = _tracker.createInstance<KafkaProducerTimoutContext>(_ctx, getState());
  enterRule(_localctx, 126, NebulaSQLParser::RuleKafkaProducerTimout);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(NebulaSQLParser::INTEGER_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeFileContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeFileContext::SinkTypeFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::FILE() {
  return getToken(NebulaSQLParser::FILE, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeFileContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeFileContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::SinkTypeFileContext::fileFormat() {
  return getRuleContext<NebulaSQLParser::FileFormatContext>(0);
}


size_t NebulaSQLParser::SinkTypeFileContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeFile;
}

void NebulaSQLParser::SinkTypeFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeFile(this);
}

void NebulaSQLParser::SinkTypeFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeFile(this);
}

NebulaSQLParser::SinkTypeFileContext* NebulaSQLParser::sinkTypeFile() {
  SinkTypeFileContext *_localctx = _tracker.createInstance<SinkTypeFileContext>(_ctx, getState());
  enterRule(_localctx, 128, NebulaSQLParser::RuleSinkTypeFile);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(651);
    match(NebulaSQLParser::FILE);
    setState(652);
    match(NebulaSQLParser::T__2);
    setState(653);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->path = match(NebulaSQLParser::STRING);
    setState(654);
    match(NebulaSQLParser::T__1);
    setState(655);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->format = fileFormat();
    setState(656);
    match(NebulaSQLParser::T__1);
    setState(657);
    antlrcpp::downCast<SinkTypeFileContext *>(_localctx)->append = match(NebulaSQLParser::STRING);
    setState(658);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileFormatContext ------------------------------------------------------------------

NebulaSQLParser::FileFormatContext::FileFormatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::CSV_FORMAT() {
  return getToken(NebulaSQLParser::CSV_FORMAT, 0);
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::NES_FORMAT() {
  return getToken(NebulaSQLParser::NES_FORMAT, 0);
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::TEXT_FORMAT() {
  return getToken(NebulaSQLParser::TEXT_FORMAT, 0);
}


size_t NebulaSQLParser::FileFormatContext::getRuleIndex() const {
  return NebulaSQLParser::RuleFileFormat;
}

void NebulaSQLParser::FileFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileFormat(this);
}

void NebulaSQLParser::FileFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileFormat(this);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::fileFormat() {
  FileFormatContext *_localctx = _tracker.createInstance<FileFormatContext>(_ctx, getState());
  enterRule(_localctx, 130, NebulaSQLParser::RuleFileFormat);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(660);
    _la = _input->LA(1);
    if (!(((((_la - 103) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 103)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeMQTTContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeMQTTContext::SinkTypeMQTTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::MQTT() {
  return getToken(NebulaSQLParser::MQTT, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeMQTTContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeMQTTContext::INTEGER_VALUE() {
  return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::INTEGER_VALUE(size_t i) {
  return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SinkTypeMQTTContext::timeUnit() {
  return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}

NebulaSQLParser::QosContext* NebulaSQLParser::SinkTypeMQTTContext::qos() {
  return getRuleContext<NebulaSQLParser::QosContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeMQTTContext::BOOLEAN_VALUE() {
  return getToken(NebulaSQLParser::BOOLEAN_VALUE, 0);
}


size_t NebulaSQLParser::SinkTypeMQTTContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeMQTT;
}

void NebulaSQLParser::SinkTypeMQTTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeMQTT(this);
}

void NebulaSQLParser::SinkTypeMQTTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeMQTT(this);
}

NebulaSQLParser::SinkTypeMQTTContext* NebulaSQLParser::sinkTypeMQTT() {
  SinkTypeMQTTContext *_localctx = _tracker.createInstance<SinkTypeMQTTContext>(_ctx, getState());
  enterRule(_localctx, 132, NebulaSQLParser::RuleSinkTypeMQTT);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(662);
    match(NebulaSQLParser::MQTT);
    setState(663);
    match(NebulaSQLParser::T__2);
    setState(664);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->mqttHostLabel = match(NebulaSQLParser::STRING);
    setState(665);
    match(NebulaSQLParser::T__1);
    setState(666);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->topic = match(NebulaSQLParser::STRING);
    setState(667);
    match(NebulaSQLParser::T__1);
    setState(668);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->user = match(NebulaSQLParser::STRING);
    setState(669);
    match(NebulaSQLParser::T__1);
    setState(670);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->maxBufferedMSGs = match(NebulaSQLParser::INTEGER_VALUE);
    setState(671);
    match(NebulaSQLParser::T__1);
    setState(672);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->mqttTimeUnitLabel = timeUnit();
    setState(673);
    match(NebulaSQLParser::T__1);
    setState(674);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->messageDelay = match(NebulaSQLParser::INTEGER_VALUE);
    setState(675);
    match(NebulaSQLParser::T__1);
    setState(676);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->qualityOfService = qos();
    setState(677);
    match(NebulaSQLParser::T__1);
    setState(678);
    antlrcpp::downCast<SinkTypeMQTTContext *>(_localctx)->asynchronousClient = match(NebulaSQLParser::BOOLEAN_VALUE);
    setState(679);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QosContext ------------------------------------------------------------------

NebulaSQLParser::QosContext::QosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::QosContext::AT_MOST_ONCE() {
  return getToken(NebulaSQLParser::AT_MOST_ONCE, 0);
}

tree::TerminalNode* NebulaSQLParser::QosContext::AT_LEAST_ONCE() {
  return getToken(NebulaSQLParser::AT_LEAST_ONCE, 0);
}


size_t NebulaSQLParser::QosContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQos;
}

void NebulaSQLParser::QosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQos(this);
}

void NebulaSQLParser::QosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQos(this);
}

NebulaSQLParser::QosContext* NebulaSQLParser::qos() {
  QosContext *_localctx = _tracker.createInstance<QosContext>(_ctx, getState());
  enterRule(_localctx, 134, NebulaSQLParser::RuleQos);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::AT_MOST_ONCE

    || _la == NebulaSQLParser::AT_LEAST_ONCE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypeOPCContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypeOPCContext::SinkTypeOPCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypeOPCContext::OPC() {
  return getToken(NebulaSQLParser::OPC, 0);
}

std::vector<tree::TerminalNode *> NebulaSQLParser::SinkTypeOPCContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::SinkTypeOPCContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}


size_t NebulaSQLParser::SinkTypeOPCContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypeOPC;
}

void NebulaSQLParser::SinkTypeOPCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypeOPC(this);
}

void NebulaSQLParser::SinkTypeOPCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypeOPC(this);
}

NebulaSQLParser::SinkTypeOPCContext* NebulaSQLParser::sinkTypeOPC() {
  SinkTypeOPCContext *_localctx = _tracker.createInstance<SinkTypeOPCContext>(_ctx, getState());
  enterRule(_localctx, 136, NebulaSQLParser::RuleSinkTypeOPC);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(683);
    match(NebulaSQLParser::OPC);
    setState(684);
    match(NebulaSQLParser::T__2);
    setState(685);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->url = match(NebulaSQLParser::STRING);
    setState(686);
    match(NebulaSQLParser::T__1);
    setState(687);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->nodeId = match(NebulaSQLParser::STRING);
    setState(688);
    match(NebulaSQLParser::T__1);
    setState(689);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->user = match(NebulaSQLParser::STRING);
    setState(690);
    match(NebulaSQLParser::T__1);
    setState(691);
    antlrcpp::downCast<SinkTypeOPCContext *>(_localctx)->password = match(NebulaSQLParser::STRING);
    setState(692);
    match(NebulaSQLParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinkTypePrintContext ------------------------------------------------------------------

NebulaSQLParser::SinkTypePrintContext::SinkTypePrintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::SinkTypePrintContext::PRINT() {
  return getToken(NebulaSQLParser::PRINT, 0);
}


size_t NebulaSQLParser::SinkTypePrintContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSinkTypePrint;
}

void NebulaSQLParser::SinkTypePrintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSinkTypePrint(this);
}

void NebulaSQLParser::SinkTypePrintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSinkTypePrint(this);
}

NebulaSQLParser::SinkTypePrintContext* NebulaSQLParser::sinkTypePrint() {
  SinkTypePrintContext *_localctx = _tracker.createInstance<SinkTypePrintContext>(_ctx, getState());
  enterRule(_localctx, 138, NebulaSQLParser::RuleSinkTypePrint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(694);
    match(NebulaSQLParser::PRINT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

NebulaSQLParser::SortItemContext::SortItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::SortItemContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}


size_t NebulaSQLParser::SortItemContext::getRuleIndex() const {
  return NebulaSQLParser::RuleSortItem;
}

void NebulaSQLParser::SortItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortItem(this);
}

void NebulaSQLParser::SortItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortItem(this);
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::sortItem() {
  SortItemContext *_localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
  enterRule(_localctx, 140, NebulaSQLParser::RuleSortItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(696);
    expression();
    setState(698);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::ASC

    || _la == NebulaSQLParser::DESC) {
      setState(697);
      antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::ASC

      || _la == NebulaSQLParser::DESC)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(702);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NebulaSQLParser::NULLS) {
      setState(700);
      match(NebulaSQLParser::NULLS);
      setState(701);
      antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::FIRST

      || _la == NebulaSQLParser::LAST)) {
        antlrcpp::downCast<SortItemContext *>(_localctx)->nullOrder = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

NebulaSQLParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::PredicateContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicateContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::PredicateContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::PredicateContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IN() {
  return getToken(NebulaSQLParser::IN, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::PredicateContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ANY() {
  return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::SOME() {
  return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ESCAPE() {
  return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IS() {
  return getToken(NebulaSQLParser::IS, 0);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::PredicateContext::nullNotnull() {
  return getRuleContext<NebulaSQLParser::NullNotnullContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::UNKNOWN() {
  return getToken(NebulaSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::DISTINCT() {
  return getToken(NebulaSQLParser::DISTINCT, 0);
}


size_t NebulaSQLParser::PredicateContext::getRuleIndex() const {
  return NebulaSQLParser::RulePredicate;
}

void NebulaSQLParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void NebulaSQLParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 142, NebulaSQLParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(783);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(705);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(704);
        match(NebulaSQLParser::NOT);
      }
      setState(707);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::BETWEEN);
      setState(708);
      antlrcpp::downCast<PredicateContext *>(_localctx)->lower = valueExpression(0);
      setState(709);
      match(NebulaSQLParser::AND);
      setState(710);
      antlrcpp::downCast<PredicateContext *>(_localctx)->upper = valueExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(713);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(712);
        match(NebulaSQLParser::NOT);
      }
      setState(715);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::IN);
      setState(716);
      match(NebulaSQLParser::T__2);
      setState(717);
      expression();
      setState(722);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(718);
        match(NebulaSQLParser::T__1);
        setState(719);
        expression();
        setState(724);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(725);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(728);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(727);
        match(NebulaSQLParser::NOT);
      }
      setState(730);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::IN);
      setState(731);
      match(NebulaSQLParser::T__2);
      setState(732);
      query();
      setState(733);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(735);
        match(NebulaSQLParser::NOT);
      }
      setState(738);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::RLIKE);
      setState(739);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(741);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(740);
        match(NebulaSQLParser::NOT);
      }
      setState(743);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::LIKE);
      setState(744);
      antlrcpp::downCast<PredicateContext *>(_localctx)->quantifier = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 9) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 9)) & 36028797018963973) != 0))) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->quantifier = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(758);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
      case 1: {
        setState(745);
        match(NebulaSQLParser::T__2);
        setState(746);
        match(NebulaSQLParser::T__3);
        break;
      }

      case 2: {
        setState(747);
        match(NebulaSQLParser::T__2);
        setState(748);
        expression();
        setState(753);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(749);
          match(NebulaSQLParser::T__1);
          setState(750);
          expression();
          setState(755);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(756);
        match(NebulaSQLParser::T__3);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(761);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(760);
        match(NebulaSQLParser::NOT);
      }
      setState(763);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::LIKE);
      setState(764);
      antlrcpp::downCast<PredicateContext *>(_localctx)->pattern = valueExpression(0);
      setState(767);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
      case 1: {
        setState(765);
        match(NebulaSQLParser::ESCAPE);
        setState(766);
        antlrcpp::downCast<PredicateContext *>(_localctx)->escapeChar = match(NebulaSQLParser::STRING);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(769);
      match(NebulaSQLParser::IS);
      setState(770);
      nullNotnull();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(771);
      match(NebulaSQLParser::IS);
      setState(773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(772);
        match(NebulaSQLParser::NOT);
      }
      setState(775);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 28) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 28)) & 9895604649985) != 0))) {
        antlrcpp::downCast<PredicateContext *>(_localctx)->kind = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(776);
      match(NebulaSQLParser::IS);
      setState(778);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::NOT) {
        setState(777);
        match(NebulaSQLParser::NOT);
      }
      setState(780);
      antlrcpp::downCast<PredicateContext *>(_localctx)->kind = match(NebulaSQLParser::DISTINCT);
      setState(781);
      match(NebulaSQLParser::FROM);
      setState(782);
      antlrcpp::downCast<PredicateContext *>(_localctx)->right = valueExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext::ValueExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ValueExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RuleValueExpression;
}

void NebulaSQLParser::ValueExpressionContext::copyFrom(ValueExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ValueExpressionDefaultContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::ValueExpressionDefaultContext::primaryExpression() {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::ValueExpressionDefaultContext::ValueExpressionDefaultContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ValueExpressionDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueExpressionDefault(this);
}
void NebulaSQLParser::ValueExpressionDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueExpressionDefault(this);
}
//----------------- ComparisonContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::ComparisonContext::comparisonOperator() {
  return getRuleContext<NebulaSQLParser::ComparisonOperatorContext>(0);
}

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::ComparisonContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ComparisonContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

NebulaSQLParser::ComparisonContext::ComparisonContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}
void NebulaSQLParser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}
//----------------- ArithmeticBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::ValueExpressionContext *> NebulaSQLParser::ArithmeticBinaryContext::valueExpression() {
  return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticBinaryContext::valueExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::ASTERISK() {
  return getToken(NebulaSQLParser::ASTERISK, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::SLASH() {
  return getToken(NebulaSQLParser::SLASH, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PERCENT() {
  return getToken(NebulaSQLParser::PERCENT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PLUS() {
  return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::CONCAT_PIPE() {
  return getToken(NebulaSQLParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::AMPERSAND() {
  return getToken(NebulaSQLParser::AMPERSAND, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::HAT() {
  return getToken(NebulaSQLParser::HAT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PIPE() {
  return getToken(NebulaSQLParser::PIPE, 0);
}

NebulaSQLParser::ArithmeticBinaryContext::ArithmeticBinaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ArithmeticBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticBinary(this);
}
void NebulaSQLParser::ArithmeticBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticBinary(this);
}
//----------------- ArithmeticUnaryContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticUnaryContext::valueExpression() {
  return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::PLUS() {
  return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::TILDE() {
  return getToken(NebulaSQLParser::TILDE, 0);
}

NebulaSQLParser::ArithmeticUnaryContext::ArithmeticUnaryContext(ValueExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ArithmeticUnaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArithmeticUnary(this);
}
void NebulaSQLParser::ArithmeticUnaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArithmeticUnary(this);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression() {
   return valueExpression(0);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::ValueExpressionContext *_localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
  NebulaSQLParser::ValueExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 144;
  enterRecursionRule(_localctx, 144, NebulaSQLParser::RuleValueExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(789);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ValueExpressionDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(786);
      primaryExpression(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ArithmeticUnaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(787);
      antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 117) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 117)) & 35) != 0))) {
        antlrcpp::downCast<ArithmeticUnaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(788);
      valueExpression(7);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(812);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(810);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(791);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(792);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == NebulaSQLParser::DIV || ((((_la - 119) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 119)) & 7) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(793);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(7);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(794);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(795);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(((((_la - 117) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 117)) & 259) != 0))) {
            antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(796);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(6);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(797);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(798);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::AMPERSAND);
          setState(799);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(5);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(800);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(801);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::HAT);
          setState(802);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(4);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(803);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(804);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->op = match(NebulaSQLParser::PIPE);
          setState(805);
          antlrcpp::downCast<ArithmeticBinaryContext *>(_localctx)->right = valueExpression(3);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<ComparisonContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleValueExpression);
          setState(806);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(807);
          comparisonOperator();
          setState(808);
          antlrcpp::downCast<ComparisonContext *>(_localctx)->right = valueExpression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(814);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::EQ() {
  return getToken(NebulaSQLParser::EQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQ() {
  return getToken(NebulaSQLParser::NEQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQJ() {
  return getToken(NebulaSQLParser::NEQJ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LT() {
  return getToken(NebulaSQLParser::LT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LTE() {
  return getToken(NebulaSQLParser::LTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GT() {
  return getToken(NebulaSQLParser::GT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GTE() {
  return getToken(NebulaSQLParser::GTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NSEQ() {
  return getToken(NebulaSQLParser::NSEQ, 0);
}


size_t NebulaSQLParser::ComparisonOperatorContext::getRuleIndex() const {
  return NebulaSQLParser::RuleComparisonOperator;
}

void NebulaSQLParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void NebulaSQLParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 146, NebulaSQLParser::RuleComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(815);
    _la = _input->LA(1);
    if (!(((((_la - 109) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 109)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HintContext ------------------------------------------------------------------

NebulaSQLParser::HintContext::HintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::HintStatementContext *> NebulaSQLParser::HintContext::hintStatement() {
  return getRuleContexts<NebulaSQLParser::HintStatementContext>();
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::HintContext::hintStatement(size_t i) {
  return getRuleContext<NebulaSQLParser::HintStatementContext>(i);
}


size_t NebulaSQLParser::HintContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHint;
}

void NebulaSQLParser::HintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHint(this);
}

void NebulaSQLParser::HintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHint(this);
}

NebulaSQLParser::HintContext* NebulaSQLParser::hint() {
  HintContext *_localctx = _tracker.createInstance<HintContext>(_ctx, getState());
  enterRule(_localctx, 148, NebulaSQLParser::RuleHint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(817);
    match(NebulaSQLParser::T__5);
    setState(818);
    antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext = hintStatement();
    antlrcpp::downCast<HintContext *>(_localctx)->hintStatements.push_back(antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext);
    setState(825);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(820);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
        case 1: {
          setState(819);
          match(NebulaSQLParser::T__1);
          break;
        }

        default:
          break;
        }
        setState(822);
        antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext = hintStatement();
        antlrcpp::downCast<HintContext *>(_localctx)->hintStatements.push_back(antlrcpp::downCast<HintContext *>(_localctx)->hintStatementContext); 
      }
      setState(827);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    }
    setState(828);
    match(NebulaSQLParser::T__6);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HintStatementContext ------------------------------------------------------------------

NebulaSQLParser::HintStatementContext::HintStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::HintStatementContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

std::vector<NebulaSQLParser::PrimaryExpressionContext *> NebulaSQLParser::HintStatementContext::primaryExpression() {
  return getRuleContexts<NebulaSQLParser::PrimaryExpressionContext>();
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::HintStatementContext::primaryExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(i);
}


size_t NebulaSQLParser::HintStatementContext::getRuleIndex() const {
  return NebulaSQLParser::RuleHintStatement;
}

void NebulaSQLParser::HintStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHintStatement(this);
}

void NebulaSQLParser::HintStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHintStatement(this);
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::hintStatement() {
  HintStatementContext *_localctx = _tracker.createInstance<HintStatementContext>(_ctx, getState());
  enterRule(_localctx, 150, NebulaSQLParser::RuleHintStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(843);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(830);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->hintName = identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(831);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->hintName = identifier();
      setState(832);
      match(NebulaSQLParser::T__2);
      setState(833);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext = primaryExpression(0);
      antlrcpp::downCast<HintStatementContext *>(_localctx)->parameters.push_back(antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext);
      setState(838);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == NebulaSQLParser::T__1) {
        setState(834);
        match(NebulaSQLParser::T__1);
        setState(835);
        antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext = primaryExpression(0);
        antlrcpp::downCast<HintStatementContext *>(_localctx)->parameters.push_back(antlrcpp::downCast<HintStatementContext *>(_localctx)->primaryExpressionContext);
        setState(840);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(841);
      match(NebulaSQLParser::T__3);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::PrimaryExpressionContext::getRuleIndex() const {
  return NebulaSQLParser::RulePrimaryExpression;
}

void NebulaSQLParser::PrimaryExpressionContext::copyFrom(PrimaryExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DereferenceContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::DereferenceContext::primaryExpression() {
  return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::DereferenceContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::DereferenceContext::DereferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DereferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDereference(this);
}
void NebulaSQLParser::DereferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDereference(this);
}
//----------------- ConstantDefaultContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext* NebulaSQLParser::ConstantDefaultContext::constant() {
  return getRuleContext<NebulaSQLParser::ConstantContext>(0);
}

NebulaSQLParser::ConstantDefaultContext::ConstantDefaultContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ConstantDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantDefault(this);
}
void NebulaSQLParser::ConstantDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantDefault(this);
}
//----------------- ColumnReferenceContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ColumnReferenceContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ColumnReferenceContext::ColumnReferenceContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ColumnReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnReference(this);
}
void NebulaSQLParser::ColumnReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnReference(this);
}
//----------------- RowConstructorContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::NamedExpressionContext *> NebulaSQLParser::RowConstructorContext::namedExpression() {
  return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::RowConstructorContext::namedExpression(size_t i) {
  return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}

NebulaSQLParser::RowConstructorContext::RowConstructorContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::RowConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowConstructor(this);
}
void NebulaSQLParser::RowConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowConstructor(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ParenthesizedExpressionContext::expression() {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}
void NebulaSQLParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}
//----------------- StarContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::StarContext::ASTERISK() {
  return getToken(NebulaSQLParser::ASTERISK, 0);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::StarContext::qualifiedName() {
  return getRuleContext<NebulaSQLParser::QualifiedNameContext>(0);
}

NebulaSQLParser::StarContext::StarContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::StarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar(this);
}
void NebulaSQLParser::StarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::FunctionCallContext::functionName() {
  return getRuleContext<NebulaSQLParser::FunctionNameContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext *> NebulaSQLParser::FunctionCallContext::expression() {
  return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionCallContext::expression(size_t i) {
  return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::FunctionCallContext::FunctionCallContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}
void NebulaSQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}
//----------------- SubqueryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryExpressionContext::query() {
  return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryExpressionContext::SubqueryExpressionContext(PrimaryExpressionContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SubqueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubqueryExpression(this);
}
void NebulaSQLParser::SubqueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubqueryExpression(this);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression() {
   return primaryExpression(0);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NebulaSQLParser::PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
  NebulaSQLParser::PrimaryExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 152;
  enterRecursionRule(_localctx, 152, NebulaSQLParser::RulePrimaryExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(885);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(846);
      match(NebulaSQLParser::ASTERISK);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<StarContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(847);
      qualifiedName();
      setState(848);
      match(NebulaSQLParser::T__4);
      setState(849);
      match(NebulaSQLParser::ASTERISK);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SubqueryExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(851);
      match(NebulaSQLParser::T__2);
      setState(852);
      query();
      setState(853);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<RowConstructorContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(855);
      match(NebulaSQLParser::T__2);
      setState(856);
      namedExpression();
      setState(859); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(857);
        match(NebulaSQLParser::T__1);
        setState(858);
        namedExpression();
        setState(861); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == NebulaSQLParser::T__1);
      setState(863);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(865);
      functionName();
      setState(866);
      match(NebulaSQLParser::T__2);
      setState(875);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
      case 1: {
        setState(867);
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
        antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
        setState(872);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1) {
          setState(868);
          match(NebulaSQLParser::T__1);
          setState(869);
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext = expression();
          antlrcpp::downCast<FunctionCallContext *>(_localctx)->argument.push_back(antlrcpp::downCast<FunctionCallContext *>(_localctx)->expressionContext);
          setState(874);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(877);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(879);
      match(NebulaSQLParser::T__2);
      setState(880);
      expression();
      setState(881);
      match(NebulaSQLParser::T__3);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<ConstantDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(883);
      constant();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<ColumnReferenceContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(884);
      identifier();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(892);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<DereferenceContext>(_tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->base = previousContext;
        pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
        setState(887);

        if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
        setState(888);
        match(NebulaSQLParser::T__4);
        setState(889);
        antlrcpp::downCast<DereferenceContext *>(_localctx)->fieldName = identifier(); 
      }
      setState(894);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

NebulaSQLParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NebulaSQLParser::IdentifierContext *> NebulaSQLParser::QualifiedNameContext::identifier() {
  return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::QualifiedNameContext::identifier(size_t i) {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}


size_t NebulaSQLParser::QualifiedNameContext::getRuleIndex() const {
  return NebulaSQLParser::RuleQualifiedName;
}

void NebulaSQLParser::QualifiedNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedName(this);
}

void NebulaSQLParser::QualifiedNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedName(this);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::qualifiedName() {
  QualifiedNameContext *_localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
  enterRule(_localctx, 154, NebulaSQLParser::RuleQualifiedName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(895);
    identifier();
    setState(900);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(896);
        match(NebulaSQLParser::T__4);
        setState(897);
        identifier(); 
      }
      setState(902);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::NumberContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNumber;
}

void NebulaSQLParser::NumberContext::copyFrom(NumberContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DecimalLiteralContext::DecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecimalLiteral(this);
}
void NebulaSQLParser::DecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecimalLiteral(this);
}
//----------------- BigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::BIGINT_LITERAL() {
  return getToken(NebulaSQLParser::BIGINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigIntLiteralContext::BigIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BigIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigIntLiteral(this);
}
void NebulaSQLParser::BigIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigIntLiteral(this);
}
//----------------- TinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::TINYINT_LITERAL() {
  return getToken(NebulaSQLParser::TINYINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::TinyIntLiteralContext::TinyIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TinyIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTinyIntLiteral(this);
}
void NebulaSQLParser::TinyIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTinyIntLiteral(this);
}
//----------------- LegacyDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::EXPONENT_VALUE() {
  return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::DECIMAL_VALUE() {
  return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::LegacyDecimalLiteralContext::LegacyDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::LegacyDecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLegacyDecimalLiteral(this);
}
void NebulaSQLParser::LegacyDecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLegacyDecimalLiteral(this);
}
//----------------- BigDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::BIGDECIMAL_LITERAL() {
  return getToken(NebulaSQLParser::BIGDECIMAL_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigDecimalLiteralContext::BigDecimalLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BigDecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBigDecimalLiteral(this);
}
void NebulaSQLParser::BigDecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBigDecimalLiteral(this);
}
//----------------- ExponentLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::EXPONENT_VALUE() {
  return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::ExponentLiteralContext::ExponentLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::ExponentLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExponentLiteral(this);
}
void NebulaSQLParser::ExponentLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExponentLiteral(this);
}
//----------------- DoubleLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::DOUBLE_LITERAL() {
  return getToken(NebulaSQLParser::DOUBLE_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DoubleLiteralContext::DoubleLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::DoubleLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoubleLiteral(this);
}
void NebulaSQLParser::DoubleLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoubleLiteral(this);
}
//----------------- IntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::INTEGER_VALUE() {
  return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::IntegerLiteralContext::IntegerLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::IntegerLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerLiteral(this);
}
void NebulaSQLParser::IntegerLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerLiteral(this);
}
//----------------- FloatLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::FLOAT_LITERAL() {
  return getToken(NebulaSQLParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::FloatLiteralContext::FloatLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::FloatLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloatLiteral(this);
}
void NebulaSQLParser::FloatLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloatLiteral(this);
}
//----------------- SmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::SMALLINT_LITERAL() {
  return getToken(NebulaSQLParser::SMALLINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::MINUS() {
  return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::SmallIntLiteralContext::SmallIntLiteralContext(NumberContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::SmallIntLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSmallIntLiteral(this);
}
void NebulaSQLParser::SmallIntLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSmallIntLiteral(this);
}
NebulaSQLParser::NumberContext* NebulaSQLParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 156, NebulaSQLParser::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(946);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::ExponentLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(903);

      if (!(!legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
      setState(905);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(904);
        match(NebulaSQLParser::MINUS);
      }
      setState(907);
      match(NebulaSQLParser::EXPONENT_VALUE);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::DecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(908);

      if (!(!legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
      setState(910);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(909);
        match(NebulaSQLParser::MINUS);
      }
      setState(912);
      match(NebulaSQLParser::DECIMAL_VALUE);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::LegacyDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(913);

      if (!(legacy_exponent_literal_as_decimal_enabled)) throw FailedPredicateException(this, "legacy_exponent_literal_as_decimal_enabled");
      setState(915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(914);
        match(NebulaSQLParser::MINUS);
      }
      setState(917);
      _la = _input->LA(1);
      if (!(_la == NebulaSQLParser::EXPONENT_VALUE

      || _la == NebulaSQLParser::DECIMAL_VALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::IntegerLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(919);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(918);
        match(NebulaSQLParser::MINUS);
      }
      setState(921);
      match(NebulaSQLParser::INTEGER_VALUE);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BigIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(922);
        match(NebulaSQLParser::MINUS);
      }
      setState(925);
      match(NebulaSQLParser::BIGINT_LITERAL);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<NebulaSQLParser::SmallIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(927);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(926);
        match(NebulaSQLParser::MINUS);
      }
      setState(929);
      match(NebulaSQLParser::SMALLINT_LITERAL);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TinyIntLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(931);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(930);
        match(NebulaSQLParser::MINUS);
      }
      setState(933);
      match(NebulaSQLParser::TINYINT_LITERAL);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<NebulaSQLParser::DoubleLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(935);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(934);
        match(NebulaSQLParser::MINUS);
      }
      setState(937);
      match(NebulaSQLParser::DOUBLE_LITERAL);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<NebulaSQLParser::FloatLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(939);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(938);
        match(NebulaSQLParser::MINUS);
      }
      setState(941);
      match(NebulaSQLParser::FLOAT_LITERAL);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BigDecimalLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(943);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NebulaSQLParser::MINUS) {
        setState(942);
        match(NebulaSQLParser::MINUS);
      }
      setState(945);
      match(NebulaSQLParser::BIGDECIMAL_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t NebulaSQLParser::ConstantContext::getRuleIndex() const {
  return NebulaSQLParser::RuleConstant;
}

void NebulaSQLParser::ConstantContext::copyFrom(ConstantContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- NullLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::NullLiteralContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

NebulaSQLParser::NullLiteralContext::NullLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullLiteral(this);
}
void NebulaSQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullLiteral(this);
}
//----------------- StringLiteralContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> NebulaSQLParser::StringLiteralContext::STRING() {
  return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::StringLiteralContext::STRING(size_t i) {
  return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::StringLiteralContext::StringLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}
void NebulaSQLParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}
//----------------- TypeConstructorContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::TypeConstructorContext::identifier() {
  return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TypeConstructorContext::STRING() {
  return getToken(NebulaSQLParser::STRING, 0);
}

NebulaSQLParser::TypeConstructorContext::TypeConstructorContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::TypeConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeConstructor(this);
}
void NebulaSQLParser::TypeConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeConstructor(this);
}
//----------------- NumericLiteralContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext* NebulaSQLParser::NumericLiteralContext::number() {
  return getRuleContext<NebulaSQLParser::NumberContext>(0);
}

NebulaSQLParser::NumericLiteralContext::NumericLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}
void NebulaSQLParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}
//----------------- BooleanLiteralContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::BooleanLiteralContext::booleanValue() {
  return getRuleContext<NebulaSQLParser::BooleanValueContext>(0);
}

NebulaSQLParser::BooleanLiteralContext::BooleanLiteralContext(ConstantContext *ctx) { copyFrom(ctx); }

void NebulaSQLParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}
void NebulaSQLParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}
NebulaSQLParser::ConstantContext* NebulaSQLParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 158, NebulaSQLParser::RuleConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(959);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NebulaSQLParser::NullLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(948);
      match(NebulaSQLParser::NULLTOKEN);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<NebulaSQLParser::TypeConstructorContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(949);
      identifier();
      setState(950);
      match(NebulaSQLParser::STRING);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<NebulaSQLParser::NumericLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(952);
      number();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<NebulaSQLParser::BooleanLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(953);
      booleanValue();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<NebulaSQLParser::StringLiteralContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(955); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(954);
                match(NebulaSQLParser::STRING);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(957); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext::BooleanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}


size_t NebulaSQLParser::BooleanValueContext::getRuleIndex() const {
  return NebulaSQLParser::RuleBooleanValue;
}

void NebulaSQLParser::BooleanValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanValue(this);
}

void NebulaSQLParser::BooleanValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanValue(this);
}

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::booleanValue() {
  BooleanValueContext *_localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
  enterRule(_localctx, 160, NebulaSQLParser::RuleBooleanValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(961);
    _la = _input->LA(1);
    if (!(_la == NebulaSQLParser::FALSE

    || _la == NebulaSQLParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrictNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::StrictNonReservedContext::StrictNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::FULL() {
  return getToken(NebulaSQLParser::FULL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::INNER() {
  return getToken(NebulaSQLParser::INNER, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::JOIN() {
  return getToken(NebulaSQLParser::JOIN, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::LEFT() {
  return getToken(NebulaSQLParser::LEFT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::NATURAL() {
  return getToken(NebulaSQLParser::NATURAL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::ON() {
  return getToken(NebulaSQLParser::ON, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::RIGHT() {
  return getToken(NebulaSQLParser::RIGHT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::UNION() {
  return getToken(NebulaSQLParser::UNION, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::USING() {
  return getToken(NebulaSQLParser::USING, 0);
}


size_t NebulaSQLParser::StrictNonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleStrictNonReserved;
}

void NebulaSQLParser::StrictNonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrictNonReserved(this);
}

void NebulaSQLParser::StrictNonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrictNonReserved(this);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::strictNonReserved() {
  StrictNonReservedContext *_localctx = _tracker.createInstance<StrictNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 162, NebulaSQLParser::RuleStrictNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(963);
    _la = _input->LA(1);
    if (!(((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 2474039710785) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnsiNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::AnsiNonReservedContext::AnsiNonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::AT() {
  return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DELETE() {
  return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DROP() {
  return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::INSERT() {
  return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::MERGE() {
  return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::QUERY() {
  return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TYPE() {
  return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}


size_t NebulaSQLParser::AnsiNonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleAnsiNonReserved;
}

void NebulaSQLParser::AnsiNonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnsiNonReserved(this);
}

void NebulaSQLParser::AnsiNonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnsiNonReserved(this);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::ansiNonReserved() {
  AnsiNonReservedContext *_localctx = _tracker.createInstance<AnsiNonReservedContext>(_ctx, getState());
  enterRule(_localctx, 164, NebulaSQLParser::RuleAnsiNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(965);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5615592343523696640) != 0) || ((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 579) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonReservedContext ------------------------------------------------------------------

NebulaSQLParser::NonReservedContext::NonReservedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ASC() {
  return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AT() {
  return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BETWEEN() {
  return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::CUBE() {
  return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BY() {
  return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DELETE() {
  return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DESC() {
  return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DIV() {
  return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DROP() {
  return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::EXISTS() {
  return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FIRST() {
  return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUPING() {
  return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INSERT() {
  return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LAST() {
  return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIKE() {
  return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIMIT() {
  return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::MERGE() {
  return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLS() {
  return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::QUERY() {
  return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::RLIKE() {
  return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ROLLUP() {
  return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SETS() {
  return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TRUE() {
  return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TYPE() {
  return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::VALUES() {
  return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WINDOW() {
  return getToken(NebulaSQLParser::WINDOW, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ALL() {
  return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AND() {
  return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ANY() {
  return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AS() {
  return getToken(NebulaSQLParser::AS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DISTINCT() {
  return getToken(NebulaSQLParser::DISTINCT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ESCAPE() {
  return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FALSE() {
  return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FROM() {
  return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUP() {
  return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::HAVING() {
  return getToken(NebulaSQLParser::HAVING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IN() {
  return getToken(NebulaSQLParser::IN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INTO() {
  return getToken(NebulaSQLParser::INTO, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IS() {
  return getToken(NebulaSQLParser::IS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NOT() {
  return getToken(NebulaSQLParser::NOT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLTOKEN() {
  return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::OR() {
  return getToken(NebulaSQLParser::OR, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ORDER() {
  return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SELECT() {
  return getToken(NebulaSQLParser::SELECT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SOME() {
  return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TABLE() {
  return getToken(NebulaSQLParser::TABLE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WHERE() {
  return getToken(NebulaSQLParser::WHERE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WITH() {
  return getToken(NebulaSQLParser::WITH, 0);
}


size_t NebulaSQLParser::NonReservedContext::getRuleIndex() const {
  return NebulaSQLParser::RuleNonReserved;
}

void NebulaSQLParser::NonReservedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonReserved(this);
}

void NebulaSQLParser::NonReservedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NebulaSQLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonReserved(this);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::nonReserved() {
  NonReservedContext *_localctx = _tracker.createInstance<NonReservedContext>(_ctx, getState());
  enterRule(_localctx, 166, NebulaSQLParser::RuleNonReserved);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(967);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -892438752910246400) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 29749) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool NebulaSQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return queryTermSempred(antlrcpp::downCast<QueryTermContext *>(context), predicateIndex);
    case 24: return identifierSempred(antlrcpp::downCast<IdentifierContext *>(context), predicateIndex);
    case 25: return strictIdentifierSempred(antlrcpp::downCast<StrictIdentifierContext *>(context), predicateIndex);
    case 33: return booleanExpressionSempred(antlrcpp::downCast<BooleanExpressionContext *>(context), predicateIndex);
    case 72: return valueExpressionSempred(antlrcpp::downCast<ValueExpressionContext *>(context), predicateIndex);
    case 76: return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext *>(context), predicateIndex);
    case 78: return numberSempred(antlrcpp::downCast<NumberContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::queryTermSempred(QueryTermContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::identifierSempred(IdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return !SQL_standard_keyword_behavior;

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::strictIdentifierSempred(StrictIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return SQL_standard_keyword_behavior;
    case 3: return !SQL_standard_keyword_behavior;

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::booleanExpressionSempred(BooleanExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::valueExpressionSempred(ValueExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 6);
    case 7: return precpred(_ctx, 5);
    case 8: return precpred(_ctx, 4);
    case 9: return precpred(_ctx, 3);
    case 10: return precpred(_ctx, 2);
    case 11: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::primaryExpressionSempred(PrimaryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

bool NebulaSQLParser::numberSempred(NumberContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return !legacy_exponent_literal_as_decimal_enabled;
    case 14: return !legacy_exponent_literal_as_decimal_enabled;
    case 15: return legacy_exponent_literal_as_decimal_enabled;

  default:
    break;
  }
  return true;
}

void NebulaSQLParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  nebulasqlParserInitialize();
#else
  ::antlr4::internal::call_once(nebulasqlParserOnceFlag, nebulasqlParserInitialize);
#endif
}
