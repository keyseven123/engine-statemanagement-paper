From 1475f1928be379a478d7056209cd0b6fb8775ac8 Mon Sep 17 00:00:00 2001
From: Philipp Grulich <philippgrulich@hotmail.de>
Date: Fri, 27 Jun 2025 11:58:23 +0200
Subject: [PATCH 1/3] bug(valPtr): can't dereference a nested pointer

It is currently not possible to dereference a nautilus val that wraps a nested pointer, e.g., `nautilus::val<char**>`. The dereference operator in `val_ptr.hpp` assumes an underlying value that it can return a value to.
It seems to be tricky to add a dereference value that returns a nautilus value of a pointer, since the pointer to the pointer will be a nullptr at trace time. Dereferencing the nullptr leads to a crash.
---
 nautilus/test/execution-tests/ExecutionTest.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/nautilus/test/execution-tests/ExecutionTest.cpp b/nautilus/test/execution-tests/ExecutionTest.cpp
index 1434dbaa..0cbeb12c 100644
--- a/nautilus/test/execution-tests/ExecutionTest.cpp
+++ b/nautilus/test/execution-tests/ExecutionTest.cpp
@@ -947,6 +947,16 @@ void registerFunctionTest(engine::NautilusEngine& engine) {
 		REQUIRE(f(&val) == 42);
 	}

+	SECTION("pureFunctionWithPtr") {
+		auto f = engine.registerFunction(std::function([](val<int8_t**> arg) -> val<int8_t> {
+			return *(*arg);
+		}));
+		int8_t val = 42;
+		int8_t* valPtr = &val;
+		int8_t** valPtrToPtr = &valPtr;
+		REQUIRE(f(valPtrToPtr) == 42);
+	}
+
 	SECTION("pureVoidFunctionWithPtr") {
 		auto f = engine.registerFunction(std::function([](val<int8_t*> arg) -> void { *arg = 42; }));
 		int8_t val = 1;

From aa05e0979065cbf1deb71074f670ccb7bb9440c6 Mon Sep 17 00:00:00 2001
From: Philipp Grulich <philippgrulich@hotmail.de>
Date: Mon, 30 Jun 2025 08:12:31 +0200
Subject: [PATCH 2/3] fix ptr dref

---
 nautilus/include/nautilus/val_concepts.hpp      |  8 ++++++++
 nautilus/include/nautilus/val_ptr.hpp           | 12 +++++++++++-
 nautilus/test/execution-tests/ExecutionTest.cpp |  8 +++++---
 3 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/nautilus/include/nautilus/val_concepts.hpp b/nautilus/include/nautilus/val_concepts.hpp
index c4195715..dd61d8a5 100644
--- a/nautilus/include/nautilus/val_concepts.hpp
+++ b/nautilus/include/nautilus/val_concepts.hpp
@@ -48,9 +48,17 @@ concept is_ptr = std::is_pointer_v<T>;
 template <typename T>
 concept is_arithmetic_ptr = is_ptr<T> && std::is_arithmetic_v<std::remove_pointer_t<T>>;

+
+template <typename T>
+concept is_ptr_ref = is_ptr<std::remove_reference_t<T>> && std::is_reference_v<T>;
+
+
 template <typename T>
 concept is_arithmetic_ref = std::is_arithmetic_v<std::remove_reference_t<T>> && std::is_reference_v<T>;

+template <typename T>
+concept is_nautilus_ref = is_ptr_ref<T> || is_arithmetic_ref<T>;
+
 template <typename T>
 concept is_void_ptr = is_ptr<T> && std::is_void_v<std::remove_pointer_t<T>>;

diff --git a/nautilus/include/nautilus/val_ptr.hpp b/nautilus/include/nautilus/val_ptr.hpp
index 2610c09e..fa0e3372 100644
--- a/nautilus/include/nautilus/val_ptr.hpp
+++ b/nautilus/include/nautilus/val_ptr.hpp
@@ -6,7 +6,7 @@

 namespace nautilus {

-template <is_arithmetic_ref ValueType>
+template <is_nautilus_ref ValueType>
 class val<ValueType> {
 public:
 	using baseType = std::remove_cvref_t<ValueType>;
@@ -149,6 +149,16 @@ class val<ValuePtrType> : public base_ptr_val<ValuePtrType> {
 #endif
 	}

+	val<ValType&> operator*()
+	    requires is_ptr<ValType>
+	{
+#ifdef ENABLE_TRACING
+		return val<ValType&>(*this, this->state);
+#else
+		return val<ValType&>(*this);
+#endif
+	}
+
 	template <class T>
 	val<ValType&> operator[](T&& io)
 	    requires is_arithmetic<ValType>
diff --git a/nautilus/test/execution-tests/ExecutionTest.cpp b/nautilus/test/execution-tests/ExecutionTest.cpp
index 0cbeb12c..ce826d14 100644
--- a/nautilus/test/execution-tests/ExecutionTest.cpp
+++ b/nautilus/test/execution-tests/ExecutionTest.cpp
@@ -942,14 +942,16 @@ void registerFunctionTest(engine::NautilusEngine& engine) {
 	}

 	SECTION("pureFunctionWithPtr") {
-		auto f = engine.registerFunction(std::function([](val<int8_t*> arg) -> val<int8_t> { return *arg; }));
+		auto f = engine.registerFunction(std::function([](val<int8_t*> arg) -> val<int8_t> {
+			return *arg; }));
 		int8_t val = 42;
 		REQUIRE(f(&val) == 42);
 	}

-	SECTION("pureFunctionWithPtr") {
+	SECTION("pureFunctionWithPtr2") {
 		auto f = engine.registerFunction(std::function([](val<int8_t**> arg) -> val<int8_t> {
-			return *(*arg);
+			 val<int8_t*> deref1 = *arg;
+			 return *deref1;
 		}));
 		int8_t val = 42;
 		int8_t* valPtr = &val;

From 7a931ece0f913ad9feb43bb5ea3e9907613be0cf Mon Sep 17 00:00:00 2001
From: Philipp Grulich <philippgrulich@hotmail.de>
Date: Mon, 30 Jun 2025 08:17:06 +0200
Subject: [PATCH 3/3] fix ptr dref

---
 nautilus/include/nautilus/val_ptr.hpp | 12 +-----------
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/nautilus/include/nautilus/val_ptr.hpp b/nautilus/include/nautilus/val_ptr.hpp
index fa0e3372..c23de708 100644
--- a/nautilus/include/nautilus/val_ptr.hpp
+++ b/nautilus/include/nautilus/val_ptr.hpp
@@ -140,17 +140,7 @@ class val<ValuePtrType> : public base_ptr_val<ValuePtrType> {
 	}

 	val<ValType&> operator*()
-	    requires is_arithmetic<ValType>
-	{
-#ifdef ENABLE_TRACING
-		return val<ValType&>(*this, this->state);
-#else
-		return val<ValType&>(*this);
-#endif
-	}
-
-	val<ValType&> operator*()
-	    requires is_ptr<ValType>
+	    requires is_arithmetic<ValType> || is_ptr<ValType>
 	{
 #ifdef ENABLE_TRACING
 		return val<ValType&>(*this, this->state);

Subject: [PATCH] feat(Dref): Added [] to allowed dref of ref
---
Index: nautilus/include/nautilus/val_ptr.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/nautilus/include/nautilus/val_ptr.hpp b/nautilus/include/nautilus/val_ptr.hpp
--- a/nautilus/include/nautilus/val_ptr.hpp	(revision b7da82c328a7ea55412877d953a3313f218abf7c)
+++ b/nautilus/include/nautilus/val_ptr.hpp	(revision 34c0a95d393322e636e974d940478ba8c53e50a6)
@@ -151,7 +151,7 @@

 	template <class T>
 	val<ValType&> operator[](T&& io)
-	    requires is_arithmetic<ValType>
+	    requires is_arithmetic<ValType> || is_ptr<ValType>
 	{
 		auto indexOffset = static_cast<val<int32_t>>(io);
 		auto valuePtr = (*this) + indexOffset;
